
# ä»£ç†æ¨¡å¼


- **å®šä¹‰ï¼š** æä¾›ä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œå¹¶ç”±**ä»£ç†å¯¹è±¡æ§åˆ¶å¯¹åŸå¯¹è±¡çš„å¼•ç”¨**

- **ä½œç”¨ï¼š** ä¸­ä»‹éš”ç¦»(æŠŠ client ä¸ readSubject å¯¹è±¡è§£è€¦ï¼Œclient åªéœ€è¦ä¿¡ä»» proxy å¯¹è±¡å³å¯) ï¼Œç¬¦åˆå¼€é—­åŸåˆ™ï¼ˆå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼Œä¿®æ”¹proxy å³å¯ï¼Œä¸ç”¨ä¿®æ”¹ realSubjectï¼‰ï¼Œå¯ä»¥å®ç°åˆ‡é¢åœ¨ proxy å±‚å®ç°ç»Ÿä¸€å¤„ç†ï¼Œ

- **ç¼ºç‚¹ï¼š** å¢åŠ ç³»ç»Ÿçš„å¤æ‚æ€§

![alt text](image-20.png)





# RPC

æ ¹æ®ç»´åŸºç™¾ç§‘çš„å®šä¹‰ï¼ŒRPCï¼ˆRemote Procedure Callï¼‰ï¼Œå³è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼Œæ˜¯ä¸€ä¸ªè®¡ç®—æœºé€šä¿¡åè®®ã€‚è¯¥åè®®å…è®¸è¿è¡Œäºä¸€å°è®¡ç®—æœºçš„ç¨‹åºè°ƒç”¨å¦ä¸€å°è®¡ç®—æœºçš„å­ç¨‹åºï¼Œè€Œç¨‹åºå‘˜ä¸ç”¨é¢å¤–åœ°ä¸ºè¿™ä¸ªäº¤äº’ä½œç”¨ç¼–ç¨‹ã€‚

RPC çš„è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
![alt text](image-21.png)


RPC è°ƒç”¨å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š

1. Client é€šè¿‡æœ¬åœ°è°ƒç”¨ï¼Œè°ƒç”¨ Client Stubã€‚
   
2. Client Stub å°†å‚æ•°æ‰“åŒ…ï¼ˆä¹Ÿå« Marshallingï¼‰æˆä¸€ä¸ªæ¶ˆæ¯ï¼Œç„¶åå‘é€è¿™ä¸ªæ¶ˆæ¯ã€‚
   
3. Client æ‰€åœ¨çš„ OS å°†æ¶ˆæ¯å‘é€ç»™ Serverã€‚
   
4. Server ç«¯æ¥æ”¶åˆ°æ¶ˆæ¯åï¼Œå°†æ¶ˆæ¯ä¼ é€’ç»™ Server Stubã€‚
   
5. Server Stub å°†æ¶ˆæ¯è§£åŒ…ï¼ˆä¹Ÿå« Unmarshallingï¼‰å¾—åˆ°å‚æ•°ã€‚Server Stub è°ƒç”¨æœåŠ¡ç«¯çš„å­ç¨‹åºï¼ˆå‡½æ•°ï¼‰ï¼Œå¤„ç†å®Œåï¼Œå°†æœ€ç»ˆç»“æœæŒ‰ç…§ç›¸åçš„æ­¥éª¤è¿”å›ç»™ Clientã€‚



è¿™é‡Œéœ€è¦æ³¨æ„ï¼ŒStub è´Ÿè´£è°ƒç”¨å‚æ•°å’Œè¿”å›å€¼çš„æµåŒ–ï¼ˆserializationï¼‰ã€å‚æ•°çš„æ‰“åŒ…å’Œè§£åŒ…ï¼Œä»¥åŠç½‘ç»œå±‚çš„é€šä¿¡ã€‚Client ç«¯ä¸€èˆ¬å« Stubï¼ŒServer ç«¯ä¸€èˆ¬å« Skeletonã€‚

ç›®å‰ï¼Œä¸šç•Œæœ‰å¾ˆå¤šä¼˜ç§€çš„ RPC åè®®ï¼Œä¾‹å¦‚è…¾è®¯çš„ Tarsã€é˜¿é‡Œçš„ Dubboã€å¾®åšçš„Motanã€Facebook çš„ Thriftã€RPCXï¼Œç­‰ç­‰ã€‚ä½†ä½¿ç”¨æœ€å¤šçš„è¿˜æ˜¯î›¼gRPCï¼Œè¿™ä¹Ÿæ˜¯æœ¬ä¸“æ æ‰€é‡‡ç”¨çš„ RPC æ¡†æ¶ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥æˆ‘ä¼šé‡ç‚¹ä»‹ç» gRPC æ¡†æ¶ã€‚


# gRPC ä»‹ç»

gRPC æ˜¯ç”± Google å¼€å‘çš„é«˜æ€§èƒ½ã€å¼€æºã€è·¨å¤šç§ç¼–ç¨‹è¯­è¨€çš„é€šç”¨ RPC æ¡†æ¶ï¼ŒåŸºäº HTTP2.0 åè®®å¼€å‘ï¼Œé»˜è®¤é‡‡ç”¨ Protocol Buffers æ•°æ®åºåˆ—åŒ–åè®®ã€‚gRPC å…·æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼š

æ”¯æŒå¤šç§è¯­è¨€ï¼Œä¾‹å¦‚ Goã€Javaã€Cã€C++ã€C#ã€Node.jsã€PHPã€Pythonã€Ruby ç­‰ã€‚

åŸºäº IDLï¼ˆInterface Definition Languageï¼‰æ–‡ä»¶å®šä¹‰æœåŠ¡ï¼Œé€šè¿‡ proto3 å·¥å…·ç”ŸæˆæŒ‡å®šè¯­è¨€çš„æ•°æ®ç»“æ„ã€æœåŠ¡ç«¯æ¥å£ä»¥åŠå®¢æˆ·ç«¯ Stubã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œä¹Ÿå¯ä»¥å°†æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯è§£è€¦ï¼Œä½¿å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯å¯ä»¥å¹¶è¡Œå¼€å‘ã€‚é€šä¿¡åè®®åŸºäºæ ‡å‡†çš„ HTTP/2 è®¾è®¡ï¼Œæ”¯æŒåŒå‘æµã€æ¶ˆæ¯å¤´å‹ç¼©ã€å• TCP çš„å¤šè·¯å¤ç”¨ã€æœåŠ¡ç«¯æ¨é€ç­‰ç‰¹æ€§ã€‚

æ”¯æŒ `Protobuf` å’Œ `JSON` åºåˆ—åŒ–æ•°æ®æ ¼å¼ã€‚Protobuf æ˜¯ä¸€ç§è¯­è¨€æ— å…³çš„é«˜æ€§èƒ½åºåˆ—åŒ–æ¡†æ¶ï¼Œå¯ä»¥å‡å°‘ç½‘ç»œä¼ è¾“æµé‡ï¼Œæé«˜é€šä¿¡æ•ˆç‡ã€‚

![alt text](image-22.png)



åƒå¾ˆå¤šå…¶ä»–çš„ RPC æœåŠ¡ä¸€æ ·ï¼ŒgRPC ä¹Ÿæ˜¯é€šè¿‡ IDL è¯­è¨€ï¼Œé¢„å…ˆå®šä¹‰å¥½æ¥å£ï¼ˆæ¥å£çš„åå­—ã€ä¼ å…¥å‚æ•°å’Œè¿”å›å‚æ•°ç­‰ï¼‰ã€‚åœ¨æœåŠ¡ç«¯ï¼ŒgRPC æœåŠ¡å®ç°æˆ‘ä»¬æ‰€å®šä¹‰çš„æ¥å£ã€‚åœ¨å®¢æˆ·ç«¯ï¼ŒgRPC å­˜æ ¹æä¾›äº†è·ŸæœåŠ¡ç«¯ç›¸åŒçš„æ–¹æ³•ã€‚

gRPC API æ¥å£é€šå¸¸ä½¿ç”¨çš„æ•°æ®ä¼ è¾“æ ¼å¼æ˜¯ Protocol Buffersã€‚




# Protocol Buffers ä»‹ç»


Protocol Buffersï¼ˆProtocolBuffer/ protobufï¼‰æ˜¯ Google å¼€å‘çš„ä¸€å¥—å¯¹æ•°æ®ç»“æ„è¿›è¡Œåºåˆ—åŒ–çš„æ–¹æ³•ï¼Œå¯ç”¨ä½œï¼ˆæ•°æ®ï¼‰é€šä¿¡åè®®ã€æ•°æ®å­˜å‚¨æ ¼å¼ç­‰ï¼Œä¹Ÿæ˜¯ä¸€ç§æ›´åŠ çµæ´»ã€é«˜æ•ˆçš„æ•°æ®æ ¼å¼ï¼Œä¸ XMLã€JSON ç±»ä¼¼ã€‚å®ƒçš„ä¼ è¾“æ€§èƒ½éå¸¸å¥½ï¼Œæ‰€ä»¥å¸¸è¢«ç”¨åœ¨ä¸€äº›å¯¹æ•°æ®ä¼ è¾“æ€§èƒ½è¦æ±‚æ¯”è¾ƒé«˜çš„ç³»ç»Ÿä¸­ï¼Œä½œä¸ºæ•°æ®ä¼ è¾“æ ¼å¼ã€‚Protocol Buffers çš„ä¸»è¦ç‰¹æ€§æœ‰ä¸‹é¢è¿™å‡ ä¸ªï¼š

- æ›´å¿«çš„æ•°æ®ä¼ è¾“é€Ÿåº¦ï¼šprotobuf åœ¨ä¼ è¾“æ—¶ï¼Œä¼šå°†æ•°æ®åºåˆ—åŒ–ä¸ºäºŒè¿›åˆ¶æ•°æ®ï¼Œå’Œ XMLã€JSON çš„æ–‡æœ¬ä¼ è¾“æ ¼å¼ç›¸æ¯”ï¼Œè¿™å¯ä»¥èŠ‚çœå¤§é‡çš„ IO æ“ä½œï¼Œä»è€Œæé«˜æ•°æ®ä¼ è¾“é€Ÿåº¦ã€‚

- è·¨å¹³å°å¤šè¯­è¨€ï¼šprotobuf è‡ªå¸¦çš„ç¼–è¯‘å·¥å…· protoc å¯ä»¥åŸºäº protobuf å®šä¹‰æ–‡ä»¶ï¼Œç¼–è¯‘å‡ºä¸åŒè¯­è¨€çš„å®¢æˆ·ç«¯æˆ–è€…æœåŠ¡ç«¯ï¼Œä¾›ç¨‹åºç›´æ¥è°ƒç”¨ï¼Œå› æ­¤å¯ä»¥æ»¡è¶³å¤šè¯­è¨€éœ€æ±‚çš„åœºæ™¯ã€‚å…·æœ‰éå¸¸å¥½çš„æ‰©å±•æ€§å’Œå…¼å®¹æ€§ï¼Œå¯ä»¥æ›´æ–°å·²æœ‰çš„æ•°æ®ç»“æ„ï¼Œè€Œä¸ç ´åå’Œå½±å“åŸæœ‰çš„ç¨‹åºã€‚
  
- åŸºäº IDL æ–‡ä»¶å®šä¹‰æœåŠ¡ï¼Œé€šè¿‡ proto3 å·¥å…·ç”ŸæˆæŒ‡å®šè¯­è¨€çš„æ•°æ®ç»“æ„ã€æœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯æ¥å£ã€‚


## gRPCæ”¯æŒçš„è®¤è¯æ–¹å¼

1. alts è®¤è¯
   
   alts æ˜¯è°·æ­Œå¼€å‘çš„ä¸€ç§ **åŒå‘è®¤è¯** çš„è®¤è¯æ–¹å¼ï¼Œä¸»è¦ç”¨äºè°·æ­ŒåŸºç¡€è®¾æ–½å†…çš„ `rpc` é€šä¿¡è®¾è®¡

1. OAuthï¼ˆOpen Authorizationï¼‰
2. STS - STSï¼ˆSecure Token Serviceï¼Œå®‰å…¨ä»¤ç‰ŒæœåŠ¡ï¼‰
3. TLSï¼ˆTransport Layer Securityï¼‰
   TLSï¼ˆåŠå…¶å‰èº«SSLï¼‰æ˜¯gRPCä¸­æœ€å¸¸ç”¨çš„è®¤è¯å’ŒåŠ å¯†æ–¹å¼ä¹‹ä¸€ã€‚å®ƒé€šè¿‡åœ¨å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´å»ºç«‹åŠ å¯†é€šé“æ¥ä¿æŠ¤æ•°æ®çš„ä¼ è¾“å®‰å…¨ã€‚

4. XDSï¼ˆExtensible Discovery Serviceï¼‰
   XDSæœ¬èº«ä¸æ˜¯ä¸€ç§è®¤è¯æ–¹å¼ï¼Œè€Œæ˜¯Envoyä»£ç†ç­‰é¡¹ç›®ä¸­ç”¨äºåŠ¨æ€å‘ç°å’Œé…ç½®ç½‘ç»œæœåŠ¡çš„åè®®ã€‚ç„¶è€Œï¼Œåœ¨gRPCçš„éƒ¨ç½²å’Œé…ç½®ä¸­ï¼ŒXDSå¯ä»¥ä¸è®¤è¯æœºåˆ¶ç»“åˆä½¿ç”¨ï¼Œä»¥æä¾›çµæ´»çš„æœåŠ¡å‘ç°å’Œé…ç½®èƒ½åŠ›ã€‚
5. Localï¼ˆæœ¬åœ°ï¼‰è®¤è¯
   åœ¨å¼€å‘æˆ–æµ‹è¯•ç¯å¢ƒä¸­ï¼ŒgRPCå¯èƒ½ä½¿ç”¨æœ¬åœ°è®¤è¯æ–¹å¼ï¼Œå¦‚åŸºäºIPåœ°å€çš„ç™½åå•ã€ç®€å•çš„ç”¨æˆ·åå’Œå¯†ç éªŒè¯ç­‰ã€‚è¿™äº›æ–¹å¼é€šå¸¸ä¸ç”¨äºç”Ÿäº§ç¯å¢ƒï¼Œå› ä¸ºå®ƒä»¬ä¸æä¾›è¶³å¤Ÿçš„å®‰å…¨æ€§ã€‚

6. Insecureï¼ˆä¸å®‰å…¨ï¼‰è®¤è¯
7. 
   åœ¨gRPCä¸­ï¼Œè¿˜å¯ä»¥é€‰æ‹©ä¸ä½¿ç”¨ä»»ä½•è®¤è¯æ–¹å¼ï¼Œå³â€œä¸å®‰å…¨â€æ¨¡å¼ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„é€šä¿¡ä¸ä¼šåŠ å¯†ï¼Œä¹Ÿä¸ä¼šè¿›è¡Œèº«ä»½éªŒè¯ã€‚è¿™ç§æ–¹å¼ä»…é€‚ç”¨äºæµ‹è¯•æˆ–å¼€å‘ç¯å¢ƒï¼Œä¸åº”åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨ã€‚


## protobufå®‰è£…

1. ä¸‹è½½ `protoc` <https://github.com/protocolbuffers/protobuf/releases>
   
   æ ¹æ®ä¸åŒçš„ç³»ç»Ÿä¸‹è½½ä¸åŒçš„åŒ…ï¼Œåœ¨ windows ä¸‹è§£å‹åæ˜¯ `protoc.exe`

1. å°† `protoc.exe` æ‰€åœ¨è·¯å¾„é…ç½®åˆ°ç¯å¢ƒå˜é‡
2. 
   ä¸‹è½½å®Œæˆåï¼Œè§£å‹æ–‡ä»¶å¹¶å°† `bin` ç›®å½•æ·»åŠ åˆ°ä½ çš„ç³»ç»Ÿç¯å¢ƒå˜é‡ä¸­ã€‚åœ¨ `Linux` æˆ– `macOS` ä¸Šï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹ `.bashrc` æˆ– `.zshrc` æ–‡ä»¶å¹¶è¿è¡Œ `source ~/.bashrc` æˆ– `source ~/.zshrc` æ¥å®ç°ã€‚åœ¨ `Windows` ä¸Šï¼Œéœ€è¦é€šè¿‡ç³»ç»Ÿå±æ€§ä¸­çš„ç¯å¢ƒå˜é‡è®¾ç½®æ¥æ·»åŠ  `protoc` çš„è·¯å¾„ã€‚

3. å®‰è£… go è¯­è¨€ä¸“ç”¨çš„ `protoc` çš„ä»£ç ç”Ÿæˆå™¨
   ```bash
   go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
   go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
   ```
   å®‰è£…åä¼šåœ¨ GOPATH ç›®å½•ä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œ
  ![alt text](image-24.png)




## proto æ–‡ä»¶ç¼–å†™ä»‹ç»
proto æ–‡ä»¶å®šä¹‰å¦‚ä¸‹ï¼š
```go
// å®šä¹‰äº† proto çš„ç‰ˆæœ¬ ï¼Œç›®å‰æœ€æ–°ç‰ˆæœ¬ä¸º 3
syntax = "proto3";

//option å…³é”®å­—ç”¨æ¥å¯¹.proto æ–‡ä»¶è¿›è¡Œä¸€äº›è®¾ç½®ï¼Œ

//å…¶ä¸­go_package æ˜¯å¿…éœ€çš„è®¾ç½®ï¼Œè€Œä¸” go_package çš„å€¼å¿…é¡»æ˜¯åŒ…å¯¼å…¥çš„è·¯å¾„ã€‚package å…³é”®å­—æŒ‡å®šç”Ÿæˆçš„.pb.go æ–‡ä»¶æ‰€åœ¨çš„åŒ…åã€‚
//"."è¡¨ç¤ºç”Ÿæˆçš„Goæ–‡ä»¶å°†ä¸.protoæ–‡ä»¶ä½äºåŒä¸€ç›®å½•ä¸‹ï¼ˆæˆ–æ¨¡å—ä¸­ï¼‰
//"service"åˆ™æ˜¯åŒ…åã€‚è¿™æ„å‘€ç€æ‰€æœ‰ç”Ÿæˆçš„Goæ–‡ä»¶éƒ½å°†å±äºserviceåŒ…ã€‚
option go_package = ".;service";

//å¦‚æœå®¢æˆ·ç«¯ä¸éœ€è¦javaåˆ™æ— éœ€ç¼–å†™

////æŒ‡å®šäº†Javaä»£ç ä¸­ä½¿ç”¨çš„åŒ…åã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç”Ÿæˆçš„Javaç±»å°†è¢«æ”¾åœ¨io.grpc.examples.helloworldåŒ…ä¸­
//option java_package = "io.grpc.examples.helloworld";
////å½“ä½¿ç”¨protocï¼ˆProtocol Buffersç¼–è¯‘å™¨ï¼‰ä¸ºJavaç”Ÿæˆä»£ç æ—¶ï¼Œå¦‚æœ.protoæ–‡ä»¶ä¸­å®šä¹‰äº†å¤šä¸ªæ¶ˆæ¯æˆ–æœåŠ¡ï¼Œå®ƒä»¬é€šå¸¸ä¼šè¢«æ”¾åœ¨ä¸€ä¸ªå¤–éƒ¨ç±»ä¸­ã€‚
//// è¿™ä¸ªé€‰é¡¹å…è®¸ä½ ä¸ºè¿™ä¸ªå¤–éƒ¨ç±»æŒ‡å®šä¸€ä¸ªè‡ªå®šä¹‰çš„åç§°ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„åŸºäºæ–‡ä»¶åç”Ÿæˆçš„åç§°
//option java_outer_classname = "HelloWorldProto";
////è¿™ä¸ªé€‰é¡¹æ§åˆ¶æ˜¯å¦åº”è¯¥ä¸ºæ¯ä¸ªå®šä¹‰ï¼ˆå¦‚æ¶ˆæ¯ã€æšä¸¾ã€æœåŠ¡ç­‰ï¼‰åœ¨Javaä¸­ç”Ÿæˆå•ç‹¬çš„æ–‡ä»¶ã€‚å½“è®¾ç½®ä¸ºtrueæ—¶ï¼Œæ¯ä¸ªå®šä¹‰éƒ½å°†è¢«æ”¾ç½®åœ¨å…¶è‡ªå·±çš„.javaæ–‡ä»¶ä¸­ï¼Œè€Œä¸æ˜¯å…¨éƒ¨æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚è¿™æœ‰åŠ©äºå‡å°‘å•ä¸ªæ–‡ä»¶çš„å¤§å°ï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
//option java_multiple_files = true;

//å®šä¹‰ Protobuf æ–‡ä»¶çš„åŒ…å
package helloworld;

// æœåŠ¡å®šä¹‰ï¼šé€šè¿‡ service å…³é”®å­—å®šä¹‰æœåŠ¡
service Greeter {
  //å‘é€é—®å€™
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// å®šä¹‰ä¸€ä¸ªæšä¸¾  
enum PhoneType {  
  MOBILE = 0;  
  HOME = 1;  
  WORK = 2;  
}  

// æ¶ˆæ¯ä½“ï¼šé€šè¿‡ message å…³é”®å­—å®šä¹‰
//        æ­¤å¤„ä¸ºè¯·æ±‚
message HelloRequest {
  //æ¶ˆæ¯å­—æ®µï¼ŒåŠå­—æ®µåœ¨æ¶ˆæ¯ä¸­çš„ä½ç½®
  string                      name = 1;
  PhoneType                   mtype = 2;
  map<string, int32>          my_map_field = 3;
  repeated string             users = 4;  // ä½¿ç”¨ repeated å…³é”®å­—è¡¨ç¤ºä¸å®šé•¿æ•°ç»„
  // ä½¿ç”¨Int32ValueåŒ…è£…ç±»å‹æ¥æ¨¡æ‹Ÿå¯é€‰çš„int32å­—æ®µ  
  // éœ€è¦ä»google/protobuf/wrappers.protoå¯¼å…¥åŒ…è£…ç±»å‹
  google.protobuf.Int32Value  optional_int32 = 1;  
}

// æ¶ˆæ¯ä½“ï¼šé€šè¿‡ message å…³é”®å­—å®šä¹‰
//        æ­¤å¤„ä¸ºå“åº”
message HelloReply {
  string                message = 1;
  PhoneType             mtype = 2;
  map<string, int32>    my_map_field = 3;
  repeated string       users = 4;  
}
```
## Protocol Bufffersä¸­çš„æ•°æ®ç±»å‹

**åŸºæœ¬æ ‡é‡ç±»å‹ï¼š**
1. æ•´æ•°ç±»å‹
   - int32ï¼šæœ‰ç¬¦å·32ä½æ•´æ•°ã€‚èŒƒå›´ä»-231åˆ°231-1ã€‚
   - int64ï¼šæœ‰ç¬¦å·64ä½æ•´æ•°ã€‚èŒƒå›´ä»-263åˆ°263-1ã€‚
   - uint32ï¼šæ— ç¬¦å·32ä½æ•´æ•°ã€‚èŒƒå›´ä»0åˆ°2^32-1ã€‚
   - uint64ï¼šæ— ç¬¦å·64ä½æ•´æ•°ã€‚èŒƒå›´ä»0åˆ°2^64-1ã€‚
  
   - sint32ï¼šä½¿ç”¨ZigZagç¼–ç çš„æœ‰ç¬¦å·32ä½æ•´æ•°ã€‚è¿™æœ‰åŠ©äºæ›´æœ‰æ•ˆåœ°ä½¿ç”¨è¾ƒå°çš„æ•´æ•°ã€‚
   - sint64ï¼šä½¿ç”¨ZigZagç¼–ç çš„æœ‰ç¬¦å·64ä½æ•´æ•°ã€‚
  
  
   - fixed32ï¼šæ— ç¬¦å·ï¼Œæ€»æ˜¯4ä¸ªå­—èŠ‚ï¼Œå¦‚æœå€¼éœ€è¦å°‘äº4ä¸ªå­—èŠ‚ï¼Œåˆ™é«˜ä½è¡¥é›¶ã€‚
   - fixed64ï¼šæ— ç¬¦å·ï¼Œæ€»æ˜¯8ä¸ªå­—èŠ‚ï¼Œå¦‚æœå€¼éœ€è¦å°‘äº8ä¸ªå­—èŠ‚ï¼Œåˆ™é«˜ä½è¡¥é›¶ã€‚
   - sfixed32ï¼šæœ‰ç¬¦å·çš„32ä½æ•´æ•°ï¼Œæ€»æ˜¯4ä¸ªå­—èŠ‚ã€‚
   - sfixed64ï¼šæœ‰ç¬¦å·çš„64ä½æ•´æ•°ï¼Œæ€»æ˜¯8ä¸ªå­—èŠ‚ã€‚
  
1. æµ®ç‚¹ç±»å‹
   - floatï¼šIEEE 754æ ‡å‡†ä¸‹çš„32ä½æµ®ç‚¹æ•°ã€‚
   - doubleï¼šIEEE 754æ ‡å‡†ä¸‹çš„64ä½æµ®ç‚¹æ•°ã€‚
  
    æµ®ç‚¹ç±»å‹çš„åŒºåˆ«åœ¨äºå®ƒä»¬çš„ç²¾åº¦å’ŒèŒƒå›´ã€‚doubleç±»å‹æä¾›äº†æ¯”floatç±»å‹æ›´é«˜çš„ç²¾åº¦å’Œæ›´å¤§çš„èŒƒå›´ã€‚

2. å¸ƒå°”ç±»å‹
   
   boolï¼šå¸ƒå°”å€¼ï¼Œå¯ä»¥æ˜¯trueæˆ–falseã€‚

3. å­—ç¬¦ä¸²ç±»å‹
   
    stringï¼šä¸€ä¸ªå­—ç¬¦ä¸²å¿…é¡»æ˜¯UTF-8ç¼–ç æˆ–7ä½ASCIIæ–‡æœ¬ã€‚
4. å­—èŠ‚ç±»å‹
    bytesï¼šå­—èŠ‚åºåˆ—ï¼Œå¯èƒ½åŒ…å«ä»»æ„æ•°æ®ï¼ˆåŒ…æ‹¬0ï¼‰ã€‚

**æšä¸¾ç±»å‹ï¼ˆEnumï¼‰**ï¼šå…è®¸å¼€å‘è€…å®šä¹‰ä¸€ç»„å‘½åçš„æ•´å‹å¸¸é‡ã€‚
  
**å¤åˆç±»å‹ï¼š**
  - æ¶ˆæ¯ï¼ˆMessageï¼‰ï¼šå¯ä»¥åŒ…å«åµŒå¥—çš„æ¶ˆæ¯å’Œå­—æ®µï¼Œç”¨äºå®šä¹‰å¤æ‚çš„æ•°æ®ç»“æ„ã€‚
  - æ˜ å°„ï¼ˆMapï¼‰ï¼šé”®å€¼å¯¹çš„é›†åˆï¼Œé”®å’Œå€¼å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼ˆé™¤äº†å¦ä¸€ä¸ªæ˜ å°„æˆ–åµŒå¥—çš„æ¶ˆæ¯ç±»å‹ï¼‰ã€‚
  
**ç‰¹æ®Šç±»å‹**ï¼šå¦‚Anyï¼ˆå¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„åºåˆ—åŒ–æ¶ˆæ¯ï¼Œå¹¶é™„åŠ ç±»å‹ä¿¡æ¯ï¼‰ã€Timestampï¼ˆè¡¨ç¤ºæ—¶é—´ç‚¹çš„å…·ä½“å€¼ï¼‰ã€Durationï¼ˆè¡¨ç¤ºæ—¶é—´é—´éš”ï¼‰ç­‰ï¼Œè¿™äº›ç±»å‹åœ¨google/protobuf/any.protoã€google/protobuf/timestamp.protoå’Œgoogle/protobuf/duration.protoç­‰æ–‡ä»¶ä¸­å®šä¹‰ã€‚

## ç¼–è§£ç åŸç†

![alt text](image-23.png)

- Base 128 Varints ï¼šå¯å˜å­—èŠ‚é•¿åº¦ç¼–ç ï¼Œæ›´å°çš„æ•°å­—å ç”¨æ›´å°çš„å­—èŠ‚
- 
  æ‹¬int32ã€int64ã€uint32ã€uint64ã€sint32ã€sint64ç­‰ã€‚è¿™äº›æ•´å‹æ•°æ®åœ¨åºåˆ—åŒ–æ—¶ï¼Œå¦‚æœå…¶ç»å¯¹å€¼è¾ƒå°ï¼Œåˆ™å¯ä»¥ä½¿ç”¨è¾ƒå°‘çš„å­—èŠ‚è¿›è¡Œç¼–ç ï¼Œä»è€Œå®ç°ç©ºé—´çš„æœ‰æ•ˆåˆ©ç”¨ã€‚Base 128 Varintsç¼–ç åˆ©ç”¨æ¯ä¸ªå­—èŠ‚çš„æœ€é«˜ä½ï¼ˆmsbï¼‰ä½œä¸ºç»­è¡Œæ ‡å¿—ï¼Œå¦‚æœæœ€é«˜ä½ä¸º1ï¼Œåˆ™è¡¨ç¤ºåç»­è¿˜æœ‰å­—èŠ‚ï¼›å¦‚æœæœ€é«˜ä½ä¸º0ï¼Œåˆ™è¡¨ç¤ºè¿™æ˜¯æœ€åä¸€ä¸ªå­—èŠ‚ã€‚å‰©ä½™çš„7ä½ç”¨äºå­˜å‚¨æ•°æ®çš„å®é™…å€¼ã€‚
  
  æ¯ä¸ªå­—èŠ‚çš„ç¬¬ä¸€ä½ï¼Œè¡¨ç¤ºåç»­æ˜¯å¦è¿˜æœ‰æ•°å­—ï¼Œåé¢çš„ 7 ä½è¡¨ç¤ºå®é™…çš„æ•°æ®

- æ¶ˆæ¯ç¼–ç  = key + value , key = å­—æ®µç¼–å· + å­—æ®µç±»å‹
  
- æœ‰ç¬¦å·æ•´å‹ï¼Œä½¿ç”¨ ZigZag ç®—æ³•ç¼–ç 
  
- Non-varintæ•°å­— - æ— å˜åŒ–ï¼š key + 32/64ä½çš„å­—èŠ‚
  
  double ã€ float ã€ fixed32 64 ã€ sfixed32 64

- å­—ç¬¦ä¸²ç¼–ç ï¼Œ key + é•¿åº¦ + å­—ç¬¦ä¸²
  
- å¤åˆç»“æ„æ¶ˆæ¯ï¼šå†…éƒ¨çš„æ¶ˆæ¯è¢«å½“åšå­—ç¬¦ä¸²å¯¹å¾…


**å­—æ®µé¡ºåº**
æ— åºï¼ˆåºåˆ—åŒ–ä¹‹åä¹Ÿä¸ä¿è¯æœ‰åºï¼Œæ‰€ä»¥å¯¹äºåŒä¸€ä¸ªæ¶ˆæ¯è¿›è¡Œä¸¤æ¬¡åºåˆ—åŒ–ï¼Œå¾—åˆ°çš„äºŒè¿›åˆ¶å¯èƒ½ä¼šæœ‰å·®å¼‚ï¼‰ï¼Œä½†æ˜¯å­—æ®µç¼–å·ä¸èƒ½éšä¾¿ä¿®æ”¹


**æœªçŸ¥å­—æ®µ**
æ— æ³•è¯†åˆ«çš„å­—æ®µï¼Œä¼šè¢«ä¿ç•™åœ¨åºåˆ—åŒ–è¾“å‡ºä¸­

## å¦‚ä½•å®‰å…¨çš„æ›´æ–°å­—æ®µ

- ä¸èƒ½æ”¹å˜å­—æ®µçš„ç¼–å·
- int32ã€uint64ã€boolæ˜¯å¯ä»¥äº’ç›¸å…¼å®¹çš„ï¼Œsint32 å’Œ sint64ä¹Ÿå…¼å®¹
- string ã€ bytes ã€ message fields ã€ optionnal å’Œ repeated å…¼å®¹
- fixed32/64 å’Œ sfixed32/64 å…¼å®¹
- bytes æ˜¯æœ‰æ•ˆçš„ utf8 ç±»å‹çš„æ—¶å€™ï¼Œ string å’Œ bytes æ˜¯å…¼å®¹çš„
- æšä¸¾å’Œ int32ï¼Œuint64 å…¼å®¹ï¼Œå¦‚æœç±»å‹ä¸åŒ¹é…ï¼Œä¼šå‘ç”Ÿæˆªæ–­


# gRPC hello world

## ç¼–å†™ proto æ–‡ä»¶

`hello.proto`

```go
//ç‰ˆæœ¬å·
syntax = "proto3";

// ./service è¡¨ç¤ºåœ¨ä¸‹ ./service ç”Ÿæˆ
// service åˆ™è¡¨ç¤ºç”Ÿæˆçš„go æ–‡ä»¶çš„åŒ…å
option go_package = "./service;service";

// å¼•å…¥å½“å‰ç›®å½•ä¸‹æ–‡ä»¶
import "user.proto";
// å¼•å…¥æ ‡å‡†åº“ä¸‹æ–‡ä»¶
import "google/protobuf/any.proto";

// åŒ…å
package service;

message DataMsg {
    string data = 1;
}


// æ¶ˆæ¯
message HelloRequest {
    string msg = 1;
    //å¯é€‰ - å¯é€‰å€¼ä¼šè¢«ç¼–è¯‘ä¸ºæŒ‡é’ˆç±»å‹
    optional string msg2 = 2;
    //å¯é‡å¤ - åœ¨go ä¸­è¡¨ç°ä¸ºåˆ‡ç‰‡
    repeated string address = 3;

    User user = 4;
}

// æ¶ˆæ¯ - å“åº”
message HelloReply {
    string msg = 1;
    google.protobuf.Any data = 2;
}

service Greeter {
    // æ™®é€š RPC
    rpc SayHello (HelloRequest) returns (HelloReply) {}
    // å®¢æˆ·ç«¯æµå¼ RPC
    rpc ClientStream (stream HelloRequest) returns (HelloReply) {}
    // æœåŠ¡å™¨ç«¯æµå¼ RPC
    rpc ServerStream (HelloRequest) returns (stream HelloReply) {}
    // åŒå‘æµå¼ RPC
    rpc TwoStream (stream HelloRequest) returns (stream HelloReply) {}
}
```

user.prodo
```go
syntax = "proto3";

option go_package = "./service;service";

package service;

message User{
    string name = 1;
}
```





ç”Ÿæˆ `pb.go` æ–‡ä»¶
```bash
protoc --go_out=../ *.proto
```
- `--go_out` : æŒ‡å®š `pd.go` æ–‡ä»¶è¾“å‡ºç›®å½•
- `*.proto` : è¡¨ç¤ºç¼–è¯‘å½“å‰ç›®å½•ä¸‹æ‰€æœ‰ä»¥ `proto` ç»“å°¾çš„æ–‡ä»¶


ç”Ÿæˆ `xx_grpc.pb.go` æ–‡ä»¶
```bash
# --proto_path æŒ‡å‘ proto æ–‡ä»¶çš„è·¯å¾„
# åœ¨æœ¬å‘½ä»¤ä¸­ä¸€ä¸ªæŒ‡å‘ï¼Œå½“å‰ç›®å½•ï¼Œå¦ä¸€ä¸ªæŒ‡å‘protoæ ‡å‡†åº“ç›®å½•
protoc --proto_path=. --proto_path=C:\my\protoc-28.0-rc-1-win64\include  --go-grpc_out=../  *.proto
```
ä¹Ÿå¯ä»¥å°†è¿™ä¸¤ç±»æ–‡ä»¶åŒæ—¶ç”Ÿæˆ
```bash
protoc --proto_path=. --proto_path=C:\my\protoc-28.0-rc-1-win64\include  --go_out=../ --go-grpc_out=../  *.proto
```

## é€šè¿‡ `proto` è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–

```go
func main() {
    hello := &service.HelloRequest{
        Msg:     "hello world",
        Address: []string{"1", "2", "3"},
    }
    // åºåˆ—åŒ–
    marshal, err := proto.Marshal(hello)
    if err != nil {
        panic(err)
    }
    //ååºåˆ—åŒ–
    newHello := &service.HelloRequest{}
    err = proto.Unmarshal(marshal, newHello)
    if err != nil {
        panic(err)
    }
    fmt.Printf("%+v\n", newHello)
}
```

## ä½¿ç”¨æ— è®¤è¯æ–¹å¼è¿›è¡ŒgRPCé€šä¿¡


æˆ‘ä»¬å‰é¢å·²ç»ç”Ÿæˆå¥½äº† `pd.go` å’Œ `xxxgrpc_pd.go` æ¥ä¸‹æ¥ç›´æ¥ç¼–å†™ï¼ŒæœåŠ¡ç«¯å’Œå®¢æˆ·ç«¯æ–‡ä»¶ï¼š

**æœåŠ¡ç«¯**ï¼šæœåŠ¡ç«¯éœ€è¦å®ç° `.proto` å®šä¹‰çš„æœåŠ¡ï¼Œç„¶åå°†æœåŠ¡æ³¨å†Œåˆ° `gRPC` ã€‚
```go
// éœ€è¦å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ç»§æ‰¿ service.UnimplementedGreeterServer
type server struct {
    service.UnimplementedGreeterServer
}

// ç„¶åå®ç° SayHello æ–¹æ³•
func (c *server) SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloReply, error) {
    log.Printf("è¯·æ±‚å€¼ï¼š %v", req)
  // ä½¿ç”¨ protoc çš„ any ç±»å‹
    a, _ := anypb.New(&service.DataMsg{Data: "data is me"})
    return &service.HelloReply{
        Msg:  "hello",
        Data: a,
    }, nil
}

// æœåŠ¡ç«¯
func TestServer(t *testing.T) {
  // ç›‘å¬ç«¯å£
    listen, _ := net.Listen("tcp", ":9090")
  // åˆ›å»º grpcæœåŠ¡ - æ­¤å¤„æ²¡æœ‰å¢åŠ ä»»ä½•é€šä¿¡éªŒè¯
    rpcServer := grpc.NewServer()

  // æ³¨å†ŒæœåŠ¡
    service.RegisterGreeterServer(rpcServer, &server{})

  // å¯åŠ¨æœåŠ¡ - è¿™é‡Œä¼šé˜»å¡ä½
    err := rpcServer.Serve(listen)
    if err != nil {
        fmt.Printf("failed to serve: %v", err)
        panic(err)
    } 
}
```

**å®¢æˆ·ç«¯**ï¼š
1. éœ€è¦åˆ›å»ºå®¢æˆ·ç«¯ï¼Œå¹¶è®¾ç½®è®¤è¯æ–¹å¼
2. è°ƒç”¨ç”ŸæˆæœåŠ¡

å®¢æˆ·ç«¯ä»£ç -ä½¿ç”¨ `dial` æ–¹å¼åˆ›å»ºå®¢æˆ·ç«¯ï¼Œæ³¨æ„åœ¨æœ€æ–°ç‰ˆæœ¬ä¸­ `dial` å·²ç»è¢«æ‰“ä¸ŠåºŸå¼ƒæ ‡ç­¾
```go
// å®¢æˆ·ç«¯-ä½¿ç”¨ Dial æ–¹å¼åˆ›å»º - ä¸éªŒè¯
func TestInsecureClientDial(t *testing.T) {

    client, err := grpc.Dial("127.0.0.1:9090",
        grpc.WithInsecure(),           // è¿™ä¸ªé€‰é¡¹å‘Šè¯‰ gRPC å®¢æˆ·ç«¯å¿½ç•¥ TLS è¯ä¹¦éªŒè¯
        grpc.WithBlock(),              // è¿™ä¸ªé€‰é¡¹ä¼šè®© Dial é˜»å¡ï¼Œç›´åˆ°è¿æ¥å»ºç«‹æˆ–å‘ç”Ÿé”™è¯¯
        grpc.WithTimeout(time.Second)) // è®¾ç½®è¿æ¥è¶…æ—¶æ—¶é—´ä¸º 1 ç§’
    if err != nil {
        log.Fatalf("æœªè¿æ¥ï¼š %v", err)
    }
    defer client.Close()

    greeterClient := service.NewGreeterClient(client)
    hello, err := greeterClient.SayHello(context.Background(), &service.HelloRequest{Msg: "01"})
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Printf("è¿”å›å€¼ %v", hello)
}
```

å®¢æˆ·ç«¯ä»£ç -ä½¿ç”¨ `NewClient` æ–¹å¼åˆ›å»ºå®¢æˆ·ç«¯
```go
func TestInsecureClient(t *testing.T) {
    // åˆ›å»ºä¸€ä¸ªä¸å®‰å…¨çš„å®¢æˆ·ç«¯å‡­æ®ï¼Œè¿™é€šå¸¸ç”¨äºæµ‹è¯•ç¯å¢ƒï¼Œä¸å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨
    cred := insecure.NewCredentials()
    // ä½¿ç”¨ä¸Šè¿°å‡­æ®é…ç½®gRPCçš„ä¼ è¾“å‡­æ®
    transportCredentials := grpc.WithTransportCredentials(cred)

    //å°è¯•ä½¿ç”¨é…ç½®çš„å‡­æ®è¿æ¥åˆ°gRPCæœåŠ¡å™¨
    client, err := grpc.NewClient("127.0.0.1:9090", transportCredentials)

    if err != nil {
        log.Fatalf("æœªè¿æ¥ï¼š %v", err) //å¦‚æœé”™è¯¯åˆ™é€€å‡º
    }
    defer client.Close() //æœ€åå…³é—­ è¿æ¥

    //åˆ›å»ºä¸€ä¸ªGreeteræœåŠ¡çš„å®¢æˆ·ç«¯
    greeterClient := service.NewGreeterClient(client)

    // è°ƒç”¨GreeteræœåŠ¡çš„SayHelloæ–¹æ³•ï¼Œå‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”
    hello, err := greeterClient.SayHello(context.Background(), &service.HelloRequest{Msg: "01"})
    if err != nil {
        fmt.Println(err)
        return
    }

  //å°† any ç±»å‹ååºåˆ—åŒ– ä¸º service.DataMsg
  var dd service.DataMsg
    err = hello.Data.UnmarshalTo(&dd)

    fmt.Printf("è¿”å›å€¼ %s , %s \n", hello.Msg, dd.Data)
}
```

## ä½¿ç”¨æ‹¦æˆªå™¨è¿›è¡ŒéªŒè¯

æœåŠ¡ç«¯ä»£ç 
```go
func TestTokenServer(t *testing.T) {
    //æ‹¦æˆªå™¨
    var authInterceptor grpc.UnaryServerInterceptor
    authInterceptor = func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (resp interface{}, err error) {
        //æ‹¦æˆªæ™®é€šæ–¹æ³•è¯·æ±‚ï¼ŒéªŒè¯ Token
        err = Auth(ctx)
        if err != nil {
            return
        }
        // ç»§ç»­å¤„ç†è¯·æ±‚
        return handler(ctx, req)
    }
    //å¯åŠ¨æœåŠ¡æ—¶æ³¨å†Œæ‹¦æˆªå™¨
    server := grpc.NewServer(grpc.UnaryInterceptor(authInterceptor))
    service.RegisterGreeterServer(server, &RpcServer{})

    listener, err := net.Listen("tcp", ":8002")
    if err != nil {
        log.Fatal("æœåŠ¡ç›‘å¬ç«¯å£å¤±è´¥", err)
    }
    err = server.Serve(listener)
    if err != nil {
        log.Fatal("æœåŠ¡ã€å¯åŠ¨å¤±è´¥", err)
    }
    fmt.Println("å¯åŠ¨æˆåŠŸ")
}
func Auth(ctx context.Context) error {
    //å–å‡ºå€¼
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return fmt.Errorf("missing credentials")
    }
    var user string
    var password string

    if val, ok := md["user"]; ok {
        user = val[0]
    }
    if val, ok := md["password"]; ok {
        password = val[0]
    }

    if user != "admin" || password != "admin" {
        return status.Errorf(codes.Unauthenticated, "tokenä¸åˆæ³•")
    }
    return nil
}
```

å®¢æˆ·ç«¯ä»£ç 
```go
// å®¢æˆ·ç«¯ å®ç° éªŒè¯å™¨ - PerRPCCredentials
type Authentication struct {
    User     string
    Password string
}

// å®ç°è·å–æ•°æ®æ–¹æ³•
func (a *Authentication) GetRequestMetadata(context.Context, ...string) (
    map[string]string, error,
) {
    return map[string]string{"user": a.User, "password": a.Password}, nil
}

// æ˜¯å¦éœ€è¦ tls çš„å®‰å…¨æ€§
func (a *Authentication) RequireTransportSecurity() bool {
    return false
}

func TestTokenClient(t *testing.T) {
    user := &Authentication{
        User:     "admin",
        Password: "admin",
    }
    client, err := grpc.NewClient(":8002", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithPerRPCCredentials(user))

    if err != nil {
        log.Fatalf("æœªè¿æ¥ï¼š %v", err) //å¦‚æœé”™è¯¯åˆ™é€€å‡º
    }
    defer client.Close() //æœ€åå…³é—­ è¿æ¥

    //åˆ›å»ºä¸€ä¸ªGreeteræœåŠ¡çš„å®¢æˆ·ç«¯
    greeterClient := service.NewGreeterClient(client)
    background := context.Background()
    // è°ƒç”¨GreeteræœåŠ¡çš„SayHelloæ–¹æ³•ï¼Œå‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”
    hello, err := greeterClient.SayHello(background,
        &service.HelloRequest{
            Msg:  "01",
            User: &service.User{Name: "123"},
        },
    )
    if err != nil {
        fmt.Println(err)
        return
    }
    var dd service.DataMsg
    err = hello.Data.UnmarshalTo(&dd)

    fmt.Printf("è¿”å›å€¼ %s , %s \n", hello.Msg, dd.Data)

}
```




## ç”Ÿæˆè‡ªç­¾è¯ä¹¦


åœ¨ `openssl.cnf` æ–‡ä»¶ä¸­æŒ‡å®šåŸŸå
1. æ‰“å¼€ copy_extensions = copy
2. æ‰“å¼€ req_extensions = v3_req
3. æ‰¾åˆ°[ v3_req ],æ·»åŠ  subjectAltName = @alt_names
4. æ·»åŠ æ–°çš„æ ‡ç­¾ [ alt_names ] , å’Œæ ‡ç­¾å­—æ®µ
   ```
    [ alt_names ]
    DNS.1 = *.mszlu.com
   ```
ç”Ÿæˆ ca è¯ä¹¦ã€æœåŠ¡ç«¯ã€å®¢æˆ·ç«¯è¯ä¹¦ï¼Œå¹¶ä½¿ç”¨ ca è¯ä¹¦å¯¹æœåŠ¡ç«¯ã€å®¢æˆ·ç«¯è¯ä¹¦ç­¾å
```bash
# ç”ŸæˆCAç§é’¥å’Œè¯ä¹¦
openssl genrsa -out ca.key 4096
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.pem -subj "/CN=my-ca"

# ç”ŸæˆæœåŠ¡å™¨ç§é’¥å’ŒCSR
openssl genrsa -out server.key 4096
openssl req -new -key server.key -out server.csr -config openssl.cnf

# ä½¿ç”¨CAç­¾ç½²æœåŠ¡å™¨è¯ä¹¦
openssl x509 -req -in server.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out server.pem -days 3650 -sha256 -extfile openssl.cnf -extensions req_ext

# ç”Ÿæˆå®¢æˆ·ç«¯ç§é’¥å’ŒCSR
openssl genrsa -out client.key 4096
openssl req -new -key client.key -out client.csr -config openssl.cnf

# ä½¿ç”¨CAç­¾ç½²å®¢æˆ·ç«¯è¯ä¹¦
openssl x509 -req -in client.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out client.pem -days 3650 -sha256 -extfile openssl.cnf -extensions req_ext
```

## åŸºäºtlsè¿›è¡Œå•å‘è®¤è¯
æœåŠ¡å®ç°-åŒä¸Š


æœåŠ¡ç«¯
```go
func TestTlsServer(t *testing.T) {
    //æ·»åŠ è¯ä¹¦
    file, err2 := credentials.NewServerTLSFromFile("./keys/server.pem", "./keys/server.key")
    if err2 != nil {
        log.Fatal("è¯ä¹¦ç”Ÿæˆé”™è¯¯", err2)
    }
    rpcServer := grpc.NewServer(grpc.Creds(file))

    service.RegisterGreeterServer(rpcServer, &RpcServer{})

    listener, err := net.Listen("tcp", ":8002")
    if err != nil {
        log.Fatal("å¯åŠ¨ç›‘å¬å‡ºé”™", err)
    }
    err = rpcServer.Serve(listener)
    if err != nil {
        log.Fatal("å¯åŠ¨æœåŠ¡å‡ºé”™", err)
    }
    fmt.Println("å¯åŠ¨grpcæœåŠ¡ç«¯æˆåŠŸ")
}
```

å®¢æˆ·ç«¯
```go
func TestClient(t *testing.T) {
    file, err2 := credentials.NewClientTLSFromFile("./keys/server.pem", "*.mszlu.com")
    if err2 != nil {
        log.Fatal("è¯ä¹¦é”™è¯¯", err2)
    }
    conn, err := grpc.NewClient(":8002", grpc.WithTransportCredentials(file))

    if err != nil {
        log.Fatal("æœåŠ¡ç«¯å‡ºé”™ï¼Œè¿æ¥ä¸ä¸Š", err)
    }
    defer conn.Close()

    prodClient := service.NewGreeterClient(conn)

    request := &service.HelloRequest{
        Msg: "123",
    }
    stockResponse, err := prodClient.SayHello(context.Background(), request)
    if err != nil {
        log.Fatal("æŸ¥è¯¢å‡ºé”™", err)
    }
    fmt.Println("æŸ¥è¯¢æˆåŠŸ", stockResponse)
}
```

## åŸºäºtlsè¿›è¡ŒåŒå‘è®¤è¯

æœåŠ¡å®ç°-åŒä¸Š


æœåŠ¡ç«¯
```go
func TestTwo2TlsServer(t *testing.T) {
    // åŠ è½½CAè¯ä¹¦
    caCert, err := os.ReadFile("./keys2/ca.pem")
    if err != nil {
        log.Fatalf("caè¯ä¹¦åŠ è½½å¤±è´¥: %v", err)
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    // åŠ è½½æœåŠ¡å™¨è¯ä¹¦å’Œå¯†é’¥
    serverCert, err := tls.LoadX509KeyPair("./keys2/server.pem", "./keys2/server.key")
    if err != nil {
        log.Fatalf("æœåŠ¡ç«¯è¯ä¹¦åŠ è½½å¤±è´¥: %v", err)
    }

    // é…ç½®TLS
    creds := credentials.NewTLS(&tls.Config{
        Certificates: []tls.Certificate{serverCert},
        ClientAuth:   tls.RequireAndVerifyClientCert,
        ClientCAs:    caCertPool,
    })

    rpcServer := grpc.NewServer(grpc.Creds(creds))
    service.RegisterGreeterServer(rpcServer, &RpcServer{})

    listener, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatal("å¯åŠ¨ç›‘å¬å‡ºé”™", err)
    }
    err = rpcServer.Serve(listener)
    if err != nil {
        log.Fatal("å¯åŠ¨æœåŠ¡å‡ºé”™", err)
    }
    fmt.Println("å¯åŠ¨grpcæœåŠ¡ç«¯æˆåŠŸ")
}
```
å®¢æˆ·ç«¯
```go
func TestTwo2TlsClient(t *testing.T) {

    // åŠ è½½CAè¯ä¹¦
    caCert, err := os.ReadFile("./keys2/ca.pem")
    if err != nil {
        log.Fatalf("caè¯ä¹¦åŠ è½½å¤±è´¥: %v", err)
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    // åŠ è½½å®¢æˆ·ç«¯è¯ä¹¦å’Œå¯†é’¥
    clientCert, err := tls.LoadX509KeyPair("./keys2/client.pem", "./keys2/client.key")
    if err != nil {
        log.Fatalf("å®¢æˆ·ç«¯è¯ä¹¦åŠ è½½å¤±è´¥: %v", err)
    }

    // é…ç½®TLS
    creds := credentials.NewTLS(&tls.Config{
        Certificates: []tls.Certificate{clientCert},
        ServerName:   "*.mszlu.com",
        RootCAs:      caCertPool,
    })

    conn, err := grpc.NewClient(":50051", grpc.WithTransportCredentials(creds))
    if err != nil {
        log.Fatalf("è¿æ¥å¤±è´¥: %v", err)
    }
    defer conn.Close()

    prodClient := service.NewGreeterClient(conn)

    request := &service.HelloRequest{
        Msg: "123",
    }
    stockResponse, err := prodClient.SayHello(context.Background(), request)
    if err != nil {
        log.Fatal("æŸ¥è¯¢å‡ºé”™", err)
    }
    fmt.Println("æŸ¥è¯¢æˆåŠŸ", stockResponse)
}
```
é€šå¸¸æ¥è¯´ï¼Œé™¤äº†éœ€è¦æœåŠ¡å™¨ã€å®¢æˆ·ç«¯è‡ªèº«çš„è¯ä¹¦ï¼Œè¿˜éœ€è¦ä¸€ä¸ª ca è¯ä¹¦ï¼Œcaè¯ä¹¦å¿…é¡»æ˜¯ æœåŠ¡ç«¯è¯ä¹¦å’Œå®¢æˆ·ç«¯è¯ä¹¦çš„ä¸Šçº§ã€‚

## stream

åœ¨ HTTP/1.1 çš„æ—¶ä»£ï¼ŒåŒä¸€ä¸ªæ—¶åˆ»åªèƒ½å¯¹ä¸€ä¸ªè¯·æ±‚è¿›è¡Œå¤„ç†æˆ–è€…å“åº”ï¼Œæ¢å¥è¯è¯´ï¼Œä¸‹ä¸€ä¸ªè¯·æ±‚å¿…é¡»è¦ç­‰å½“å‰è¯·æ±‚å¤„ç†å®Œæ‰èƒ½ç»§ç»­è¿›è¡Œã€‚

> HTTP/1.1éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨æœåŠ¡ç«¯æ²¡æœ‰responseçš„æ—¶å€™ï¼Œå®¢æˆ·ç«¯æ˜¯å¯ä»¥å‘èµ·å¤šä¸ªrequestçš„ï¼Œä½†æœåŠ¡ç«¯ä¾æ—§æ˜¯é¡ºåºå¯¹è¯·æ±‚è¿›è¡Œå¤„ç†, å¹¶æŒ‰ç…§æ”¶åˆ°è¯·æ±‚çš„æ¬¡åºäºˆä»¥è¿”å›ã€‚

HTTP/2 çš„æ—¶ä»£ï¼Œå¤šè·¯å¤ç”¨çš„ç‰¹æ€§è®©ä¸€æ¬¡åŒæ—¶å¤„ç†å¤šä¸ªè¯·æ±‚æˆä¸ºäº†ç°å®ï¼Œå¹¶ä¸”åŒä¸€ä¸ª TCP é€šé“ä¸­çš„è¯·æ±‚ä¸åˆ†å…ˆåã€ä¸ä¼šé˜»å¡ï¼ŒHTTP/2 ä¸­å¼•å…¥äº†æµ(Stream) å’Œ å¸§(Frame) çš„æ¦‚å¿µï¼Œå½“ TCP é€šé“å»ºç«‹ä»¥åï¼Œåç»­çš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯ä»¥æµçš„æ–¹å¼å‘é€çš„ï¼Œè€ŒäºŒè¿›åˆ¶å¸§åˆ™æ˜¯ç»„æˆæµçš„æœ€å°å•ä½ï¼Œå±äºåè®®å±‚ä¸Šçš„æµå¼ä¼ è¾“ã€‚

> HTTP/2 åœ¨ä¸€ä¸ª TCP è¿æ¥çš„åŸºç¡€ä¸Šè™šæ‹Ÿå‡ºå¤šä¸ª Stream, Stream ä¹‹é—´å¯ä»¥å¹¶å‘çš„è¯·æ±‚å’Œå¤„ç†, å¹¶ä¸” HTTP/2 ä»¥äºŒè¿›åˆ¶å¸§ (frame) çš„æ–¹å¼è¿›è¡Œæ•°æ®ä¼ é€, å¹¶å¼•å…¥äº†å¤´éƒ¨å‹ç¼© (HPACK), å¤§å¤§æå‡äº†äº¤äº’æ•ˆç‡


proto ä¸­ æµçš„å®šä¹‰
```go
service Greeter {
    // æ™®é€š RPC
    rpc SayHello (HelloRequest) returns (HelloReply) {}
    // å®¢æˆ·ç«¯æµå¼ RPC
    rpc ClientStream (stream HelloRequest) returns (HelloReply) {}
    // æœåŠ¡å™¨ç«¯æµå¼ RPC
    rpc ServerStream (HelloRequest) returns (stream HelloReply) {}
    // åŒå‘æµå¼ RPC
    rpc TwoStream (stream HelloRequest) returns (stream HelloReply) {}
}
```




### å®¢æˆ·ç«¯æµ

å®ç° `ClientStream` æœåŠ¡
```go
func (c *RpcServer) ClientStream(stream service.Greeter_ClientStreamServer) error {
    count := 0
    for {
        //æºæºä¸æ–­çš„å»æ¥æ”¶å®¢æˆ·ç«¯å‘æ¥çš„ä¿¡æ¯
        recv, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                return nil
            }
            return err
        }
        fmt.Println("æœåŠ¡ç«¯æ¥æ”¶åˆ°çš„æµ", recv.Msg, count)

        // æ¥æ”¶10æ¬¡åï¼Œä¸»åŠ¨è¿”å›
        count++
        if count > 10 {
            rsp := &service.HelloReply{Msg: "1"}
            err := stream.SendAndClose(rsp)
            if err != nil {
                return err
            }
            return nil
        }
    }
}
```

æœåŠ¡ç«¯å®ç° - ä¸å…¶ä»–å®ç°æ— ä»»ä½•åŒºåˆ«
```go
func TestStreamServer(t *testing.T) {
    listen, _ := net.Listen("tcp", ":9090")
    rpcServer := grpc.NewServer()
    service.RegisterGreeterServer(rpcServer, &RpcServer{})

    err := rpcServer.Serve(listen)
    if err != nil {
        fmt.Printf("failed to serve: %v", err)
        panic(err)
    } else {
        fmt.Println("RpcServer started")
    }
}
```
å®¢æˆ·ç«¯
```go
func TestStreamInsecureClient(t *testing.T) {
    // åˆ›å»ºä¸€ä¸ªä¸å®‰å…¨çš„å®¢æˆ·ç«¯å‡­æ®ï¼Œè¿™é€šå¸¸ç”¨äºæµ‹è¯•ç¯å¢ƒï¼Œä¸å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨
    cred := insecure.NewCredentials()
    // ä½¿ç”¨ä¸Šè¿°å‡­æ®é…ç½®gRPCçš„ä¼ è¾“å‡­æ®
    transportCredentials := grpc.WithTransportCredentials(cred)

    //å°è¯•ä½¿ç”¨é…ç½®çš„å‡­æ®è¿æ¥åˆ°gRPCæœåŠ¡å™¨
    client, err := grpc.NewClient("127.0.0.1:9090", transportCredentials)

    if err != nil {
        log.Fatalf("æœªè¿æ¥ï¼š %v", err) //å¦‚æœé”™è¯¯åˆ™é€€å‡º
    }
    defer client.Close() //æœ€åå…³é—­ è¿æ¥

    //åˆ›å»ºä¸€ä¸ªGreeteræœåŠ¡çš„å®¢æˆ·ç«¯
    greeterClient := service.NewGreeterClient(client)

    stream, err := greeterClient.ClientStream(context.Background())
    if err != nil {
        log.Fatal("è·å–æµå‡ºé”™", err)
    }
    // åˆ›å»ºä¸€ä¸ªåŸºäº struct çš„ channelï¼Œå®¹é‡ä¸º1
    rsp := make(chan struct{}, 1)
    // 10 å‘é€æ¶ˆæ¯
    go send10TimesRequest(stream, rsp)
    // å½“å‘é€10æ¬¡åï¼Œç­‰å¾…è¿”å›å€¼
    select {
    case <-rsp:
        //å…³é—­å¹¶æ¥æ”¶è¿”å›å€¼
        recv, err := stream.CloseAndRecv()
        if err != nil {
            log.Fatal(err)
        }
        stock := recv.Msg
        fmt.Println("å®¢æˆ·ç«¯æ”¶åˆ°å“åº”ï¼š", stock)
    }
}
func send10TimesRequest(stream service.Greeter_ClientStreamClient, rsp chan struct{}) {
    count := 0
    var i int
    for {
        i++
        request := &service.HelloRequest{
            Msg: strconv.Itoa(i),
        }
        // åŸºäºæµå‘é€æ¶ˆæ¯
        err := stream.SendMsg(request)
        if err != nil {
            log.Fatal(err)
        }
        time.Sleep(time.Second)
        count++
        if count > 10 {
            rsp <- struct{}{}
            break
        }
    }
}
```





### æœåŠ¡ç«¯æµ

`ServerStream` æœåŠ¡å®ç°
```go
func (c *RpcServer) ServerStream(req *service.HelloRequest, stream service.Greeter_ServerStreamServer) error {
	for i := 0; i < 10; i++ {
		err := stream.Send(&service.HelloReply{
			Msg: strconv.Itoa(i),
		})
		if err != nil {
			return err
		}
	}

	return nil

}
```
å®¢æˆ·ç«¯å®ç°
```go
stream, err := greeterClient.ServerStream(context.Background(), &service.HelloRequest{
    Msg: "Hello World",
})
if err != nil {
    log.Fatalf("è·å–æœåŠ¡ç«¯æµå¤±è´¥ %v", err)
}
for i := 0; i < 10; i++ {

    recv, err := stream.Recv()
    if err != nil {
        if err == io.EOF {
            fmt.Println("å®¢æˆ·ç«¯æ•°æ®æ¥æ”¶å®Œæˆ")
            err := stream.CloseSend()
            if err != nil {
                log.Fatal(err)
            }
            break
        }
        log.Fatal(err)
    }
    fmt.Println("æœåŠ¡ç«¯æ¥æ”¶åˆ°çš„æµ", recv.Msg, i)

}
```

### åŒå‘æµ

å®ç° `TwoStream` æœåŠ¡
```go
func (c *RpcServer) TwoStream(stream service.Greeter_TwoStreamServer) error {
    var i int
    for {
        i++
        // å¾ªç¯æ¥æ”¶å®¢æˆ·ç«¯å‘æ¥çš„æ¶ˆæ¯
        recv, err := stream.Recv()
        if err != nil {
            return nil
        }
        fmt.Println("æœåŠ¡ç«¯æ”¶åˆ°å®¢æˆ·ç«¯çš„æ¶ˆæ¯", recv.Msg)
        time.Sleep(time.Second)
        // å‘å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
        rsp := &service.HelloReply{Msg: strconv.Itoa(i)}
        err = stream.Send(rsp)
        if err != nil {
            return nil
        }
    }
}
```

å®¢æˆ·ç«¯æµå®ç°
```go
func towSend(prodClient service.GreeterClient) {
    // è·å–æµ
    stream, err := prodClient.TwoStream(context.Background())

    var i int
    for {
        i++
        // æƒ³æœåŠ¡ç«¯å‘é€æ¶ˆæ¯
        request := &service.HelloRequest{
            Msg: strconv.Itoa(i),
        }
        err = stream.Send(request)
        if err != nil {
            log.Fatal(err)
        }
        time.Sleep(time.Second)

        // ä»æœåŠ¡ç«¯æ¥æ”¶æ¶ˆæ¯
        recv, err := stream.Recv()
        if err != nil {
            log.Fatal(err)
        }
        
        fmt.Println("å®¢æˆ·ç«¯æ”¶åˆ°çš„æµä¿¡æ¯", recv.Msg)
    }
}
```

# æ‹¦æˆªå™¨

grpc ä¸­çš„æ‹¦æˆªå™¨åˆ†ä¸ºä¸¤ç§
- ä¸€å…ƒæ‹¦æˆªå™¨ 
  - ç”¨äºæ‹¦æˆªå’Œå¤„ç†**ä¸€å…ƒï¼ˆUnaryï¼‰**è°ƒç”¨ï¼Œå³å•æ¬¡è¯·æ±‚-å“åº”çš„ gRPC æ–¹æ³•ã€‚
  - åªæ‹¦æˆª Unary æ–¹æ³•ï¼Œä¸ä¼šæ‹¦æˆªæµå¼æ–¹æ³•ã€‚
  > å…¸å‹ç”¨ä¾‹åŒ…æ‹¬èº«ä»½éªŒè¯ã€æ—¥å¿—è®°å½•ã€ç›‘æ§ã€è¯·æ±‚æˆ–å“åº”ä¿®æ”¹ã€‚
  
- æµå¼æ‹¦æˆªå™¨
  - ç”¨äºæ‹¦æˆªå’Œå¤„ç†**æµå¼ï¼ˆStreamingï¼‰**è°ƒç”¨ï¼ŒåŒ…æ‹¬å®¢æˆ·ç«¯æµã€æœåŠ¡ç«¯æµå’ŒåŒå‘æµå¼ RPCã€‚
  - åªæ‹¦æˆª Streaming æ–¹æ³•ï¼Œä¸ä¼šæ‹¦æˆªä¸€å…ƒæ–¹æ³•ã€‚
  > é€‚ç”¨äºéœ€è¦åœ¨æµå¼é€šä¿¡è¿‡ç¨‹ä¸­è¿›è¡Œæ‹¦æˆªå¤„ç†çš„åœºæ™¯ï¼Œä¾‹å¦‚è®°å½•æ‰€æœ‰ä¼ å…¥çš„æ¶ˆæ¯æµæˆ–å¯¹æµæ•°æ®è¿›è¡Œé¢„å¤„ç†ã€‚

## unary interceptors
å¯¹äºunaryæœåŠ¡çš„æ‹¦æˆªå™¨åªéœ€å®ç°UnaryServerInterceptoræ¥å£å³å¯
```go
func(ctx context.Context, req interface{}, 
     info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)
```

- `ctx context.Context`ï¼šå•ä¸ªè¯·æ±‚çš„ä¸Šä¸‹æ–‡
- `req interface{}`ï¼šRPCæœåŠ¡çš„è¯·æ±‚ç»“æ„ä½“
- `info *UnaryServerInfo`ï¼šRPCçš„æœåŠ¡ä¿¡æ¯
- `handler UnaryHandler`ï¼šå®ƒåŒ…è£…äº†æœåŠ¡å®ç°ï¼Œé€šè¿‡è°ƒç”¨å®ƒæˆ‘ä»¬å¯ä»¥å®ŒæˆRPCå¹¶è·å–åˆ°å“åº”

**ç¤ºä¾‹ï¼šæ£€æŸ¥token**

æœåŠ¡ç«¯ï¼š
```go
func(ctx context.Context, //ä¸Šä¸‹æ–‡
			req any, //å…·ä½“çš„è¯·æ±‚
			info *grpc.UnaryServerInfo, // grpc server
			handler grpc.UnaryHandler, //çœŸæ­£å®ç°æœåŠ¡çš„æ–¹æ³•
		) (resp any, err error) {
        //è®°å½•æ—¶é—´
        now := time.Now()
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok {
            //æœªè®¤è¯
            return ctx, status.Errorf(codes.Unauthenticated, "æœªæä¾›è®¤è¯æ•°æ®")
        }

        var r any
        tokens := md.Get("token")

        //æ£€æŸ¥token
        if len(tokens) > 0 {
            tk := tokens[0]
            if tk == "123" {

                // å‘å®¢æˆ·ç«¯å‘é€ metadata
                newMd := metadata.Pairs("token", "server token  is 123")
                grpc.SendHeader(ctx, newMd) // ç¡®ä¿åœ¨å‘é€ä»»ä½•å“åº”ä¹‹å‰è°ƒç”¨

                // ç»§ç»­å¤„ç†è¯·æ±‚
                r, err = handler(ctx, req)
            } else {
                return ctx, status.Errorf(codes.Unauthenticated, "æœªæä¾›è®¤è¯æ•°æ®1")
            }
        } else {
            return ctx, status.Errorf(codes.Unauthenticated, "æœªæä¾›è®¤è¯æ•°æ®2")
        }

        //æ‰“å°ç”¨æ—¶
        fmt.Printf("ç”¨æ—¶ %v\n", time.Since(now))

        return r, err
    },
```
å®¢æˆ·ç«¯
```go
interceptor := grpc.WithChainUnaryInterceptor(func(ctx context.Context,
		method string, req, reply any, c *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {

        // åˆ›å»º metadata
		md := metadata.Pairs("token", "123")
		newCtx := metadata.NewOutgoingContext(ctx, md)

        // è¿½åŠ  metadata
		newCtx = metadata.AppendToOutgoingContext(newCtx, "key", "k1")

		// ä½¿ç”¨æ–°çš„contextè°ƒç”¨åŸå§‹çš„RPCæ–¹æ³•, å¹¶è·å–æœåŠ¡ç«¯è®¾ç½®çš„ header
		var header, trailer metadata.MD
		err := invoker(newCtx, method, req, reply, c, grpc.Header(&header), grpc.Trailer(&trailer))
		if err != nil {
			// å¤„ç†é”™è¯¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
			return err
		}

		fmt.Println(method+":server ts", header.Get("token"))

		//trailer
		// å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨è¿™é‡Œè¿›ä¸€æ­¥å¤„ç†replyæˆ–è¿›è¡Œæ—¥å¿—è®°å½•
		return nil
	},
	)
```

## streaming interceptors

å¯¹äºstreamæœåŠ¡çš„æ‹¦æˆªå™¨åªè¦å®ç°StreamServerInterceptoræ¥å£å³å¯
```go
func(srv interface{}, ss ServerStream, 
     info *StreamServerInfo, handler StreamHandler) error
```

- srv interface{}ï¼šæœåŠ¡å®ç°
- ss ServerStreamï¼šæœåŠ¡ç«¯è§†è§’çš„æµã€‚
- info *StreamServerInfoï¼šRPCçš„æœåŠ¡ä¿¡æ¯
- handler StreamHandlerï¼šå®ƒåŒ…è£…äº†æœåŠ¡å®ç°ï¼Œé€šè¿‡è°ƒç”¨å®ƒæˆ‘ä»¬å¯ä»¥å®ŒæˆRPC

```go
func orderStreamServerInterceptor(srv interface{},
    ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {

    // Pre-processing logic
    s := time.Now()

    // Invoking the StreamHandler to complete the execution of RPC invocation
    err := handler(srv, ss)

    // Post processing logic
    log.Printf("Method: %s, latency: %s\n", info.FullMethod, time.Now().Sub(s))

    return err
}

func main() {
    s := grpc.NewServer(
    grpc.StreamInterceptor(orderStreamServerInterceptor),
    )

    pb.RegisterOrderManagementServer(s, &OrderManagementImpl{})

    //...
}
```


# metadata
åœ¨ `gRPC` `ä¸­ï¼ŒMetadata` æ˜¯ä¸€ç§æœºåˆ¶ï¼Œå…è®¸å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨åœ¨è¯·æ±‚å’Œå“åº”ä¸­ä¼ é€’é¢å¤–çš„é”®å€¼å¯¹ä¿¡æ¯ã€‚å®ƒå¯ä»¥ç”¨äºèº«ä»½éªŒè¯ã€è¿½è¸ªã€ä¸Šä¸‹æ–‡ä¿¡æ¯ä¼ é€’ç­‰ã€‚ `Metadata` ä¸å±äºè¯·æ±‚æˆ–å“åº”çš„ä¸»è¦æ•°æ®ï¼Œè€Œæ˜¯é¢å¤–é™„åŠ çš„ä¿¡æ¯ã€‚

## Metadata çš„ç‰¹ç‚¹
1. **é”®å€¼å¯¹ç»“æ„**ï¼š`Metadata` ä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜åœ¨ï¼Œé”®é€šå¸¸æ˜¯å­—ç¬¦ä¸²ï¼Œå€¼å¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–äºŒè¿›åˆ¶æ•°æ®ã€‚

2. **ä¼ é€’æ–¹å¼**ï¼šåœ¨ `gRPC` è¯·æ±‚ä¸­ï¼Œ `Metadata` å¯ä»¥é€šè¿‡å®¢æˆ·ç«¯åœ¨å‘èµ·è¯·æ±‚æ—¶é™„åŠ åœ¨è¯·æ±‚å¤´ä¸­ï¼ŒæœåŠ¡å™¨ä¹Ÿå¯ä»¥åœ¨å“åº”ä¸­è¿”å› `Metadata` ã€‚

3. åˆ†ç±»ï¼š

    - è¯·æ±‚ Metadataï¼šç”±å®¢æˆ·ç«¯å‘é€ç»™æœåŠ¡å™¨çš„ Metadataï¼Œé€šå¸¸åŒ…å«èº«ä»½éªŒè¯ä»¤ç‰Œã€å®¢æˆ·ç«¯ä¿¡æ¯ç­‰ã€‚
  
    - å“åº” Metadataï¼šæœåŠ¡å™¨è¿”å›ç»™å®¢æˆ·ç«¯çš„ Metadataï¼Œå¯èƒ½åŒ…å«æœåŠ¡å™¨çŠ¶æ€ä¿¡æ¯æˆ–å…¶ä»–é™„åŠ æ•°æ®ã€‚
  
    - å°¾éƒ¨ Metadataï¼ˆTrailing Metadataï¼‰ï¼šåœ¨æœåŠ¡å™¨å®Œæˆå“åº”åè¿”å›ï¼Œé€šå¸¸ç”¨äºè¿”å›é¢å¤–çš„å“åº”çŠ¶æ€æˆ–è¿½è¸ªä¿¡æ¯ã€‚
  
## æ“ä½œæ–¹å¼

- **åœ¨å®¢æˆ·ç«¯**ï¼Œå¯ä»¥é€šè¿‡æ‹¦æˆªå™¨æˆ–åœ¨è°ƒç”¨æ–¹æ³•æ—¶ç›´æ¥è®¾ç½® `Metadata` ã€‚
- **åœ¨æœåŠ¡å™¨ç«¯**ï¼Œå¯ä»¥åœ¨æ–¹æ³•å¤„ç†é€»è¾‘ä¸­è¯»å–æˆ–è®¾ç½® `Metadata` ã€‚

## å…¸å‹åº”ç”¨åœºæ™¯
- èº«ä»½éªŒè¯ï¼šåœ¨è¯·æ±‚ä¸­æºå¸¦è®¤è¯ä»¤ç‰Œï¼ŒæœåŠ¡å™¨é€šè¿‡ Metadata éªŒè¯å®¢æˆ·ç«¯èº«ä»½ã€‚
- è¿½è¸ªå’Œç›‘æ§ï¼šä¼ é€’è¿½è¸ª IDï¼Œä»¥ä¾¿åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è¿›è¡Œè¯·æ±‚è¿½è¸ªã€‚
- è·¨è¯­è¨€å…¼å®¹æ€§ï¼šMetadata åœ¨ gRPC çš„å„ä¸ªè¯­è¨€å®ç°ä¸­éƒ½æ”¯æŒï¼Œé€‚ç”¨äºå¤šè¯­è¨€ç³»ç»Ÿä¹‹é—´çš„ä¿¡æ¯ä¼ é€’ã€‚

## matedataæºç è§£é‡Š
`matedata` å­˜å‚¨
```go
type mdIncomingKey struct{} //ç«™å†…ä¼ é€’: åªèƒ½åœ¨æ–¹æ³•å†…ä¼ é€’ï¼Œä¸èƒ½åœ¨æœåŠ¡é—´ä¼ é€’
type mdOutgoingKey struct{} //ç«™å¤–ä¼ é€’: æœåŠ¡é—´ä¼ é€’
```
ç«™å†…ä¼ é€’ï¼š
```go
// åˆ›å»ºä¸€ä¸ªç«™å†… matedata ,è°ƒç”¨è¯¥å‡½æ•°åä¸å¯ä¿®æ”¹ md
// NewIncomingContext creates a new context with incoming md attached. md must
// not be modified after calling this function.
func NewIncomingContext(ctx context.Context, md MD) context.Context 

// ä»ç«™å†…å–å‡º metadata
// FromIncomingContext returns the incoming metadata in ctx if it exists.
//
// All keys in the returned MD are lowercase.
func FromIncomingContext(ctx context.Context) (MD, bool)
```

ç«™å¤–ä¼ é€’
```go

// NewOutgoingContext åˆ›å»ºä¸€ä¸ªé™„åŠ äº†ä¼ å‡º md çš„æ–°ä¸Šä¸‹æ–‡ã€‚å¦‚æœä¸ AppendToOutgoingContext ä¸€èµ·ä½¿ç”¨ï¼ŒNewOutgoingContext å°†è¦†ç›–ä»»ä½•å…ˆå‰é™„åŠ çš„å…ƒæ•°æ®ã€‚è°ƒç”¨æ­¤å‡½æ•°åï¼Œä¸å¾—ä¿®æ”¹ mdã€‚
func NewOutgoingContext(ctx context.Context, md MD) context.Context


//ä»ç«™å¤–å–å¾— matedataï¼Œé”® å‡ä¸ºå°å†™
// FromOutgoingContext returns the outgoing metadata in ctx if it exists.
//
// All keys in the returned MD are lowercase.
func FromOutgoingContext(ctx context.Context) (MD, bool)

// æ·»åŠ é”®å€¼å¯¹ï¼Œå¹¶è¿”å› context
// AppendToOutgoingContext returns a new context with the provided kv merged
// with any existing metadata in the context. Please refer to the documentation
// of Pairs for a description of kv.
func AppendToOutgoingContext(ctx context.Context, kv ...string) context.Context 
```

## Metadata ä½¿ç”¨

### åˆ›å»º

**ä½¿ç”¨New()ï¼š**
```go
md := metadata.New(map[string]string{"key1":"value1","key2":"value2"})
```
**ä½¿ç”¨Pairs()**ï¼šè¦æ³¨æ„å¦‚æœæœ‰ç›¸åŒçš„ key ä¼šè‡ªåŠ¨åˆå¹¶
```go
md := metadata.Pairs(
    "key1", "value1",
    "key1", "value1.2", // "key1" will have map value []string{"value1", "value1.2"}
    "key2", "value2",
)
```
### åˆå¹¶å¤šä¸ªmetadata

```go
md1 :=  metadata.Pairs("k1", "v1", "k2", "v2")
md2 := metadata.New(map[string]string{"key1":"value1","key2":"value2"})

md := metadata.Join(md1, md2)
```

### å­˜å‚¨äºŒè¿›åˆ¶æ•°æ®

åœ¨ metadata ä¸­ï¼Œkey æ°¸è¿œæ˜¯ string ç±»å‹ï¼Œä½†æ˜¯ value å¯ä»¥æ˜¯ string ä¹Ÿå¯ä»¥æ˜¯äºŒè¿›åˆ¶æ•°æ®ã€‚ä¸ºäº†åœ¨ metadata ä¸­å­˜å‚¨äºŒè¿›åˆ¶æ•°æ®ï¼Œæˆ‘ä»¬ä»…ä»…éœ€è¦åœ¨ key çš„åé¢åŠ ä¸Šä¸€ä¸ª - bin åç¼€ã€‚å…·æœ‰ - bin åç¼€çš„ key æ‰€å¯¹åº”çš„ value åœ¨åˆ›å»º metadata æ—¶ä¼šè¢«ç¼–ç ï¼ˆbase64ï¼‰ï¼Œæ”¶åˆ°çš„æ—¶å€™ä¼šè¢«è§£ç ï¼š

```go
md := metadata.Pairs(
    "key", "string value",
    "key-bin", string([]byte{96, 102}),
)
```
### Metadata å‘é€ä¸æ¥æ”¶

metadata å°±æ˜¯gRPCä¸­å¯ä»¥ä¼ é€’çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ä¹‹ä¸€ï¼Œæ‰€ä»¥metadataçš„ä½¿ç”¨æ–¹å¼å°±æ˜¯ï¼šmetadataè®°å½•åˆ°contextï¼Œä»contextè¯»å–metadata


#### Clinetå‘é€Serveræ¥æ”¶

**Clinetå‘é€Metadata**

```go
// å°†metadataæ·»åŠ åˆ°contextä¸­ï¼Œè·å–æ–°çš„context
md := metadata.Pairs("k1", "v1", "k1", "v2", "k2", "v3")
ctx := metadata.NewOutgoingContext(context.Background(), md)

// å¦‚æœå¯¹åº”çš„ context æ²¡æœ‰ metadataï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ª
ctx := metadata.AppendToOutgoingContext(ctx, "k1", "v1", "k1", "v2", "k2", "v3")

// ä¸€å…ƒè°ƒç”¨ - unary RPC
response, err := client.xxxRPC(ctx, someRequest)

// æµå¼è°ƒç”¨ - streaming RPC
stream, err := client.xxxStreamingRPC(ctx)
```

**Server æ¥æ”¶ Metedata**ï¼š æ™®é€šRPCä¸æµå¼RPCçš„åŒºåˆ«ä¸å¤§ï¼Œéƒ½æ˜¯ä»contex.Contextä¸­è¯»å–metadata
```go
// æ™®é€šRPCï¼ˆunary RPCï¼‰
//Unary Call
func (s *server) xxxRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {
    md, ok := metadata.FromIncomingContext(ctx)
}

// æµå¼RPCï¼ˆstreaming RPCï¼‰
//Streaming Call
func (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {
    md, ok := metadata.FromIncomingContext(stream.Context()) // get context from stream
}
```
#### Serverå‘é€Clinetæ¥æ”¶
å¯¹äº **æ™®é€šRPCï¼ˆunary RPCï¼‰** `serverç«¯` å¯ä»¥ä½¿ç”¨ `grpc` åŒ…ä¸­æä¾›çš„å‡½æ•°å‘ `client` å‘é€ `header` å’Œ `trailer`

- grpc.SendHeader()
- grpc.SetHeader()
- grpc.SetTrailer()
  
```go
func (s *server) SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, error) {
  // åˆ›å»ºå¹¶å‘é€header
  header := metadata.Pairs("header-key", "val")
  grpc.SendHeader(ctx, header)
  
  // åˆ›å»ºå¹¶å‘é€trailer
  trailer := metadata.Pairs("trailer-key", "val")
  grpc.SetTrailer(ctx, trailer)
}
```

å¯¹äº**æµå¼RPCï¼ˆstreaming RPCï¼‰** `serverç«¯` å¯ä»¥ä½¿ç”¨ `ServerStream` æ¥å£ä¸­å®šä¹‰çš„å‡½æ•°å‘ `client` å‘é€ `header` å’Œ `trailer`

- ServerStream.SendHeader()
- ServerStream.SetHeader()
- ServerStream.SetTrailer()

```go
func (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {
  // create and send header
  header := metadata.Pairs("header-key", "val")
  stream.SendHeader(header)
  
  // create and set trailer
  trailer := metadata.Pairs("trailer-key", "val")
  stream.SetTrailer(trailer)
}
```

**`client` æ¥æ”¶ `metadata`**

```go
//æ™®é€šRPCï¼ˆunary RPCï¼‰ä½¿ç”¨grpc.Header()å’Œgrpc.Trailer()æ–¹æ³•æ¥æ¥æ”¶ Metadata
// RPC using the context with new metadata.
var header, trailer metadata.MD

order := pb.Order{Id: "101", Items: []string{"iPhone XS", "Mac Book Pro"}, Destination: "San Jose, CA", Price: 2300.00}
res, err := client.AddOrder(ctx, &order, grpc.Header(&header), grpc.Trailer(&trailer))
if err != nil {
  panic(err)
}
// ä½¿ç”¨æ‹¦æˆªå™¨åˆ™æ˜¯
var header, trailer metadata.MD
err := invoker(newCtx, method, req, reply, c, grpc.Header(&header), grpc.Trailer(&trailer))
if err != nil {
    // å¤„ç†é”™è¯¯ï¼ˆå¦‚æœéœ€è¦ï¼‰
    return err
}


// æµå¼RPCï¼ˆstreaming RPCï¼‰é€šè¿‡è°ƒç”¨è¿”å›çš„ ClientStreamæ¥å£çš„Header()å’Œ Trailer()æ–¹æ³•æ¥æ”¶ metadata
stream, err := client.SomeStreamingRPC(ctx)

// retrieve header
header, err := stream.Header()

stream.CloseAndRecv()

// retrieve trailer
trailer := stream.Trailer()
```

### Headerå’ŒTraileråŒºåˆ«

æ ¹æœ¬åŒºåˆ«ï¼šå‘é€çš„æ—¶æœºä¸åŒï¼

- headersä¼šåœ¨ä¸‹é¢ä¸‰ç§åœºæ™¯ä¸‹è¢«å‘é€

    - SendHeader() è¢«è°ƒç”¨æ—¶ï¼ˆåŒ…å«grpc.SendHeaderå’Œstream.SendHeader)
    - ç¬¬ä¸€ä¸ªå“åº”è¢«å‘é€æ—¶
    - RPCç»“æŸæ—¶ï¼ˆåŒ…å«æˆåŠŸæˆ–å¤±è´¥ï¼‰

- trailerä¼šåœ¨rpcè¿”å›çš„æ—¶å€™ï¼Œå³è¿™ä¸ªè¯·æ±‚ç»“æŸçš„æ—¶å€™è¢«å‘é€

å·®å¼‚åœ¨æµå¼RPCï¼ˆstreaming RPCï¼‰ä¸­æ¯”è¾ƒæ˜æ˜¾ï¼š

å› ä¸ºtraileræ˜¯åœ¨æœåŠ¡ç«¯å‘é€å®Œè¯·æ±‚ä¹‹åæ‰å‘é€çš„ï¼Œæ‰€ä»¥clientè·å–trailerçš„æ—¶å€™éœ€è¦åœ¨stream.CloseAndRecvæˆ–è€…stream.Recv è¿”å›énilé”™è¯¯ (åŒ…å« io.EOF)ä¹‹å

å¦‚æœstream.CloseAndRecvä¹‹å‰è°ƒç”¨stream.Trailer()è·å–çš„æ˜¯ç©º
```go
stream, err := client.SomeStreamingRPC(ctx)

// retrieve header
header, err := stream.Header()

// retrieve trailer 
// `trailer`ä¼šåœ¨rpcè¿”å›çš„æ—¶å€™ï¼Œå³è¿™ä¸ªè¯·æ±‚ç»“æŸçš„æ—¶å€™è¢«å‘é€
// å› æ­¤æ­¤æ—¶è°ƒç”¨`stream.Trailer()`è·å–çš„æ˜¯ç©º
trailer := stream.Trailer()

stream.CloseAndRecv()

// retrieve trailer 
// `trailer`ä¼šåœ¨rpcè¿”å›çš„æ—¶å€™ï¼Œå³è¿™ä¸ªè¯·æ±‚ç»“æŸçš„æ—¶å€™è¢«å‘é€
// å› æ­¤æ­¤æ—¶è°ƒç”¨`stream.Trailer()`æ‰å¯ä»¥è·å–åˆ°å€¼
trailer := stream.Trailer()
```

# é”™è¯¯å¤„ç†

gRPC æä¾›äº†google.golang.org/grpc/statusæ¥è¡¨ç¤ºé”™è¯¯ï¼Œè¿™ä¸ªç»“æ„åŒ…å«äº† code å’Œ message ä¸¤ä¸ªå­—æ®µ

ğŸŒ² codeæ˜¯ç±»ä¼¼äºhttp status codeçš„ä¸€ç³»åˆ—é”™è¯¯ç±»å‹çš„æšä¸¾ï¼Œæ‰€æœ‰è¯­è¨€ sdk éƒ½ä¼šå†…ç½®è¿™ä¸ªæšä¸¾åˆ—è¡¨

è™½ç„¶æ€»å…±é¢„å®šä¹‰äº†16ä¸ªcodeï¼Œä½†gRPCæ¡†æ¶å¹¶ä¸æ˜¯ç”¨åˆ°äº†æ¯ä¸€ä¸ªcodeï¼Œæœ‰äº›codeä»…æä¾›ç»™ä¸šåŠ¡é€»è¾‘ä½¿ç”¨

ç¤ºä¾‹
```go
func (c *RpcServer) SayHello(ctx context.Context, req *service.HelloRequest) (*service.HelloReply, error) {
	log.Printf("è¯·æ±‚å€¼ï¼š %v", req)
	a, _ := anypb.New(&service.DataMsg{Data: "data is me"})
	return &service.HelloReply{
		Msg:  "hello",
		Data: a,
	}, status.Error(codes.OK, "")
}
```



# å¯¹æœåŠ¡ç«¯/å®¢æˆ·ç«¯çš„æ± åŒ–

æˆ‘ä»¬åœ¨å¹¶å‘é‡è¾ƒé«˜æ—¶ï¼Œå¯ä»¥å»ºç«‹å¤šä¸ª æœåŠ¡ç«¯/å®¢æˆ·ç«¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†å…¶æ± åŒ–ï¼Œä½¿ç”¨æ—¶æ‹¿å»ä¸€ä¸ªå³å¯

æ–¹å¼ä¸€ï¼šè‡ªè¡Œæ§åˆ¶æ± ä¸­çš„èµ„æº
```go
type userClient struct {
	clients []RpcClient
	index   int64
}

// è½®è¯¢ä½¿ç”¨
func (r *userClient) Get() struct {
	//1. index + 1ï¼Œç›¸å½“äºæ¯è½®è¯¢ä½¿ç”¨ æ± ä¸­çš„èµ„æº
	index := atomic.AddInt64(&r.index, 1)
	i := int(index) % len(r.clients)
	return r.clients[i]
}

// åœ¨æ­¤å¤„åˆå§‹åŒ– æ±  ï¼Œå¹¶åˆå§‹åŒ–è¿æ¥
func NewClientPool(size int) {
	var cs []struct
	for i := 0; i < size; i++ {
		server := struct{}
		cs = append(cs, server)
	}
}
```
æ–¹å¼äºŒï¼šä½¿ç”¨ sync.Pool å¯¹è±¡

```go
var connPool = sync.Pool{
	New: func() any {
		// è¿æ¥åˆ°æœåŠ¡
		addr := flag.String("addr", "127.0.0.1:80", "server listen address")

		opts := []grpc.DialOption{
			// åˆ›å»ºä¸€ä¸ªä¸å®‰å…¨çš„å®¢æˆ·ç«¯å‡­æ®ï¼Œè¿™é€šå¸¸ç”¨äºæµ‹è¯•ç¯å¢ƒï¼Œä¸å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨
			grpc.WithTransportCredentials(insecure.NewCredentials()),
			//gRPCå®¢æˆ·ç«¯çš„è¯»å†™ç¼“å†²åŒºè®¾ç½®
			grpc.WithWriteBufferSize(1024 * 1024 * 1), // é»˜è®¤32KB
			grpc.WithReadBufferSize(1024 * 1024 * 1),  // é»˜è®¤32KB,
			grpc.WithKeepaliveParams(keepalive.ClientParameters{
				Time:                10 * time.Minute, // æŒ‡å®šå®¢æˆ·ç«¯å¤šä¹…å‘é€ä¸€ä¸ªä¿æ´»æ¢æµ‹æ¶ˆæ¯ç»™æœåŠ¡ç«¯
				Timeout:             10 * time.Second, // æŒ‡å®šç­‰å¾…æœåŠ¡ç«¯å“åº”ä¿æ´»æ¢æµ‹æ¶ˆæ¯çš„æœ€é•¿æ—¶é—´
				PermitWithoutStream: false,            // å½“æ²¡æœ‰æ´»åŠ¨çš„RPCæµæ—¶ï¼Œæ˜¯å¦å…è®¸å‘é€ä¿æ´»æ¢æµ‹æ¶ˆæ¯
			}),
		}

		//å°è¯•ä½¿ç”¨é…ç½®çš„å‡­æ®è¿æ¥åˆ°gRPCæœåŠ¡å™¨
		client, err := grpc.NewClient(*addr, opts...)

		if err != nil {
			log.Fatalf("did not connect: %v", err)
		}
		return client
	},
}

func GetConn() *grpc.ClientConn {
	return connPool.Get().(*grpc.ClientConn)
}

func CloseConn(conn *grpc.ClientConn) {
	connPool.Put(conn)
}
```


æ³¨æ„äº‹é¡¹
- é¿å…è¿‡åº¦ä¾èµ–ï¼šè™½ç„¶sync.Poolå¯ä»¥æé«˜æ€§èƒ½ï¼Œä½†è¿‡åº¦ä¾èµ–å¯èƒ½å¯¼è‡´ä»£ç å¤æ‚æ€§å’Œå¯ç»´æŠ¤æ€§ä¸‹é™ã€‚å› æ­¤ï¼Œåœ¨ä½¿ç”¨sync.Poolæ—¶éœ€è¦æƒè¡¡åˆ©å¼Šï¼Œç¡®ä¿å…¶åœ¨åˆé€‚çš„åœºæ™¯ä¸­ä½¿ç”¨ã€‚
- é¿å…å­˜å‚¨å¤§å¯¹è±¡æˆ–é•¿æ—¶é—´å ç”¨çš„å¯¹è±¡ï¼šsync.Poolæ›´é€‚åˆå­˜å‚¨å°å¯¹è±¡æˆ–ä¸´æ—¶å¯¹è±¡ã€‚å¯¹äºå¤§å¯¹è±¡æˆ–é•¿æ—¶é—´å ç”¨çš„å¯¹è±¡ï¼Œä½¿ç”¨sync.Poolå¯èƒ½ä¼šå¯¼è‡´å†…å­˜å ç”¨è¿‡é«˜æˆ–å¯¹è±¡æ³„éœ²ç­‰é—®é¢˜ã€‚
- å¤„ç†Getæ–¹æ³•è¿”å›nilçš„æƒ…å†µï¼šå¦‚æœGetæ–¹æ³•è¿”å›nilï¼Œè°ƒç”¨è€…éœ€è¦åˆ¤æ–­æ˜¯å¦ä¸ºnilå¹¶ç›¸åº”åœ°å¤„ç†ã€‚ä¸ºäº†é¿å…æ½œåœ¨çš„é”™è¯¯å’Œè¯¯è§£ï¼Œå»ºè®®åœ¨Getæ–¹æ³•ä¸­è¿”å›ä¸€ä¸ªæœ‰æ•ˆçš„é»˜è®¤å€¼æˆ–é”™è¯¯å¯¹è±¡ã€‚
- å¦å¤–gRPCå•è¿æ¥æ”¯æŒä¸Šä¸‡çš„å¹¶å‘ï¼Œæ›´é«˜çš„å¹¶å‘æ‰éœ€è¦è€ƒè™‘è¿æ¥æ± 
- è¿æ¥æ± çš„å¼•å…¥ä¼šå¢åŠ å¤æ‚åº¦ï¼Œä¸è¦è¿‡æ—©ä¼˜åŒ–
- sync.Pool åªæ˜¯ä¸´æ—¶ç¼“å­˜ï¼Œè¿æ¥éšæ—¶å¯èƒ½å¤±æ•ˆ


# ä½¿ç”¨åå°„ç®€åŒ– gRPCçš„è°ƒç”¨


## æœåŠ¡ç«¯å¢åŠ åå°„è°ƒç”¨

```go
reflection.Register(s)
```

## gRPC UI
gRPC UI æ˜¯ä¸€ä¸ªäº¤äº’å¼çš„ web ç•Œé¢ï¼Œç±»ä¼¼äº Postmanï¼Œä½†ä¸“ä¸º gRPC æœåŠ¡è®¾è®¡ã€‚å®ƒå…è®¸ç”¨æˆ·é€šè¿‡ä¸€ä¸ªç›´è§‚çš„ç•Œé¢ä¸ gRPC æœåŠ¡è¿›è¡Œäº¤äº’ï¼Œè€Œæ— éœ€ç¼–å†™ä»»ä½•ä»£ç ã€‚gRPC UI æä¾›äº†ä¸°å¯Œçš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬åŠ¨æ€æ„å»ºè¯·æ±‚è¡¨å•ã€é€‰æ‹©æœåŠ¡å’Œæ–¹æ³•ã€ä»¥åŠæŸ¥çœ‹å“åº”ç­‰ã€‚


### å®‰è£… gRPC UI


```bash
go install github.com/fullstorydev/grpcui/cmd/grpcui@latest
```

### è¿è¡Œ gRPC UI

ç«¯å£æ˜¯ æœåŠ¡çš„ç«¯å£
```bash
grpcui -plaintext localhost:9019
```




# è‡ªåŠ¨ç”ŸæˆgRPCæ–‡ä»¶(./pb)
```
protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative user_growth.proto
```

# protobufæ–‡ä»¶æ¥æº
    google/api/*.proto æ¥è‡ª https://github.com/googleapis/googleapis
    google/protobuf/*.proto æ¥è‡ª https://github.com/protocolbuffers/protobuf

# ç”Ÿæˆprotosetæ–‡ä»¶
```
protoc --proto_path=. --descriptor_set_out=myservice.protoset --include_imports ./user_growth.proto
```

# grpcurlè°ƒç”¨
```
# ä½¿ç”¨gRPCæœåŠ¡
grpcurl -plaintext localhost:80 list
grpcurl -plaintext localhost:80 list UserGrowth.UserCoin
grpcurl -plaintext localhost:80 describe
grpcurl -plaintext localhost:80 describe UserGrowth.UserCoin
grpcurl -plaintext localhost:80 describe UserGrowth.UserCoin.ListTasks
# ä½¿ç”¨protoæ–‡ä»¶
grpcurl -import-path ./ -proto user_growth.proto list
# ä½¿ç”¨protosetæ–‡ä»¶
grpcurl -protoset myservice.protoset list UserGrowth.UserCoin
# è°ƒç”¨gRPCæœåŠ¡
grpcurl -plaintext localhost:80 UserGrowth.UserCoin/ListTasks
grpcurl -plaintext -d '{"uid":1}' localhost:80 UserGrowth.UserCoin/UserCoinInfo
```

# ç”Ÿæˆgrpc-gatewayä»£ç 
````
protoc -I . --grpc-gateway_out ./ \
    --grpc-gateway_opt logtostderr=true \
    --grpc-gateway_opt paths=source_relative \
    --grpc-gateway_opt generate_unbound_methods=true \
    user_growth.proto
````
