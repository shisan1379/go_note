
# 函数


<!-- ## 栈帧-todo -->

## 逃逸分析

**逃逸分析定义：**

> 当函数局部变量的声明周期，超过栈帧的声明周期，编译器会把该局部变量由栈分配修改为堆分配，即变量从栈上逃逸到堆上。


在实际中，只要代码逻辑允许，编译器总是倾向于把变量分配在栈上，这比分配在堆上更高效。所以编译器倾向于让变量不逃逸。

## 闭包

**闭包：**
> 在某个函数内部定义了另一个函数，内层函数使用了外层函数的局部变量，并且内层函数被外层函数作为返回值返回。




<!-- ## Function Value -todo -->


## defer

`Go` 语言的 `defer` 按照先入后出 - FILO(First In Last Out)的顺序调用所有注册的函数。





## panic

# 方法

## 组合式继承


# goroutine

## GM模型-todo

## GMP模型


![alt text](image-2.png)

![alt text](image-1.png)

- 全局队列（Global Queue）：存放等待运行的 G。
- 每个 P 维护一个本地队列
- 当一个 G 被创建出来或者变为可执行状态时，优先放到 P 的本地队列中，否则放到全局队列
- 当一个 G 在 M中执行结束后， 调度器 会从P队列中把新的 G 取出交给 M 执行，如果此时 P队列为空， M 会优先尝试从全局队列中寻找 G 来执行，如果全局队列为空，它会随机挑选一个 P 从它的队列中拿走一半G 放到自己的队列中执行

## P 与 M 的数量问题
1. P 的数量：
   
    由启动时环境变量 `$GOMAXPROCS` 或者是由 `runtime` 的方法 `GOMAXPROCS()` 决定。这意味着在程序执行的任意时刻都只有 `$GOMAXPROCS` 个 `goroutine` 在同时运行。
1. M 的数量:
   - go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。
   - runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量
   - 一个 M 阻塞了，会创建新的 M。
  
M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。


## P 和 M 何时会被创建

1. P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。

2. M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。

## 调度器的设计策略

核心策略就是 **复用线程**，避免频繁的创建、销毁线程。

对于线程的复用则是通过以下的子策略

1. work stealing 机制 - 工作窃取
   
   当本线程无可运行的 `G` 时，尝试从其他线程绑定的 `P` 偷取 `G`，而不是销毁本线程

1. hand off 机制 - 移交机制
   
   当本线程因为 `G` 进行系统调用阻塞时，线程释放绑定的 `P` ，将其移交给其它空闲线程执行

**调度器的其它特点**

**利用并行**： `GOMAXPROCS` 设置 `P` 的数量，最多有 `GOMAXPROCS` 个线程分布在多个 `CPU` 上同时运行。 `GOMAXPROCS` 也限制了并发的程度，比如 `GOMAXPROCS = 核数/2`，则最多利用了一半的 `CPU` 核进行并行。

**抢占**: 在 `coroutine-协程` 中要等待一个协程主动让出 `CPU` 才执行下一个协程，在 `Go` 中，一个 `goroutine` 最多占用 `CPU` `10ms`，防止其他 `goroutine` 被饿死，这就是 `goroutine` 不同于 `coroutine` 的一个地方。

**全局 G 队列**：在新的调度器中依然有全局 `G` 队列，但功能已经被弱化了，当 `M` 执行 `work stealing` 从其他 `P` 偷不到 `G` 时，它可以从全局 `G` 队列获取 `G`


## go func () 执行流程

![alt text](image-3.png)


1. 通过 `go` 关键字创建 `goroutine` 并执行
2. 被创建出来的 `goroutine` 优先被放入本地 `P队列` 如果 `P队列` 已满(256) ，那么放到 `全局G队列`
3. `gorouotine` 只能运行在 `M` 中，一个 `M` 至少持有一个 `P`



# 同步

# 堆



