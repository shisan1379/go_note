

# go并发

## 并发与并行

并行：同一时刻，执行多条指令
并发：同一时刻，只有一条指令在执行，但是进程会被轮换执行，这依赖 CPU时间片算法

## 进程

程序执行，称为进程。

### 进程状态

进程基本的状态有5种。分别为`初始态`，`就绪态`，`运行态`，`挂起态`与`终止态`。其中初始态为进程准备阶段，常与就绪态结合来看。

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240325213125.png)



### 进程并发

进程，系统开销比较大，并发数量少，

## 线程

线程是轻量级的进程

进程：独立的内存空间，有PCB
线程，有PCB，有共享的内存空间

线程一般是最小的执行单位，进程是最小的资源分配单位


### 线程同步

同步即协同步调，按预定的先后次序运行

- 互斥量 - mutex

- 读写锁
    写独占，读共享


## 协程

协程 是轻量级线程，一个线程可以拥有多个协程，但同一时刻，只能有一个协程运行，多个协程共享，该线程的计算机资源

## go 并发
go 在语言层面支持并发 `goroutine` . Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。

Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。

Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。

## goroutine

goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。

### goroutine创建

使用 go 关键字
```go
func newTask() {
    i := 0
    for {
        i++
        fmt.Printf("new goroutine: i = %d\n", i)
        time.Sleep(1 * time.Second) //延时1s
    }
}

func TestGoroutine(t *testing.T) {
    go newTask()
    time.Sleep(1 * time.Second) //延时1s
    //退出
    fmt.Println("main goroutine exit")
}
```
输出
```
new goroutine: i = 1
new goroutine: i = 2
main goroutine exit
```

主goroutine退出后，其它的工作goroutine也会自动退出


### runtime 包

#### runtime.Gosched()
出让当前时间片，直到调度器再次调度，类似于其它语言的 yield 方法

示例
```go
func TestGosched(t *testing.T) {
    go func(s string) {
        for i := 0; i < 2; i++ {
            fmt.Println(s)
        }
    }("world")

    for i := 0; i < 2; i++ {
        runtime.Gosched() //import "runtime" 包
        /*
           屏蔽runtime.Gosched()运行结果如下：
               hello
               hello

           没有runtime.Gosched()运行结果如下：
               world
               world
               hello
               hello
        */
        fmt.Println("hello")
    }
}
```

#### runtime.Goexit()

立即终止 当前 goroutine 执行，调度器会确保 所有 **已注册的 `defer` 执行**

```go

func TestGoExit(t *testing.T) {
    go func() {
        defer fmt.Println("A.defer")

        defer fmt.Println("B.defer")

        runtime.Goexit() // 终止当前 goroutine
        fmt.Println("A") // 不会执行
    }()
}
```


####  runtime.GOMAXPROCS()

设置可以并行计算的CPU核数的最大值，并返回之前的值

```go
func TestMaxCore(t *testing.T) {

    fmt.Printf("cpu %d", runtime.NumCPU()) // 获取当前的核心数

    //设置 使用的核心数为 2
    n := runtime.GOMAXPROCS(2)

    fmt.Printf("n = %d\n", n)

    maxProcs := runtime.GOMAXPROCS(0)
    fmt.Println("Current GOMAXPROCS value:", maxProcs) //获取当前使用的核心数
}
```

注意，从Go 1.5开始，GOMAXPROCS的默认值可能会根据系统的CPU核心数自动设置，通常不需要手动设置。在并发编程时，应该更多地依赖Go的goroutines和channels进行通信和同步，而不是直接控制线程数量。Go运行时会自动在可用的逻辑处理器之间调度goroutines的执行，以实现高效的并发性能。



## channel

channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。

goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。

引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240325223724.png)

### 使用channel

使用make 创建 channel
```go
make(chan Type)  //等价于make(chan Type, 0)
make(chan Type, capacity)
```

当 参数capacity= 0 时，channel 是无缓冲阻塞读写的；当capacity > 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。


channel非常像生活中的管道，一边可以存放东西，另一边可以取出东西。channel通过操作符 <- 来接收和发送数据，发送和接收数据语法：

```go
channel <- value        //发送value到channel
<-channel               //接收并将其丢弃
val := <-channel        //从channel中接收数据，并赋值给val
val, ok := <-channel    //功能同上，同时检查通道是否已关闭或者是否为空
```

默认情况下， channel 接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。

### 无缓冲 channel

无缓冲的通道，不能保存值的通道。
- 在发送值后，对方没有接收时就会阻塞，直到对方接受才会继续执行
- 在接收值时，对方没有发送就会阻塞，直到对方发送才会继续执行

代码验证情况1：发送值后，对方不接收会被阻塞
```go
func TestNoBuffer(t *testing.T) {

    c := make(chan int)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
        }
    }()

    fmt.Println("阻塞主线程 10秒 后接收")
    time.Sleep(10 * time.Second)

    x := <-c
    fmt.Println("接收 i: ", x)
    fmt.Println("再次阻塞主线程，查看日志是否有数据放入通道")
    time.Sleep(10 * time.Hour)
}
```
输出
```
阻塞主线程 10秒 后接收
放入 i: 0
接收 i:  0
再次阻塞主线程，查看日志是否有数据放入通道
放入 i: 1
```

代码验证情况2：接收值时对方没有发送，就会阻塞线程
```go
func TestNoBufferReceive(t *testing.T) {

    c := make(chan int)

    go func() {

        fmt.Println("开始接收值")

        for {
            x := <-c
            fmt.Println("接收 i: ", x)
        }

    }()
    fmt.Println("主线程阻塞")
    time.Sleep(1 * time.Hour)
}
```
输出
```
主线程阻塞
开始接收值
```
### 有缓冲的channel

有缓冲的通道，能够存储指定量的数据。

- 对于放入端，只要通道没有满，那么就不会阻塞
- 对于接收端，只要通道没有空，就不会阻塞


代码示例
```go
func TestNoBuffer(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
        }
    }()

    fmt.Println("阻塞主线程 10秒 后接收")
    time.Sleep(10 * time.Second)

    x := <-c
    fmt.Println("接收 i: ", x)
    fmt.Println("再次阻塞主线程，查看日志是否有数据放入通道")
    time.Sleep(10 * time.Hour)
}
```

输出
```bash
阻塞主线程 10秒 后接收
放入 i: 0
放入 i: 1
放入 i: 2
接收 i:  0
再次阻塞主线程，查看日志是否有数据放入通道
放入 i: 3
```

### 关闭channel

发送者 关闭
```go
func TestChannelClose(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
            close(c)
            break
        }
        fmt.Println("退出子线程")

    }()

    fmt.Println("阻塞主线程 5秒 后接收")
    time.Sleep(5 * time.Second)
    if data, ok := <-c; ok {
        fmt.Println("接收值", data) //接收者仍然可以接收关闭通道的值
    }

    time.Sleep(1 * time.Second)
}
```
输出
```
阻塞主线程 5秒 后接收
放入 i: 0
退出子线程
接收值 0
```

接收者关闭
```go
func TestChannelClose(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
            time.Sleep(100)
        }

        fmt.Println("退出子线程")
    }()

    time.Sleep(1 * time.Second)
    if data, ok := <-c; ok {
        fmt.Println("接收值", data)
    }
    close(c)//关闭 通道 , 发送者会抛出通道已关闭的异常

    time.Sleep(1 * time.Second)
}
```
输出
```
放入 i: 0
放入 i: 1
放入 i: 2
接收值 0
放入 i: 3
panic: send on closed channel
```

- channel 不需要像文件一样经常关闭，只有需要结束时关闭即可
- 关闭 channel 后，
- 关闭 channel 后，可以继续从channel 接收数据


### 使用range操作 channel

```go
func TestRangeChannel(t *testing.T) {
    c := make(chan int)

    go func() {
        for i := 0; i < 5; i++ {
            c <- i
        }
        close(c)
    }()

    for data := range c {
        fmt.Println(data)
    }
    fmt.Println("Finished")
}
```


### 单向channel

默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。

我们可以指定通道的方向，可以让它只发送数据，或者只接收数据。


#### 单向channel声明

```go
var ch1 chan int        // ch1是一个正常的channel，是双向的
var ch2 chan<- float64  // ch2是单向channel，只用于写float64数据
var ch3 <-chan int      // ch3是单向channel，只用于读int数据
```


- `chan<-` 表示数据进入管道，要把数据写进管道，对于调用者就是输出。
- `<-chan` 表示数据从管道出来，对于调用者就是得到管道的数据，当然就是输入。

可以将 channel 隐式转换为单向队列，但是不能将单向 channel 转为普通 channel

```go
c := make(chan int, 3)
var send chan<- int = c     // 只发送
var recv <-chan int = c     // 只接收
```

使用示例
```go
func counter(out chan<- int) {
    defer close(out)
    for i := 0; i < 5; i++ {
        out <- i //如果对方不读 会阻塞
    }
}

// <-chan //只读
func printer(in <-chan int) {
    for num := range in {
        fmt.Println(num)
    }
}
func TestF2(t *testing.T) {
    c := make(chan int) //   chan   //读写

    go counter(c) //生产者

    go printer(c) //消费者
    
    time.Sleep(1 * time.Second)
    close(c) //原有的 c 通道，依然能影响 转换后的 单向通道
    time.Sleep(1 * time.Hour)
    fmt.Println("done")
}
```

输出
```bash
0
1
2
3
4
--- FAIL: TestF2 (1.02s)
panic: close of closed channel [recovered]
    panic: close of closed channel
```


#### 生产者消费者模型

单向通道最适合的就是生产者消费者模型，对于生产者消费者处理能力不同步的情况，可以设置通道的缓存，以适应。

### 基于channel的死锁

```go
func Test10(t *testing.T) {
    //创建无缓冲 channel
    ch := make(chan int)
    ch <- 1 // 向通道内写入，然后被阻塞，因为ch 是无缓冲的
    fmt.Println("send")

    go func() {
        <-ch // 这里永远不会被调用
        fmt.Println("received")
    }()
    fmt.Println("over")
}
```
输出
```bash
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
testing.(*T).Run(0xc00012a340, {0xf5b883?, 0xc00bd2cc8c?}, 0xf69270)

    C:/my/go1.22.1/src/testing/testing.go:1750 +0x3ab
testing.runTests.func1(0xc00012a340)
    C:/my/go1.22.1/src/testing/testing.go:2161 +0x37
testing.tRunner(0xc00012a340, 0xc000115c70)
    C:/my/go1.22.1/src/testing/testing.go:1689 +0xfb
testing.runTests(0xc0000080f0, {0x106b620, 0x1d, 0x1d}, {0x1?, 0xecffb3?, 0x0?})
    C:/my/go1.22.1/src/testing/testing.go:2159 +0x445
testing.(*M).Run(0xc000078140)
    C:/my/go1.22.1/src/testing/testing.go:2027 +0x68b
main.main()
    _testmain.go:103 +0x16c

goroutine 6 [chan send]:
geektime-web/main.Test10(0xc00012a4e0?)
    D:/gopath/src/geektime-web/main/t6_test.go:355 +0x36
testing.tRunner(0xc00012a4e0, 0xf69270)
    C:/my/go1.22.1/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
    C:/my/go1.22.1/src/testing/testing.go:1742 +0x390
```
### nil channel

从一个已经关闭的 channel 获取数据永远不会被阻塞，还可以获取到 对应类型的 零值，对一个 nil channel 进行获取操作，会造成**阻塞**

示例：
```go
func Test11(t *testing.T) {
    c1, c2 := make(chan int), make(chan int)

    go func() {
        time.Sleep(5 * time.Second)
        c1 <- 5
        close(c1)
    }()
    go func() {
        time.Sleep(7 * time.Second)
        c2 <- 7
        close(c2)
    }()
    var ok1, ok2 bool
    for {
        select {
        case x := <-c1:
            ok1 = true
            fmt.Println(x)

        case x := <-c2:
            ok2 = true
            fmt.Println(x)
        }
        if ok1 && ok2 {
            break
        }
    }
}
```
输出：我们可以看到输出了很多我们不期望的 0 ，就是因为 c1 在被关闭后，不在阻塞并能够获取到int的零值
```bash
5
0
0
0
。。。。
0
0
0
7
end
```


## time

### time.Timer


Timer是一个定时器。代表未来的一个单一事件，你可以告诉timer你要等待多长时间。

```go
type Timer struct {
    C <-chan Time
    r runtimeTimer
}
```
它提供一个channel，在定时时间到达之前，没有数据写入 timer.C 会一直阻塞。直到定时时间到，定时器就会向自己的C字节发送一个time.Time类型的元素值，阻塞解除，可以从中读取数据。

```go
func TestTimer2(t *testing.T) {
    //创建定时器，5秒后，定时器就会向自己的C字节发送一个time.Time类型的元素值
    timer1 := time.NewTimer(time.Second * 5)
    t1 := time.Now() //当前时间
    fmt.Printf("t1: %v\n", t1)

    t2 := <-timer1.C //在这里被阻塞，直到定时时间到
    fmt.Printf("t2: %v\n", t2)
}
```
输出：注意两个时间相差两秒
```
t1: 2024-03-27 20:04:32.9717091 +0800 CST m=+0.002626401
t2: 2024-03-27 20:04:34.978423 +0800 CST m=+2.009340301
```


使用 NewTimer、 sleep 、 After  进行等待
```go
func TestTimer2(t *testing.T) {
    //如果只是想单纯的等待的话，可以使用 time.Sleep 来实现
    timer2 := time.NewTimer(time.Second * 2)
    <-timer2.C
    fmt.Println("2s后:", time.Now())

    time.Sleep(time.Second * 2)
    fmt.Println("再一次2s后:", time.Now())

    <-time.After(time.Second * 2)
    fmt.Println("再再一次2s后:", time.Now())
}
```


停止定时器
```go
func TestTimer3(t *testing.T) {
    timer3 := time.NewTimer(time.Second)
    go func() {
        <-timer3.C
        fmt.Println("Timer 3 expired")
    }()

    stop := timer3.Stop() //停止定时器
    if stop {
        fmt.Println("Timer 3 stopped")
    }
}
```

输出：定时器停止后，后续代码不在运行
```bash
Timer 3 stopped
```

重置定时器
```go
func TestTime5(t *testing.T) {
    timer4 := time.NewTimer(time.Second * 5) // 5s等待
    timer4.Reset(time.Second * 3)            // 3s等待
    fmt.Println(time.Now())
    <-timer4.C
    fmt.Println(time.Now())
}
```
输出：中间相差3秒
```bash
2024-03-27 20:12:41.7107254 +0800 CST m=+0.002595401
2024-03-27 20:12:44.7229744 +0800 CST m=+3.014844401
```

#### 定时器常用操作

1. 实现延迟功能
    1. After
    
        ```go
        <-time.After(2 * time.Second)
        ``` 
    1. `Sleep` 
        ```
        time.Sleep(2 * time.Second)
        ```
    1. `NewTimer`
        ```go
        timer := time.NewTimer(2 * time.Second)
        <- timer.C
        ```
1. 定时器停止
    ```go
    timer := time.NewTimer(3 * time.Second)
    go func() {
        <-timer.C
        fmt.Println("子协程可以打印了，因为定时器的时间到")
    }()
    timer.Stop() //停止定时器

    for {
    }
    ```
1. 定时器重置
    ```go
    ok := timer1.Reset(1 * time.Second) //重新设置为1s
    ```

### time.Ticker

Ticker是一个周期触发定时的计时器，它会按照一个时间间隔往channel发送系统当前时间，而channel的接收者可以以固定的时间间隔从channel中读取事件

```go
type Ticker struct {
    C <-chan Time 	// The channel on which the ticks are delivered.
    r runtimeTimer
}
```

使用示例
```go
func TestTicket(t *testing.T) {
    //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)
    ticker := time.NewTicker(time.Second * 1)

    i := 0
    go func() {
        for { //循环
            <-ticker.C
            i++
            fmt.Println("i = ", i)

            if i == 5 {
                ticker.Stop() //停止定时器
            }
        }
    }() //别忘了()

    //死循环，特地不让main goroutine结束
    for {
    }
}
```

## select

Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。

select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。

与switch语句相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：

```go
select {
case <-chan1:
    // 如果chan1成功读到数据，则进行该case处理语句
case chan2 <- 1:
    // 如果成功向chan2写入数据，则进行该case处理语句
default:
    // 如果上面都没有成功，则进入default处理流程()
    // 如果没有 default 语句 select 将被阻塞，直到有一个通信可以执行下去
}
```


示例：
```go
func fibonacci(c, quit chan int) {
    x, y := 1, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func TestSelect(t *testing.T) {
    c := make(chan int)
    quit := make(chan int)

    go func() {
        for i := 0; i < 6; i++ {
            fmt.Println(<-c)
        }
        quit <- 0
    }()

    fibonacci(c, quit)
}
```
输出
```bash
1
1
2
3
5
8
quit
```

### 使用select 解决超时
有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：
```go
func main() {
    c := make(chan int)
    o := make(chan bool)
    go func() {
        for {
            select {
            case v := <-c:
                fmt.Println(v)
            case <-time.After(5 * time.Second):
                fmt.Println("timeout")
                o <- true
                break
            }
        }
    }()
    //c <- 666 // 注释掉，引发 timeout
    <-o
}
```
### 使用select 实现心跳机制

```go
func Test13(t *testing.T) {
    heartbeat := time.NewTicker(1 * time.Second)
    defer heartbeat.Stop()
    for {
        select {
        case t := <-heartbeat.C: //心跳逻辑
            fmt.Println(t)

        }
    }
}
```
输出
```bash
2024-03-28 19:59:43.385703 +0800 CST m=+1.004713301
2024-03-28 19:59:44.3941031 +0800 CST m=+2.013113401
2024-03-28 19:59:45.3871755 +0800 CST m=+3.006185801
2024-03-28 19:59:46.3950864 +0800 CST m=+4.014096701
.
.
.;/
```

## sync包
标准库 sync 包提供了针对传统**基于共享内存模型**的基本同步原语，包括  互斥锁(sync.Mutex) 、 读写锁(sync.RWMutex) 、 条件变量(sync.Cond) 等



### sync.Mutex

当需要高性能的临界区同步场景时， Mutex 要比 channel 的性能要高很多


**示例：**
使用 Mutex 
```go
var cs = 0
var m2 sync.Mutex

func byMutex() {
    m2.Lock()
    defer m2.Unlock()
    cs++
}

func Test16(b *testing.T) {
    for n := 0; n < 100000000; n++ {
        byMutex()
    }
}
```
结果
```bash
=== RUN   Test16
--- PASS: Test16 (0.40s)
PASS
```

使用 channel
```go
var cs = 0
var c = make(chan struct{}, 1)

func Test17(b *testing.T) {
    for n := 0; n < 100000000; n++ {
        byChan()
    }
}
```
结果
```bash
=== RUN   Test17
--- PASS: Test17 (1.89s)
PASS
```

注意事项：**避免使用复制后的 Mutex ，因为这会复制 Mutex 的当前状态**

```go
type foo struct {
    n int
    sync.Mutex
}

func Test19(t *testing.T) {
    f := foo{n: 17}
    go func(f foo) {
        for {
            log.Printf("g2: try to lock foo...")
            f.Lock()
            log.Println("g2: lock foo ok")
            time.Sleep(3 * time.Second)
            f.Unlock()
            log.Println("g2: unlock foo ok")
        }
    }(f) //使用 f 的副本执行 g2

    f.Lock()
    log.Println("g1:lock foo ok")

    go func(f foo) {
        log.Printf("g3: try to lock foo...") //g3 会阻塞在这里，这是因为 f 在传入的时候已经是加锁状态，并且由于传入的是副本，所以 g 的解锁不会影响 g3
        f.Lock()
        log.Println("g3: lock foo ok")
        time.Sleep(3 * time.Second)
        f.Unlock()
        log.Println("g3: unlock foo ok")
    }(f) //使用 f 的副本执行 g3

    //time.Sleep(1000 * time.Second)
    f.Unlock()
    log.Println("g1: unlock foo ok")
    time.Sleep(1000 * time.Second)

}
```

go 标准库 Mutex 定义
```go
//$GOROOT/src/sync/mutex.go
type Mutex struct{
    state int32
    sema  uint32
}
```

- state : 表示当前互斥锁的状态
- sema  : 表示控制锁状态的信号量

对 Mutex 的复制会复制这两个整型字段，所以推荐使用 **闭包** 或者 **传递地址或指针** 的方式。

### sync.RWMutex

RWMutex 是 Go 语言中提供的一个读写互斥锁，全称是 "Reader-Writer Mutex"，即读写互斥锁。它允许多个读操作同时进行，但写操作是互斥的，也就是说在任意时刻只能有一个写操作，且写操作会阻塞其他读写操作。

读：加锁、解锁
- RLock：用于获取读锁。当多个 goroutine 尝试获取读锁时，它们可以同时获得，从而允许多个读操作并发进行。
- RUnlock：用于释放读锁。每个调用 RLock 的 goroutine 都应该在其完成读操作后调用 RUnlock。


写锁同 Mutex 相同


### sync.Cond

sync.Cond 是 Go 语言标准库 sync 包中提供的一个基于互斥锁或读写锁实现的条件变量类型，主要用于协调多个 goroutine 访问共享资源时的同步问题。当共享资源的状态发生变化时，sync.Cond 可以用来通知等待条件变化而阻塞的 goroutine。


- NewCond(l Locker): 创建 Cond 对象，需要传入一个锁对象（互斥锁或读写锁）。

- Wait(): 阻塞当前 goroutine，等待通知信号。调用 Wait 方法时会自动释放锁，并在等待期间保持释放状态，直到被唤醒或信号到来。一旦 goroutine 被唤醒或接收到信号，Wait 方法会重新获取锁并返回。

- Signal(): 发送信号通知，唤醒一个等待的 goroutine。如果有多个 goroutine 在等待，Signal 只会唤醒其中一个。

- Broadcast(): 发送信号通知，唤醒所有等待的 goroutine。

sync.Cond 需要与一个互斥锁或读写锁一起使用，以确保不会同时操作共享资源。这种机制使得多个 goroutine 能够在特定条件下协调执行，例如等待某个条件成立后再继续执行。


### sync.WaitGroup
用于等待 goroutine 执行完成，类似于 java 的 Countdownlatch

- Add(delta int): 这个方法用于增加或减少等待goroutine的数量。参数delta可以是正数或负数。当delta为正数时，表示增加计数器的值，通常用于在启动新的goroutine之前增加计数；当delta为负数时，表示减少计数器的值，通常用于在goroutine完成其任务后调用，表示该goroutine已经完成。

- Done(): 这个方法用于标记goroutine已执行完成，它实际上是Add(-1)的简化调用。在每个goroutine完成任务后，应该调用Done()方法来减少计数器的值。

- Wait(): 这个方法会阻塞调用它的goroutine，直到WaitGroup中计数器的值变为0，即所有goroutine都执行完成。如果在任何goroutine中没有调用Done()方法，Wait()方法会一直阻塞程序。

### sync.Once

sync.Once 是 Go 语言标准库中的一个同步原语，其主要目的是确保某个操作或函数在并发环境下只被执行一次。这对于诸如单例模式、初始化配置或保持数据库连接等场景特别有用，因为它们需要确保某些操作只执行一次，以避免重复创建资源或造成其他不必要的开销。


sync.Once 的主要特性包括：

- 线程安全：在并发环境下，多个协程或线程可以同时调用 sync.Once，但关联的操作或函数只会被执行一次。

- 延迟执行：与 init 函数不同，sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到实际使用时再执行。

-  控制变量初始化：sync.Once 常用于控制变量的初始化。当且仅当第一次访问某个变量时，它才进行初始化（写操作）。在初始化过程中，所有读操作都会被阻塞，直到初始化完成。一旦初始化完成，变量将驻留在内存中，且只初始化一次。


sync.Once 只有一个导出的方法，即 Do。该方法接收一个函数作为参数，并在首次调用时执行该函数。如果多次调用 Do，只有第一次会执行函数，后续调用则不会有任何效果。

基本示例
```go
var (  
    initOnce sync.Once  
    resource string  
    err      error  
)  
  
func initialize() {  
    // 初始化资源的操作  
    resource = "Initialized resource"  
    err = nil  
}  
  
func GetResource() (string, error) {  
    initOnce.Do(initialize) // 仅在第一次调用时执行 initialize 函数  
    return resource, err  
}
```

在这个例子中，getResource 函数使用 sync.Once 来确保 initialize 函数只会在第一次调用 getResource 时执行。这有助于避免重复初始化的开销，提高性能并确保资源的一致性。


### sync.pool

sync.Pool 是一个数据对象缓存池，具有如下特点

- 它是 goroutine 并发安全的
- 放入该缓存池中的数据对象的生命都是暂时的
- 缓存池中的数据对象是被可以重复利用的，这就减轻了GC压力
- sync.Pool 为每个 P(goroutine调度模型中的P) 单独建立了 local 缓存池，进一步降低高并发下锁的竞争


使用
1. 定义 New 函数，用于在池中没有可用对象时创建新的对象。

    使用 sync.Pool 结构体并传入 New 函数作为字段来创建一个新的 sync.Pool 实例。

    在代码中，myType 是你想要池化的类型。New 函数应该返回一个该类型的新实例的指针（或者任何满足 interface{} 类型的值）。我们也可以使用 New 关键字返回指针
    ```go
    var pool = sync.Pool{  
        New: func() interface{} {  
            // 返回一个新的对象实例  
            // 例如，这里返回一个 *myType 的新实例  
            return &myType{}  
        },  
    }
    ```
2. 从池中获取对象
    使用 Get 方法从池中获取一个对象。由于 Get 返回的是 interface{} 类型，因此你可能需要进行类型断言将其转换为你期望的类型。
    ```go
    obj := pool.Get().(*myType)  
    // 使用 obj 进行操作...
    ```
2. 从池中获取对象

    使用 Get 方法从池中获取一个对象。由于 Get 返回的是 interface{} 类型，因此你可能需要进行类型断言将其转换为你期望的类型。
    ```go
    obj := pool.Get().(*myType)  
    // 使用 obj 进行操作...
    ```

3. 使用完对象后放回池中：
    ```go
    pool.Put(obj)
    ```


### sync.map


sync.Map是Go语言中的一个并发安全的映射类型，它可以在多个goroutine之间安全地存储和访问数据。其设计目标是提供高效的并发读写操作，尤其适用于读多写少的场景。

sync.Map的原理是使用两个map（read和dirty）进行读写分离，但两个map共用底层的entry实体。read map仅用于读操作，它好比sync.Map的一个“高速缓存”。当goroutine从sync.Map中读数据时，sync.Map会首先查看read这个缓存层是否有用户需要的数据（key是否命中）。如果key命中，则通过原子操作将数据读取并返回，这是sync.Map推荐的快速路径（fast path），也是sync.Map读性能极高的原因。

而dirty map则用于在特定情况下存储最新写入的key-value数据。当read map中的miss次数（即读取read map获取不到key的次数）到达一定阈值后，dirty map会提升为read map。dirty map被再创建时，会浅拷贝read map。

总的来说，sync.Map通过读写分离和缓存机制，实现了高效的并发读写操作，避免了显式的锁操作，从而提高了并发性能。



使用

- Store：存储一对 key-value 值。

- Load：根据 key 获取对应的 value 值，并且可以判断 key 是否存在。

- LoadOrStore：如果 key 对应的 value 存在，则返回该 value；如果不存在，存储相应的 value。

- Delete：删除一个 key-value 键值对。

- Range：循环迭代 sync.Map，效果与 for range 一样。

```go
package main  
  
import (  
    "fmt"  
    "sync"  
)  
  
func main() {  
    // 创建一个sync.Map  
    var m sync.Map  
  
    // 使用Store方法存储键值对  
    m.Store("one", 1)  
    m.Store("two", 2)  
    m.Store("three", 3)  
  
    // 使用Load方法读取键值对  
    var value interface{}  
    value, ok := m.Load("two")  
    if ok {  
        fmt.Println("Value for 'two':", value)  
    }  
  
    // 使用Range方法遍历sync.Map中的所有键值对  
    m.Range(func(key, value interface{}) bool {  
        fmt.Printf("key: %s, value: %d\n", key, value)  
        // 返回true表示继续迭代，返回false则停止迭代  
        return true  
    })  
  
    // 使用Delete方法删除键值对  
    m.Delete("one")  
  
    // 再次检查'one'键是否存在  
    if _, ok := m.Load("one"); !ok {  
        fmt.Println("'one' has been deleted")  
    }  
}
```



1. sync.Map的键必须是可比较的，也就是说，键的实际类型不能是函数类型、字典类型或切片类型。

1. 在使用Range方法时，由于sync.Map可能在迭代过程中被其他goroutine修改，所以迭代得到的结果可能不是最新的或完整的。如果需要确保得到一致性的结果，你可能需要在迭代过程中加锁或使用其他同步机制。但请注意，这样做可能会降低性能。

1. 由于sync.Map的设计目标主要是提供高效的并发读写操作，所以在某些场景下，其性能可能不如使用传统的互斥锁（mutex）或读写锁（RWMutex）保护的map。因此，在选择使用sync.Map时，需要根据具体的使用场景和性能要求进行评估。


## sync/atomic


atomic 包提供了一组函数，可以对基本数据类型和一些复杂类型进行原子操作

1. 加载（Load）和存储（Store）
    
    从内存中原子地加载一个值。
    ```go
    LoadInt32、LoadInt64、LoadUint32、LoadUint64、LoadUintptr、LoadPointer：
    ```

    原子地将一个值存储到内存中。
    ```go
    StoreInt32、StoreInt64、StoreUint32、StoreUint64、StoreUintptr、StorePointer：
     ```


1. 比较并交换（CompareAndSwap, CAS）

    `CompareAndSwapInt32、CompareAndSwapInt64` 等：
    
    原子地比较目标变量的当前值是否等于给定的旧值，如果是，则将目标变量设置为新值。这个函数返回一个布尔值，表示是否成功地将新值存储到目标变量中。

1. 其他操作

    `AddInt64、SubInt64、AddUint32、SubUint32` 等：原子地对整数进行加或减操作。


示例1：对共享整型变量的无锁读写
```go
var nl int64

func atomicAddInt() int64 {
	return atomic.AddInt64(&nl, 1)
}

func atomicLoadInt() int64 {
	return atomic.LoadInt64(&nl)
}
```

示例2：对自定义类型的无锁读写
```go
type Config struct {
	data string
}

func BenchmarkSet(b *testing.B) {
    // 声明一个 atomic.Value 类型的变量 config，用于存储 Config 类型的值  
	var config atomic.Value
	c := Config{data: "hello"}
	b.ReportAllocs()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
            // 原子地将 Config 类型的值 c 存储到 config 变量中  
			config.Store(c)
		}
	})

}
```

**适用场景**

atomic 更适合一些对性能十分敏感的操作，适合读多写少的场景。如果需要对一个较大的临界区操作还是首选 sync 包中的原语


## 协程如何退出
在一般的多线程程序中，我们可以设置一个全局变量，来通知各个线程退出与否。在使用该全局变量时，一般使用`锁`对其进行保护，并暴露其在多线程下的可见性(例如 java 的 volitail)。



### 通过select+channel退出协程

```go
func TestChannel2(t *testing.T) {

	var wg sync.WaitGroup
	wg.Add(1)
	stopCh := make(chan bool) //用来停止监控狗
	go func() {
		defer wg.Done()
		watchDog2(stopCh, "【监控狗1】")
	}()

	time.Sleep(5 * time.Second) //先让监控狗监控5秒
	fmt.Println("发出退出指令")
	stopCh <- true //发停止指令

	wg.Wait()
	fmt.Println("主协程退出")

}

func watchDog2(stopCh chan bool, name string) {

	//开启for select循环，一直后台监控
	for {
		select {

		case <-stopCh:
			fmt.Println(name, "停止指令已收到，马上停止")
			return

		default:
			fmt.Println(name, "正在监控……")

		}
		time.Sleep(1 * time.Second)
	}
}
```


## context


通过 `select + channel` 的方式退出协程，比较优雅，但是如果我们希望同时取消多个协程呢？

如果要定时取消协程又该怎么办呢？

在使用 select + channel 的方式，则需要定义多个 channel ，但是这样代码会非常复杂，难以维护。

go 语言提供了 context 可以跟踪到每个协程并控制它们。



### 改写监控狗代码


```go
func TestContext(t *testing.T) {
	var wg sync.WaitGroup

	wg.Add(1)

	ctx, stop := context.WithCancel(context.Background())

	go func() {
		defer wg.Done()
		watchDog(ctx, "【监控狗1】")
	}()

	time.Sleep(5 * time.Second) //先让监控狗监控5秒

    //将上面的向通道写值，改为调用stop 方法
	stop() //发停止指令,

	wg.Wait()

}

func watchDog(ctx context.Context, name string) {

	//开启for select循环，一直后台监控
	for {
		select {

        //将上面的监听通道，改为监听 contex.Done 方法的返回的通道
		case <-ctx.Done():
			fmt.Println(name, "停止指令已收到，马上停止")
			return

		default:
			fmt.Println(name, "正在监控……")

		}
		time.Sleep(1 * time.Second)
	}

}
```

可以看到，这和修改前的整体代码结构一样，只不过从 channel 换成了 Context。以上示例只是 Context 的一种使用场景，它的能力不止于此。



### 什么是 Context

一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。

如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。

Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。

Context 接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。


```go
type Context interface {

    // deadline: 截止时间
    // ok      : 是否设置截止时间
    Deadline() (deadline time.Time, ok bool)

    // 返回一个只读的 channel ，如果该 channel 可以读取，那么可以已退出协程
    Done() <-chan struct{}

    //返回取消的错误原因，即因为什么原因 Context 被取消。
    Err() error

    // Value 方法获取该 Context 上绑定的值，是一个键值对，
    // 所以要通过一个 key 才可以获取对应的值。
    Value(key interface{}) interface{}
}
```

### Context 树

我们不需要自己实现 Context 接口，Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。

从使用功能上分，有四种实现好的 Context。

- 空 Context：不可取消，没有截止时间，主要用于 Context 树的根节点。

- 可取消的 Context：用于发出取消信号，当取消的时候，它的子 Context 也会取消。

- 可定时取消的 Context：多了一个定时的功能。

- 值 Context：用于存储一个 key-value 键值对。

从下图 Context 的衍生树可以看到，最顶部的是空 Context，它作为整棵 Context 树的根节点，在 Go 语言中，可以通过 context.Background() 获取一个根节点 Context。



![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240525130929.png)




有了根节点 Context 后，这颗 Context 树要怎么生成呢？需要使用 Go 语言提供的四个函数。

- WithCancel(parent Context)：生成一个可取消的 Context。

- WithDeadline(parent Context, d time.Time)：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。 设置的是绝对的时间点，如 24年5月30日 01 时，01分，01秒，0001毫秒等

- WithTimeout(parent Context, timeout time.Duration)：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消，设置的是相对的时间点，如5秒后

- WithValue(parent Context, key, val interface{})：生成一个可携带 key-value 键值对的 Context。

以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。

示例：
```go
func TestContexDealLine2(t *testing.T) {
	var wg sync.WaitGroup
	// 可取消的 context
	ctx, _ := context.WithCancel(context.Background())
	// 有截止时间的 context
	ctx, stopFunc2 := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second)) // 延长截止时间以便观察
	// 可设置值的 context
	ctx = context.WithValue(ctx, "1", 2)

	for i := 0; i < 4; i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done() // 确保在协程退出时调用Done
			for {
				select {
				case <-ctx.Done():
					fmt.Println(n, ":协程退出")
					return
				default:
					fmt.Println(n, "work", ctx.Value("1"))
					time.Sleep(time.Millisecond * 100) // 添加延时以便观察协程的工作
				}
			}
		}(i) // 传递i作为参数给协程，如果直接使用的话，会作为闭包传入，最终值，在这里就是 4
	}
	time.Sleep(time.Second * 1)
	fmt.Println("发出退出命令")
	stopFunc2()

	wg.Wait()
}
```


### context 
Context 是一种非常好的工具，使用它可以很方便地控制取消多个协程。在 Go 语言标准库中也使用了它们，比如 net/http 中使用 Context 取消网络的请求。

要更好地使用 Context，有一些使用原则需要尽可能地遵守。

- Context 不要放在结构体中，要以参数的方式传递。

- Context 作为函数的参数时，要放在第一位，也就是第一个参数。

- 要使用 context.Background 函数生成根节点的 Context，也就是最顶层的 Context。

- Context 传值要传递必须的值，而且要尽可能地少，不要什么都传。

- Context 多协程安全，可以在多个协程中放心使用。


## go语言并发模式




### for select 模式
for select 循环模式非常常见，在前面的课程中也使用过，它一般和 channel 组合完成任务，代码格式如下：

```go
for { //for无限循环，或者for range循环

  select {

    //通过一个channel控制
    case <- channel:
        return
    default:
        //执行具体的任务

  }

}
```
这是一种 for 循环 +select 多路复用的并发模式，哪个 case 满足就执行哪个，直到满足一定的条件退出 for 循环（比如发送退出信号）。

在这上面有一个变种，即 使用一个 channel 作为指示退出的标识，使用其它 channel 作为接收/发送，一般配置 for range 使用


```go
for _,s:=range []int{}{

   select {

    //用于退出for 循环
    case <-done:
      return

    //用于发送/接收值
    case resultCh <- s:
   }
}
```

### select timeout 模式

假如需要访问服务器获取数据，因为网络的不同响应时间不一样，为保证程序的质量，不可能一直等待网络返回，所以需要设置一个超时时间，这时候就可以使用 select timeout 模式，如下所示：

```go
func main() {

   result := make(chan string)

   go func() {
      //模拟网络访问
      time.Sleep(8 * time.Second)
      result <- "服务端结果"

   }()

   select {

   case v := <-result:
      fmt.Println(v)

   case <-time.After(5 * time.Second)://通过 time.After 防止 select 无限等待

      fmt.Println("网络访问超时了")
   }
}
```

select timeout 模式的核心在于通过 time.After 函数设置一个超时时间，防止因为异常造成 select 语句的无限等待。

> 小提示：如果可以使用 Context 的 WithTimeout 函数超时取消，要优先使用。

### Pipeline 模式/流水线模式

Pipeline 模式也称为流水线模式，模拟的就是现实世界中的流水线生产。以手机组装为例，整条生产流水线可能有成百上千道工序，每道工序只负责自己的事情，最终经过一道道工序组装，就完成了一部手机的生产。

从技术上看，每一道工序的输出，就是下一道工序的输入，在工序之间传递的东西就是数据，这种模式称为流水线模式，而传递的数据称为数据流。


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240527193845.png)
通过以上流水线模式示意图，可以看到从最开始的生产，经过工序 1、2、3、4 到最终成品，这就是一条比较形象的流水线，也就是 Pipeline。

现在我以组装手机为例，讲解流水线模式的使用。假设一条组装手机的流水线有 3 道工序，分别是配件采购、配件组装、打包成品，如图所示：


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240527193901.png)


从以上示意图中可以看到，采购的配件通过 channel 传递给工序 2 进行组装，然后再通过 channel 传递给工序 3 打包成品。相对工序 2 来说，工序 1 是生产者，工序 3 是消费者。相对工序 1 来说，工序 2 是消费者。相对工序 3 来说，工序 2 是生产者。

我用下面的几组代码进行演示：

**工序1采购**
```go
func buy(n int) <-chan string {

   out := make(chan string)//定义一个输出 channel

   go func() {

      defer close(out)
      for i := 1; i <= n; i++ {
         out <- fmt.Sprint("配件", i)
      }
   }()
   return out
}
```
**工序2组装**
```go
func build(in <-chan string) <-chan string {
   out := make(chan string)
   go func() {
      defer close(out)
      for c := range in {
         out <- "组装(" + c + ")"
      }
   }()
   return out
}
```
工序3打包
```go
func pack(in <-chan string) <-chan string {
   out := make(chan string)
   go func() {
      defer close(out)
      for c := range in {
         out <- "打包(" + c + ")"
      }
   }()
   return out
}
```

```go
func main() {

   coms := buy(10)    //采购10套配件
   phones := build(coms) //组装10部手机
   packs := pack(phones) //打包它们以便售卖

   //输出测试，看看效果
   for p := range packs {
      fmt.Println(p)
   }
}
```

从上述例子中，我们可以总结出一个流水线模式的构成：

流水线由一道道工序构成，每道工序通过 channel 把数据传递到下一个工序；

每道工序一般会对应一个函数，函数里有协程和 channel，协程一般用于处理数据并把它放入 channel 中，整个函数会返回这个 channel 以供下一道工序使用；

最终要有一个组织者（示例中的 main 函数）把这些工序串起来，这样就形成了一个完整的流水线，对于数据来说就是数据流。


### 扇出和扇入模式

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240528192711.png)



```go

//扇入函数（组件），把多个chanel中的数据发送到一个channel中
func merge(ins ...<-chan string) <-chan string {

	var wg sync.WaitGroup
	out := make(chan string)

	//把一个channel中的数据发送到out中
	p := func(in <-chan string) {
		defer wg.Done()
		for c := range in {
			out <- c
		}
	}

	wg.Add(len(ins))

	//扇入，需要启动多个goroutine用于处于多个channel中的数据
	for _, cs := range ins {
		go p(cs)
	}

	//等待所有输入的数据ins处理完，再关闭输出out
	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}

func TestPippeline2(t *testing.T) {

    //1.配件 i
	coms := buy(100) //采购100套配件

    //2.组装
	//三班人同时组装100部手机
	phones1 := build(coms) 
	phones2 := build(coms)
	phones3 := build(coms)

	//3.汇聚三个channel成一个
	phones := merge(phones1, phones2, phones3)

    //4.打包
	packs := pack(phones) //打包它们以便售卖

	//输出测试，看看效果
	for p := range packs {
		fmt.Println(p)
	}
}
```


### Futures 模式


Futures 模式可以理解为未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取，如果子协程还没有返回结果，就一直等待。我用下面的代码进行演示：

```go
//洗菜

func washVegetables() <-chan string {
   vegetables := make(chan string)
   go func() {
      time.Sleep(5 * time.Second)
      vegetables <- "洗好的菜"
   }()
   return vegetables
}

//烧水

func boilWater() <-chan string {
   water := make(chan string)
   go func() {
      time.Sleep(5 * time.Second)
      water <- "烧开的水"
   }()
   return water
}
```

```go
func main() {
   vegetablesCh := washVegetables() //洗菜
   waterCh := boilWater()           //烧水
   fmt.Println("已经安排洗菜和烧水了，我先眯一会")
   time.Sleep(2 * time.Second)



   fmt.Println("要做火锅了，看看菜和水好了吗")
   vegetables := <-vegetablesCh
   water := <-waterCh
   fmt.Println("准备好了，可以做火锅了:",vegetables,water)
}
```



# go错误处理策略

go 语言中没有提供 try catch 的异常处理机制，而是和 c 语言一样，认为 **错误就是值** ，同时结合多返回值策略，避免了单返回值承载信息过多的情况

error接口

```go
//$GOROOT/src/builtin/builtin.go
type interface error {
    Error() string
}
```

## 构造错误值

**使用 `errors.New(string)`**
```go
err := errors.New("first error")
```

**使用 `fmt.Errorf(string)`**

```go
fmt.Errorf("wrap err:%d", 1)
fmt.Errorf("wrap err:%w", e1)
```

当我们使用 `%w`  时 `fmt.Errorf` 返回的错误类型为 `fmt.warpError`
```go
type warpError {
    msg string
    err Error
}

func (e *warpError) Error() string {
    return e.msg
}

func (e *warpError) Unwarp() Error {
    return e.err
}
```

`warpError` 类型的包装的错误，可以被**包装错误链**检查到

```go
e1 := errors.New("123")

e2 := fmt.Errorf("wrap err:%w", e1)

is := errors.Is(e2, e1) //e2 是否等于e1 或者 e2 包裹了 e1 返回 true
fmt.Print(is)
```
## 携带上下文的错误类型

标准库中的net 包定义的携带上下文的错误类型
```go
//$GOROOT/src/net/net.go
type OpError struct {
    Op string
    Net string
    Source Addr 
    Addr Addr
    Err error
}
```

## 透明错误处理策略

```go
err := dosomething()
if err != nil{
    //不关心错误如何，执行简单的逻辑并返回错误
    ...
    return
}
```

这是最常见的错误处理策略

## 哨兵错误处理策略

我们可以判断 `Error()` 方法返回的错误字符串来进行处理，但是这种方式容易造成**隐式的耦合**，所以可以采用导出错误值的方式做出错误的分支处理

```go
// $GOROOT/src/bufio/bufio.go
var(
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    .
    .
    .
)

// 错误处理代码
data, err := b.Peek()

if err != nil {
    switch err
    case bufio.ErrInvalidUnreadByte:
        ....
        return 

    case ...:
        ....
        return 
    。
    。
    。
}
```

注意导出的错误一般以 `Errxxx` 方式命名




