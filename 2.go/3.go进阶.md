

# go并发

## 并发与并行

并行：同一时刻，执行多条指令
并发：同一时刻，只有一条指令在执行，但是进程会被轮换执行，这依赖 CPU时间片算法

## 进程

程序执行，称为进程。

### 进程状态

进程基本的状态有5种。分别为`初始态`，`就绪态`，`运行态`，`挂起态`与`终止态`。其中初始态为进程准备阶段，常与就绪态结合来看。

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240325213125.png)



### 进程并发

进程，系统开销比较大，并发数量少，

## 线程

线程是轻量级的进程

进程：独立的内存空间，有PCB
线程，有PCB，有共享的内存空间

线程一般是最小的执行单位，进程是最小的资源分配单位


### 线程同步

同步即协同步调，按预定的先后次序运行

- 互斥量 - mutex

- 读写锁
    写独占，读共享


## 协程

协程 是轻量级线程，一个线程可以拥有多个协程，但同一时刻，只能有一个协程运行，多个协程共享，该线程的计算机资源

## go 并发
go 在语言层面支持并发 `goroutine` . Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。

Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。

Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。

## goroutine

goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。

### goroutine创建

使用 go 关键字
```go
func newTask() {
    i := 0
    for {
        i++
        fmt.Printf("new goroutine: i = %d\n", i)
        time.Sleep(1 * time.Second) //延时1s
    }
}

func TestGoroutine(t *testing.T) {
    go newTask()
    time.Sleep(1 * time.Second) //延时1s
    //退出
    fmt.Println("main goroutine exit")
}
```
输出
```
new goroutine: i = 1
new goroutine: i = 2
main goroutine exit
```

主goroutine退出后，其它的工作goroutine也会自动退出


### runtime 包

#### runtime.Gosched()
出让当前时间片，直到调度器再次调度，类似于其它语言的 yield 方法

示例
```go
func TestGosched(t *testing.T) {
    go func(s string) {
        for i := 0; i < 2; i++ {
            fmt.Println(s)
        }
    }("world")

    for i := 0; i < 2; i++ {
        runtime.Gosched() //import "runtime" 包
        /*
           屏蔽runtime.Gosched()运行结果如下：
               hello
               hello

           没有runtime.Gosched()运行结果如下：
               world
               world
               hello
               hello
        */
        fmt.Println("hello")
    }
}
```

#### runtime.Goexit()

立即终止 当前 goroutine 执行，调度器会确保 所有 **已注册的 `defer` 执行**

```go

func TestGoExit(t *testing.T) {
    go func() {
        defer fmt.Println("A.defer")

        defer fmt.Println("B.defer")

        runtime.Goexit() // 终止当前 goroutine
        fmt.Println("A") // 不会执行
    }()
}
```


####  runtime.GOMAXPROCS()

设置可以并行计算的CPU核数的最大值，并返回之前的值

```go
func TestMaxCore(t *testing.T) {

    fmt.Printf("cpu %d", runtime.NumCPU()) // 获取当前的核心数

    //设置 使用的核心数为 2
    n := runtime.GOMAXPROCS(2)

    fmt.Printf("n = %d\n", n)

    maxProcs := runtime.GOMAXPROCS(0)
    fmt.Println("Current GOMAXPROCS value:", maxProcs) //获取当前使用的核心数
}
```

注意，从Go 1.5开始，GOMAXPROCS的默认值可能会根据系统的CPU核心数自动设置，通常不需要手动设置。在并发编程时，应该更多地依赖Go的goroutines和channels进行通信和同步，而不是直接控制线程数量。Go运行时会自动在可用的逻辑处理器之间调度goroutines的执行，以实现高效的并发性能。



## channel

channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。

goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。goroutine 奉行通过通信来共享内存，而不是共享内存来通信。

引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240325223724.png)

### 使用channel

使用make 创建 channel
```go
make(chan Type)  //等价于make(chan Type, 0)
make(chan Type, capacity)
```

当 参数capacity= 0 时，channel 是无缓冲阻塞读写的；当capacity > 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。


channel非常像生活中的管道，一边可以存放东西，另一边可以取出东西。channel通过操作符 <- 来接收和发送数据，发送和接收数据语法：

```go
channel <- value        //发送value到channel
<-channel               //接收并将其丢弃
val := <-channel        //从channel中接收数据，并赋值给val
val, ok := <-channel    //功能同上，同时检查通道是否已关闭或者是否为空
```

默认情况下， channel 接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。

### 无缓冲 channel

无缓冲的通道，不能保存值的通道。
- 在发送值后，对方没有接收时就会阻塞，直到对方接受才会继续执行
- 在接收值时，对方没有发送就会阻塞，直到对方发送才会继续执行

代码验证情况1：发送值后，对方不接收会被阻塞
```go
func TestNoBuffer(t *testing.T) {

    c := make(chan int)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
        }
    }()

    fmt.Println("阻塞主线程 10秒 后接收")
    time.Sleep(10 * time.Second)

    x := <-c
    fmt.Println("接收 i: ", x)
    fmt.Println("再次阻塞主线程，查看日志是否有数据放入通道")
    time.Sleep(10 * time.Hour)
}
```
输出
```
阻塞主线程 10秒 后接收
放入 i: 0
接收 i:  0
再次阻塞主线程，查看日志是否有数据放入通道
放入 i: 1
```

代码验证情况2：接收值时对方没有发送，就会阻塞线程
```go
func TestNoBufferReceive(t *testing.T) {

    c := make(chan int)

    go func() {

        fmt.Println("开始接收值")

        for {
            x := <-c
            fmt.Println("接收 i: ", x)
        }

    }()
    fmt.Println("主线程阻塞")
    time.Sleep(1 * time.Hour)
}
```
输出
```
主线程阻塞
开始接收值
```
### 有缓冲的channel

有缓冲的通道，能够存储指定量的数据。

- 对于放入端，只要通道没有满，那么就不会阻塞
- 对于接收端，只要通道没有空，就不会阻塞


代码示例
```go
func TestNoBuffer(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
        }
    }()

    fmt.Println("阻塞主线程 10秒 后接收")
    time.Sleep(10 * time.Second)

    x := <-c
    fmt.Println("接收 i: ", x)
    fmt.Println("再次阻塞主线程，查看日志是否有数据放入通道")
    time.Sleep(10 * time.Hour)
}
```

输出
```bash
阻塞主线程 10秒 后接收
放入 i: 0
放入 i: 1
放入 i: 2
接收 i:  0
再次阻塞主线程，查看日志是否有数据放入通道
放入 i: 3
```

### 关闭channel

发送者 关闭
```go
func TestChannelClose(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
            close(c)
            break
        }
        fmt.Println("退出子线程")

    }()

    fmt.Println("阻塞主线程 5秒 后接收")
    time.Sleep(5 * time.Second)
    if data, ok := <-c; ok {
        fmt.Println("接收值", data) //接收者仍然可以接收关闭通道的值
    }

    time.Sleep(1 * time.Second)
}
```
输出
```
阻塞主线程 5秒 后接收
放入 i: 0
退出子线程
接收值 0
```

接收者关闭
```go
func TestChannelClose(t *testing.T) {

    c := make(chan int, 2)
    go func() {
        for i := 0; i < 1000; i++ {
            fmt.Println("放入 i:", i)
            c <- i
            time.Sleep(100)
        }

        fmt.Println("退出子线程")
    }()

    time.Sleep(1 * time.Second)
    if data, ok := <-c; ok {
        fmt.Println("接收值", data)
    }
    close(c)//关闭 通道 , 发送者会抛出通道已关闭的异常

    time.Sleep(1 * time.Second)
}
```
输出
```
放入 i: 0
放入 i: 1
放入 i: 2
接收值 0
放入 i: 3
panic: send on closed channel
```

- channel 不需要像文件一样经常关闭，只有需要结束时关闭即可
- 关闭 channel 后，
- 关闭 channel 后，可以继续从channel 接收数据


### 使用range操作 channel

```go
func TestRangeChannel(t *testing.T) {
    c := make(chan int)

    go func() {
        for i := 0; i < 5; i++ {
            c <- i
        }
        close(c)
    }()

    for data := range c {
        fmt.Println(data)
    }
    fmt.Println("Finished")
}
```


### 单向channel

默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。

我们可以指定通道的方向，可以让它只发送数据，或者只接收数据。


#### 单向channel声明

```go
var ch1 chan int        // ch1是一个正常的channel，是双向的
var ch2 chan<- float64  // ch2是单向channel，只用于写float64数据
var ch3 <-chan int      // ch3是单向channel，只用于读int数据
```


- `chan<-` 表示数据进入管道，要把数据写进管道，对于调用者就是输出。
- `<-chan` 表示数据从管道出来，对于调用者就是得到管道的数据，当然就是输入。

可以将 channel 隐式转换为单向队列，但是不能将单向 channel 转为普通 channel

```go
c := make(chan int, 3)
var send chan<- int = c     // 只发送
var recv <-chan int = c     // 只接收
```

使用示例
```go
func counter(out chan<- int) {
    defer close(out)
    for i := 0; i < 5; i++ {
        out <- i //如果对方不读 会阻塞
    }
}

// <-chan //只读
func printer(in <-chan int) {
    for num := range in {
        fmt.Println(num)
    }
}
func TestF2(t *testing.T) {
    c := make(chan int) //   chan   //读写

    go counter(c) //生产者

    go printer(c) //消费者
    
    time.Sleep(1 * time.Second)
    close(c) //原有的 c 通道，依然能影响 转换后的 单向通道
    time.Sleep(1 * time.Hour)
    fmt.Println("done")
}
```

输出
```bash
0
1
2
3
4
--- FAIL: TestF2 (1.02s)
panic: close of closed channel [recovered]
    panic: close of closed channel
```


#### 生产者消费者模型

单向通道最适合的就是生产者消费者模型，对于生产者消费者处理能力不同步的情况，可以设置通道的缓存，以适应。

### 基于channel的死锁

```go
func Test10(t *testing.T) {
    //创建无缓冲 channel
    ch := make(chan int)
    ch <- 1 // 向通道内写入，然后被阻塞，因为ch 是无缓冲的
    fmt.Println("send")

    go func() {
        <-ch // 这里永远不会被调用
        fmt.Println("received")
    }()
    fmt.Println("over")
}
```
输出
```bash
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
testing.(*T).Run(0xc00012a340, {0xf5b883?, 0xc00bd2cc8c?}, 0xf69270)

    C:/my/go1.22.1/src/testing/testing.go:1750 +0x3ab
testing.runTests.func1(0xc00012a340)
    C:/my/go1.22.1/src/testing/testing.go:2161 +0x37
testing.tRunner(0xc00012a340, 0xc000115c70)
    C:/my/go1.22.1/src/testing/testing.go:1689 +0xfb
testing.runTests(0xc0000080f0, {0x106b620, 0x1d, 0x1d}, {0x1?, 0xecffb3?, 0x0?})
    C:/my/go1.22.1/src/testing/testing.go:2159 +0x445
testing.(*M).Run(0xc000078140)
    C:/my/go1.22.1/src/testing/testing.go:2027 +0x68b
main.main()
    _testmain.go:103 +0x16c

goroutine 6 [chan send]:
geektime-web/main.Test10(0xc00012a4e0?)
    D:/gopath/src/geektime-web/main/t6_test.go:355 +0x36
testing.tRunner(0xc00012a4e0, 0xf69270)
    C:/my/go1.22.1/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
    C:/my/go1.22.1/src/testing/testing.go:1742 +0x390
```
### nil channel

从一个已经关闭的 channel 获取数据永远不会被阻塞，还可以获取到 对应类型的 零值，对一个 nil channel 进行获取操作，会造成**阻塞**

示例：
```go
func Test11(t *testing.T) {
    c1, c2 := make(chan int), make(chan int)

    go func() {
        time.Sleep(5 * time.Second)
        c1 <- 5
        close(c1)
    }()
    go func() {
        time.Sleep(7 * time.Second)
        c2 <- 7
        close(c2)
    }()
    var ok1, ok2 bool
    for {
        select {
        case x := <-c1:
            ok1 = true
            fmt.Println(x)

        case x := <-c2:
            ok2 = true
            fmt.Println(x)
        }
        if ok1 && ok2 {
            break
        }
    }
}
```
输出：我们可以看到输出了很多我们不期望的 0 ，就是因为 c1 在被关闭后，不在阻塞并能够获取到int的零值
```bash
5
0
0
0
。。。。
0
0
0
7
end
```


## time

### time.Timer


Timer是一个定时器。代表未来的一个单一事件，你可以告诉timer你要等待多长时间。

```go
type Timer struct {
    C <-chan Time
    r runtimeTimer
}
```
它提供一个channel，在定时时间到达之前，没有数据写入 timer.C 会一直阻塞。直到定时时间到，定时器就会向自己的C字节发送一个time.Time类型的元素值，阻塞解除，可以从中读取数据。

```go
func TestTimer2(t *testing.T) {
    //创建定时器，5秒后，定时器就会向自己的C字节发送一个time.Time类型的元素值
    timer1 := time.NewTimer(time.Second * 5)
    t1 := time.Now() //当前时间
    fmt.Printf("t1: %v\n", t1)

    t2 := <-timer1.C //在这里被阻塞，直到定时时间到
    fmt.Printf("t2: %v\n", t2)
}
```
输出：注意两个时间相差两秒
```
t1: 2024-03-27 20:04:32.9717091 +0800 CST m=+0.002626401
t2: 2024-03-27 20:04:34.978423 +0800 CST m=+2.009340301
```


使用 NewTimer、 sleep 、 After  进行等待
```go
func TestTimer2(t *testing.T) {
    //如果只是想单纯的等待的话，可以使用 time.Sleep 来实现
    timer2 := time.NewTimer(time.Second * 2)
    <-timer2.C
    fmt.Println("2s后:", time.Now())

    time.Sleep(time.Second * 2)
    fmt.Println("再一次2s后:", time.Now())

    <-time.After(time.Second * 2)
    fmt.Println("再再一次2s后:", time.Now())
}
```


停止定时器
```go
func TestTimer3(t *testing.T) {
    timer3 := time.NewTimer(time.Second)
    go func() {
        <-timer3.C
        fmt.Println("Timer 3 expired")
    }()

    stop := timer3.Stop() //停止定时器
    if stop {
        fmt.Println("Timer 3 stopped")
    }
}
```

输出：定时器停止后，后续代码不在运行
```bash
Timer 3 stopped
```

重置定时器
```go
func TestTime5(t *testing.T) {
    timer4 := time.NewTimer(time.Second * 5) // 5s等待
    timer4.Reset(time.Second * 3)            // 3s等待
    fmt.Println(time.Now())
    <-timer4.C
    fmt.Println(time.Now())
}
```
输出：中间相差3秒
```bash
2024-03-27 20:12:41.7107254 +0800 CST m=+0.002595401
2024-03-27 20:12:44.7229744 +0800 CST m=+3.014844401
```

#### 定时器常用操作

1. 实现延迟功能
    1. After
    
        ```go
        <-time.After(2 * time.Second)
        ``` 
    1. `Sleep` 
        ```
        time.Sleep(2 * time.Second)
        ```
    1. `NewTimer`
        ```go
        timer := time.NewTimer(2 * time.Second)
        <- timer.C
        ```
1. 定时器停止
    ```go
    timer := time.NewTimer(3 * time.Second)
    go func() {
        <-timer.C
        fmt.Println("子协程可以打印了，因为定时器的时间到")
    }()
    timer.Stop() //停止定时器

    for {
    }
    ```
1. 定时器重置
    ```go
    ok := timer1.Reset(1 * time.Second) //重新设置为1s
    ```

### time.Ticker

Ticker是一个周期触发定时的计时器，它会按照一个时间间隔往channel发送系统当前时间，而channel的接收者可以以固定的时间间隔从channel中读取事件

```go
type Ticker struct {
    C <-chan Time 	// The channel on which the ticks are delivered.
    r runtimeTimer
}
```

使用示例
```go
func TestTicket(t *testing.T) {
    //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)
    ticker := time.NewTicker(time.Second * 1)

    i := 0
    go func() {
        for { //循环
            <-ticker.C
            i++
            fmt.Println("i = ", i)

            if i == 5 {
                ticker.Stop() //停止定时器
            }
        }
    }() //别忘了()

    //死循环，特地不让main goroutine结束
    for {
    }
}
```

## select

Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。

select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。

与switch语句相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作，大致的结构如下：

```go
select {
case <-chan1:
    // 如果chan1成功读到数据，则进行该case处理语句
case chan2 <- 1:
    // 如果成功向chan2写入数据，则进行该case处理语句
default:
    // 如果上面都没有成功，则进入default处理流程()
    // 如果没有 default 语句 select 将被阻塞，直到有一个通信可以执行下去
}
```


示例：
```go
func fibonacci(c, quit chan int) {
    x, y := 1, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func TestSelect(t *testing.T) {
    c := make(chan int)
    quit := make(chan int)

    go func() {
        for i := 0; i < 6; i++ {
            fmt.Println(<-c)
        }
        quit <- 0
    }()

    fibonacci(c, quit)
}
```
输出
```bash
1
1
2
3
5
8
quit
```

### 使用select 解决超时
有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：
```go
func main() {
    c := make(chan int)
    o := make(chan bool)
    go func() {
        for {
            select {
            case v := <-c:
                fmt.Println(v)
            case <-time.After(5 * time.Second):
                fmt.Println("timeout")
                o <- true
                break
            }
        }
    }()
    //c <- 666 // 注释掉，引发 timeout
    <-o
}
```
### 使用select 实现心跳机制

```go
func Test13(t *testing.T) {
    heartbeat := time.NewTicker(1 * time.Second)
    defer heartbeat.Stop()
    for {
        select {
        case t := <-heartbeat.C: //心跳逻辑
            fmt.Println(t)

        }
    }
}
```
输出
```bash
2024-03-28 19:59:43.385703 +0800 CST m=+1.004713301
2024-03-28 19:59:44.3941031 +0800 CST m=+2.013113401
2024-03-28 19:59:45.3871755 +0800 CST m=+3.006185801
2024-03-28 19:59:46.3950864 +0800 CST m=+4.014096701
.
.
.;/
```

## sync包
标准库 sync 包提供了针对传统**基于共享内存模型**的基本同步原语，包括  互斥锁(sync.Mutex) 、 读写锁(sync.RWMutex) 、 条件变量(sync.Cond) 等



### sync.Mutex

当需要高性能的临界区同步场景时， Mutex 要比 channel 的性能要高很多


**示例：**
使用 Mutex 
```go
var cs = 0
var m2 sync.Mutex

func byMutex() {
    m2.Lock()
    defer m2.Unlock()
    cs++
}

func Test16(b *testing.T) {
    for n := 0; n < 100000000; n++ {
        byMutex()
    }
}
```
结果
```bash
=== RUN   Test16
--- PASS: Test16 (0.40s)
PASS
```

使用 channel
```go
var cs = 0
var c = make(chan struct{}, 1)

func Test17(b *testing.T) {
    for n := 0; n < 100000000; n++ {
        byChan()
    }
}
```
结果
```bash
=== RUN   Test17
--- PASS: Test17 (1.89s)
PASS
```

注意事项：**避免使用复制后的 Mutex ，因为这会复制 Mutex 的当前状态**

```go
type foo struct {
    n int
    sync.Mutex
}

func Test19(t *testing.T) {
    f := foo{n: 17}
    go func(f foo) {
        for {
            log.Printf("g2: try to lock foo...")
            f.Lock()
            log.Println("g2: lock foo ok")
            time.Sleep(3 * time.Second)
            f.Unlock()
            log.Println("g2: unlock foo ok")
        }
    }(f) //使用 f 的副本执行 g2

    f.Lock()
    log.Println("g1:lock foo ok")

    go func(f foo) {
        log.Printf("g3: try to lock foo...") //g3 会阻塞在这里，这是因为 f 在传入的时候已经是加锁状态，并且由于传入的是副本，所以 g 的解锁不会影响 g3
        f.Lock()
        log.Println("g3: lock foo ok")
        time.Sleep(3 * time.Second)
        f.Unlock()
        log.Println("g3: unlock foo ok")
    }(f) //使用 f 的副本执行 g3

    //time.Sleep(1000 * time.Second)
    f.Unlock()
    log.Println("g1: unlock foo ok")
    time.Sleep(1000 * time.Second)

}
```

go 标准库 Mutex 定义
```go
//$GOROOT/src/sync/mutex.go
type Mutex struct{
    state int32
    sema  uint32
}
```

- state : 表示当前互斥锁的状态
- sema  : 表示控制锁状态的信号量

对 Mutex 的复制会复制这两个整型字段，所以推荐使用 **闭包** 或者 **传递地址或指针** 的方式。

### sync.RWMutex

RWMutex 是 Go 语言中提供的一个读写互斥锁，全称是 "Reader-Writer Mutex"，即读写互斥锁。它允许多个读操作同时进行，但写操作是互斥的，也就是说在任意时刻只能有一个写操作，且写操作会阻塞其他读写操作。

读：加锁、解锁
- RLock：用于获取读锁。当多个 goroutine 尝试获取读锁时，它们可以同时获得，从而允许多个读操作并发进行。
- RUnlock：用于释放读锁。每个调用 RLock 的 goroutine 都应该在其完成读操作后调用 RUnlock。


写锁同 Mutex 相同


### sync.Cond

sync.Cond 是 Go 语言标准库 sync 包中提供的一个基于互斥锁或读写锁实现的条件变量类型，主要用于协调多个 goroutine 访问共享资源时的同步问题。当共享资源的状态发生变化时，sync.Cond 可以用来通知等待条件变化而阻塞的 goroutine。


- NewCond(l Locker): 创建 Cond 对象，需要传入一个锁对象（互斥锁或读写锁）。

- Wait(): 阻塞当前 goroutine，等待通知信号。调用 Wait 方法时会自动释放锁，并在等待期间保持释放状态，直到被唤醒或信号到来。一旦 goroutine 被唤醒或接收到信号，Wait 方法会重新获取锁并返回。

- Signal(): 发送信号通知，唤醒一个等待的 goroutine。如果有多个 goroutine 在等待，Signal 只会唤醒其中一个。

- Broadcast(): 发送信号通知，唤醒所有等待的 goroutine。

sync.Cond 需要与一个互斥锁或读写锁一起使用，以确保不会同时操作共享资源。这种机制使得多个 goroutine 能够在特定条件下协调执行，例如等待某个条件成立后再继续执行。


### sync.WaitGroup
用于等待 goroutine 执行完成，类似于 java 的 Countdownlatch

- Add(delta int): 这个方法用于增加或减少等待goroutine的数量。参数delta可以是正数或负数。当delta为正数时，表示增加计数器的值，通常用于在启动新的goroutine之前增加计数；当delta为负数时，表示减少计数器的值，通常用于在goroutine完成其任务后调用，表示该goroutine已经完成。

- Done(): 这个方法用于标记goroutine已执行完成，它实际上是Add(-1)的简化调用。在每个goroutine完成任务后，应该调用Done()方法来减少计数器的值。

- Wait(): 这个方法会阻塞调用它的goroutine，直到WaitGroup中计数器的值变为0，即所有goroutine都执行完成。如果在任何goroutine中没有调用Done()方法，Wait()方法会一直阻塞程序。

### sync.Once

sync.Once 是 Go 语言标准库中的一个同步原语，其主要目的是确保某个操作或函数在并发环境下只被执行一次。这对于诸如单例模式、初始化配置或保持数据库连接等场景特别有用，因为它们需要确保某些操作只执行一次，以避免重复创建资源或造成其他不必要的开销。


sync.Once 的主要特性包括：

- 线程安全：在并发环境下，多个协程或线程可以同时调用 sync.Once，但关联的操作或函数只会被执行一次。

- 延迟执行：与 init 函数不同，sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到实际使用时再执行。

-  控制变量初始化：sync.Once 常用于控制变量的初始化。当且仅当第一次访问某个变量时，它才进行初始化（写操作）。在初始化过程中，所有读操作都会被阻塞，直到初始化完成。一旦初始化完成，变量将驻留在内存中，且只初始化一次。


sync.Once 只有一个导出的方法，即 Do。该方法接收一个函数作为参数，并在首次调用时执行该函数。如果多次调用 Do，只有第一次会执行函数，后续调用则不会有任何效果。

基本示例
```go
var (  
    initOnce sync.Once  
    resource string  
    err      error  
)  
  
func initialize() {  
    // 初始化资源的操作  
    resource = "Initialized resource"  
    err = nil  
}  
  
func GetResource() (string, error) {  
    initOnce.Do(initialize) // 仅在第一次调用时执行 initialize 函数  
    return resource, err  
}
```

在这个例子中，getResource 函数使用 sync.Once 来确保 initialize 函数只会在第一次调用 getResource 时执行。这有助于避免重复初始化的开销，提高性能并确保资源的一致性。


### sync.pool

sync.Pool 是一个数据对象缓存池，具有如下特点

- 它是 goroutine 并发安全的
- 放入该缓存池中的数据对象的生命都是暂时的
- 缓存池中的数据对象是被可以重复利用的，这就减轻了GC压力
- sync.Pool 为每个 P(goroutine调度模型中的P) 单独建立了 local 缓存池，进一步降低高并发下锁的竞争


使用
1. 定义 New 函数，用于在池中没有可用对象时创建新的对象。

    使用 sync.Pool 结构体并传入 New 函数作为字段来创建一个新的 sync.Pool 实例。

    在代码中，myType 是你想要池化的类型。New 函数应该返回一个该类型的新实例的指针（或者任何满足 interface{} 类型的值）。我们也可以使用 New 关键字返回指针
    ```go
    var pool = sync.Pool{  
        New: func() interface{} {  
            // 返回一个新的对象实例  
            // 例如，这里返回一个 *myType 的新实例  
            return &myType{}  
        },  
    }
    ```
2. 从池中获取对象
    使用 Get 方法从池中获取一个对象。由于 Get 返回的是 interface{} 类型，因此你可能需要进行类型断言将其转换为你期望的类型。
    ```go
    obj := pool.Get().(*myType)  
    // 使用 obj 进行操作...
    ```
2. 从池中获取对象

    使用 Get 方法从池中获取一个对象。由于 Get 返回的是 interface{} 类型，因此你可能需要进行类型断言将其转换为你期望的类型。
    ```go
    obj := pool.Get().(*myType)  
    // 使用 obj 进行操作...
    ```

3. 使用完对象后放回池中：
    ```go
    pool.Put(obj)
    ```


### sync.map


sync.Map是Go语言中的一个并发安全的映射类型，它可以在多个goroutine之间安全地存储和访问数据。其设计目标是提供高效的并发读写操作，尤其适用于读多写少的场景。

sync.Map的原理是使用两个map（read和dirty）进行读写分离，但两个map共用底层的entry实体。read map仅用于读操作，它好比sync.Map的一个“高速缓存”。当goroutine从sync.Map中读数据时，sync.Map会首先查看read这个缓存层是否有用户需要的数据（key是否命中）。如果key命中，则通过原子操作将数据读取并返回，这是sync.Map推荐的快速路径（fast path），也是sync.Map读性能极高的原因。

而dirty map则用于在特定情况下存储最新写入的key-value数据。当read map中的miss次数（即读取read map获取不到key的次数）到达一定阈值后，dirty map会提升为read map。dirty map被再创建时，会浅拷贝read map。

总的来说，sync.Map通过读写分离和缓存机制，实现了高效的并发读写操作，避免了显式的锁操作，从而提高了并发性能。



使用

- Store：存储一对 key-value 值。

- Load：根据 key 获取对应的 value 值，并且可以判断 key 是否存在。

- LoadOrStore：如果 key 对应的 value 存在，则返回该 value；如果不存在，存储相应的 value。

- Delete：删除一个 key-value 键值对。

- Range：循环迭代 sync.Map，效果与 for range 一样。

```go
package main  
  
import (  
    "fmt"  
    "sync"  
)  
  
func main() {  
    // 创建一个sync.Map  
    var m sync.Map  
  
    // 使用Store方法存储键值对  
    m.Store("one", 1)  
    m.Store("two", 2)  
    m.Store("three", 3)  
  
    // 使用Load方法读取键值对  
    var value interface{}  
    value, ok := m.Load("two")  
    if ok {  
        fmt.Println("Value for 'two':", value)  
    }  
  
    // 使用Range方法遍历sync.Map中的所有键值对  
    m.Range(func(key, value interface{}) bool {  
        fmt.Printf("key: %s, value: %d\n", key, value)  
        // 返回true表示继续迭代，返回false则停止迭代  
        return true  
    })  
  
    // 使用Delete方法删除键值对  
    m.Delete("one")  
  
    // 再次检查'one'键是否存在  
    if _, ok := m.Load("one"); !ok {  
        fmt.Println("'one' has been deleted")  
    }  
}
```



1. sync.Map的键必须是可比较的，也就是说，键的实际类型不能是函数类型、字典类型或切片类型。

1. 在使用Range方法时，由于sync.Map可能在迭代过程中被其他goroutine修改，所以迭代得到的结果可能不是最新的或完整的。如果需要确保得到一致性的结果，你可能需要在迭代过程中加锁或使用其他同步机制。但请注意，这样做可能会降低性能。

1. 由于sync.Map的设计目标主要是提供高效的并发读写操作，所以在某些场景下，其性能可能不如使用传统的互斥锁（mutex）或读写锁（RWMutex）保护的map。因此，在选择使用sync.Map时，需要根据具体的使用场景和性能要求进行评估。


## sync/atomic


atomic 包提供了一组函数，可以对基本数据类型和一些复杂类型进行原子操作

1. 加载（Load）和存储（Store）
    
    从内存中原子地加载一个值。
    ```go
    LoadInt32、LoadInt64、LoadUint32、LoadUint64、LoadUintptr、LoadPointer：
    ```

    原子地将一个值存储到内存中。
    ```go
    StoreInt32、StoreInt64、StoreUint32、StoreUint64、StoreUintptr、StorePointer：
     ```


1. 比较并交换（CompareAndSwap, CAS）

    `CompareAndSwapInt32、CompareAndSwapInt64` 等：
    
    原子地比较目标变量的当前值是否等于给定的旧值，如果是，则将目标变量设置为新值。这个函数返回一个布尔值，表示是否成功地将新值存储到目标变量中。

1. 其他操作

    `AddInt64、SubInt64、AddUint32、SubUint32` 等：原子地对整数进行加或减操作。


示例1：对共享整型变量的无锁读写
```go
var nl int64

func atomicAddInt() int64 {
    return atomic.AddInt64(&nl, 1)
}

func atomicLoadInt() int64 {
    return atomic.LoadInt64(&nl)
}
```

示例2：对自定义类型的无锁读写
```go
type Config struct {
    data string
}

func BenchmarkSet(b *testing.B) {
    // 声明一个 atomic.Value 类型的变量 config，用于存储 Config 类型的值  
    var config atomic.Value
    c := Config{data: "hello"}
    b.ReportAllocs()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            // 原子地将 Config 类型的值 c 存储到 config 变量中  
            config.Store(c)
        }
    })

}
```

**适用场景**

atomic 更适合一些对性能十分敏感的操作，适合读多写少的场景。如果需要对一个较大的临界区操作还是首选 sync 包中的原语


## 协程如何退出
在一般的多线程程序中，我们可以设置一个全局变量，来通知各个线程退出与否。在使用该全局变量时，一般使用`锁`对其进行保护，并暴露其在多线程下的可见性(例如 java 的 volitail)。



### 通过select+channel退出协程

```go
func TestChannel2(t *testing.T) {

    var wg sync.WaitGroup
    wg.Add(1)
    stopCh := make(chan bool) //用来停止监控狗
    go func() {
        defer wg.Done()
        watchDog2(stopCh, "【监控狗1】")
    }()

    time.Sleep(5 * time.Second) //先让监控狗监控5秒
    fmt.Println("发出退出指令")
    stopCh <- true //发停止指令

    wg.Wait()
    fmt.Println("主协程退出")

}

func watchDog2(stopCh chan bool, name string) {

    //开启for select循环，一直后台监控
    for {
        select {

        case <-stopCh:
            fmt.Println(name, "停止指令已收到，马上停止")
            return

        default:
            fmt.Println(name, "正在监控……")

        }
        time.Sleep(1 * time.Second)
    }
}
```


## context


通过 `select + channel` 的方式退出协程，比较优雅，但是如果我们希望同时取消多个协程呢？

如果要定时取消协程又该怎么办呢？

在使用 select + channel 的方式，则需要定义多个 channel ，但是这样代码会非常复杂，难以维护。

go 语言提供了 context 可以跟踪到每个协程并控制它们。



### 改写监控狗代码


```go
func TestContext(t *testing.T) {
    var wg sync.WaitGroup

    wg.Add(1)

    ctx, stop := context.WithCancel(context.Background())

    go func() {
        defer wg.Done()
        watchDog(ctx, "【监控狗1】")
    }()

    time.Sleep(5 * time.Second) //先让监控狗监控5秒

    //将上面的向通道写值，改为调用stop 方法
    stop() //发停止指令,

    wg.Wait()

}

func watchDog(ctx context.Context, name string) {

    //开启for select循环，一直后台监控
    for {
        select {

        //将上面的监听通道，改为监听 contex.Done 方法的返回的通道
        case <-ctx.Done():
            fmt.Println(name, "停止指令已收到，马上停止")
            return

        default:
            fmt.Println(name, "正在监控……")

        }
        time.Sleep(1 * time.Second)
    }

}
```

可以看到，这和修改前的整体代码结构一样，只不过从 channel 换成了 Context。以上示例只是 Context 的一种使用场景，它的能力不止于此。



### 什么是 Context

一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程。

如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。

Context 就是用来简化解决这些问题的，并且是并发安全的。Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。

Context 接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。


```go
type Context interface {

    // deadline: 截止时间
    // ok      : 是否设置截止时间
    Deadline() (deadline time.Time, ok bool)

    // 返回一个只读的 channel ，如果该 channel 可以读取，那么可以已退出协程
    Done() <-chan struct{}

    //返回取消的错误原因，即因为什么原因 Context 被取消。
    Err() error

    // Value 方法获取该 Context 上绑定的值，是一个键值对，
    // 所以要通过一个 key 才可以获取对应的值。
    Value(key interface{}) interface{}
}
```

### Context 树

我们不需要自己实现 Context 接口，Go 语言提供了函数可以帮助我们生成不同的 Context，通过这些函数可以生成一颗 Context 树，这样 Context 才可以关联起来，父 Context 发出取消信号的时候，子 Context 也会发出，这样就可以控制不同层级的协程退出。

从使用功能上分，有四种实现好的 Context。

- 空 Context：不可取消，没有截止时间，主要用于 Context 树的根节点。

- 可取消的 Context：用于发出取消信号，当取消的时候，它的子 Context 也会取消。

- 可定时取消的 Context：多了一个定时的功能。

- 值 Context：用于存储一个 key-value 键值对。

从下图 Context 的衍生树可以看到，最顶部的是空 Context，它作为整棵 Context 树的根节点，在 Go 语言中，可以通过 context.Background() 获取一个根节点 Context。



![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240525130929.png)




有了根节点 Context 后，这颗 Context 树要怎么生成呢？需要使用 Go 语言提供的四个函数。

- WithCancel(parent Context)：生成一个可取消的 Context。

- WithDeadline(parent Context, d time.Time)：生成一个可定时取消的 Context，参数 d 为定时取消的具体时间。 设置的是绝对的时间点，如 24年5月30日 01 时，01分，01秒，0001毫秒等

- WithTimeout(parent Context, timeout time.Duration)：生成一个可超时取消的 Context，参数 timeout 用于设置多久后取消，设置的是相对的时间点，如5秒后

- WithValue(parent Context, key, val interface{})：生成一个可携带 key-value 键值对的 Context。

以上四个生成 Context 的函数中，前三个都属于可取消的 Context，它们是一类函数，最后一个是值 Context，用于存储一个 key-value 键值对。

示例：
```go
func TestContexDealLine2(t *testing.T) {
    var wg sync.WaitGroup
    // 可取消的 context
    ctx, _ := context.WithCancel(context.Background())
    // 有截止时间的 context
    ctx, stopFunc2 := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second)) // 延长截止时间以便观察
    // 可设置值的 context
    ctx = context.WithValue(ctx, "1", 2)

    for i := 0; i < 4; i++ {
        wg.Add(1)
        go func(n int) {
            defer wg.Done() // 确保在协程退出时调用Done
            for {
                select {
                case <-ctx.Done():
                    fmt.Println(n, ":协程退出")
                    return
                default:
                    fmt.Println(n, "work", ctx.Value("1"))
                    time.Sleep(time.Millisecond * 100) // 添加延时以便观察协程的工作
                }
            }
        }(i) // 传递i作为参数给协程，如果直接使用的话，会作为闭包传入，最终值，在这里就是 4
    }
    time.Sleep(time.Second * 1)
    fmt.Println("发出退出命令")
    stopFunc2()

    wg.Wait()
}
```


### context 
Context 是一种非常好的工具，使用它可以很方便地控制取消多个协程。在 Go 语言标准库中也使用了它们，比如 net/http 中使用 Context 取消网络的请求。

要更好地使用 Context，有一些使用原则需要尽可能地遵守。

- Context 不要放在结构体中，要以参数的方式传递。

- Context 作为函数的参数时，要放在第一位，也就是第一个参数。

- 要使用 context.Background 函数生成根节点的 Context，也就是最顶层的 Context。

- Context 传值要传递必须的值，而且要尽可能地少，不要什么都传。

- Context 多协程安全，可以在多个协程中放心使用。


## go语言并发模式




### for select 模式
for select 循环模式非常常见，在前面的课程中也使用过，它一般和 channel 组合完成任务，代码格式如下：

```go
for { //for无限循环，或者for range循环

  select {

    //通过一个channel控制
    case <- channel:
        return
    default:
        //执行具体的任务

  }

}
```
这是一种 for 循环 +select 多路复用的并发模式，哪个 case 满足就执行哪个，直到满足一定的条件退出 for 循环（比如发送退出信号）。

在这上面有一个变种，即 使用一个 channel 作为指示退出的标识，使用其它 channel 作为接收/发送，一般配置 for range 使用


```go
for _,s:=range []int{}{

   select {

    //用于退出for 循环
    case <-done:
      return

    //用于发送/接收值
    case resultCh <- s:
   }
}
```

### select timeout 模式

假如需要访问服务器获取数据，因为网络的不同响应时间不一样，为保证程序的质量，不可能一直等待网络返回，所以需要设置一个超时时间，这时候就可以使用 select timeout 模式，如下所示：

```go
func main() {

   result := make(chan string)

   go func() {
      //模拟网络访问
      time.Sleep(8 * time.Second)
      result <- "服务端结果"

   }()

   select {

   case v := <-result:
      fmt.Println(v)

   case <-time.After(5 * time.Second)://通过 time.After 防止 select 无限等待

      fmt.Println("网络访问超时了")
   }
}
```

select timeout 模式的核心在于通过 time.After 函数设置一个超时时间，防止因为异常造成 select 语句的无限等待。

> 小提示：如果可以使用 Context 的 WithTimeout 函数超时取消，要优先使用。

### Pipeline 模式/流水线模式

Pipeline 模式也称为流水线模式，模拟的就是现实世界中的流水线生产。以手机组装为例，整条生产流水线可能有成百上千道工序，每道工序只负责自己的事情，最终经过一道道工序组装，就完成了一部手机的生产。

从技术上看，每一道工序的输出，就是下一道工序的输入，在工序之间传递的东西就是数据，这种模式称为流水线模式，而传递的数据称为数据流。


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240527193845.png)
通过以上流水线模式示意图，可以看到从最开始的生产，经过工序 1、2、3、4 到最终成品，这就是一条比较形象的流水线，也就是 Pipeline。

现在我以组装手机为例，讲解流水线模式的使用。假设一条组装手机的流水线有 3 道工序，分别是配件采购、配件组装、打包成品，如图所示：


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240527193901.png)


从以上示意图中可以看到，采购的配件通过 channel 传递给工序 2 进行组装，然后再通过 channel 传递给工序 3 打包成品。相对工序 2 来说，工序 1 是生产者，工序 3 是消费者。相对工序 1 来说，工序 2 是消费者。相对工序 3 来说，工序 2 是生产者。

我用下面的几组代码进行演示：

**工序1采购**
```go
func buy(n int) <-chan string {

   out := make(chan string)//定义一个输出 channel

   go func() {

      defer close(out)
      for i := 1; i <= n; i++ {
         out <- fmt.Sprint("配件", i)
      }
   }()
   return out
}
```
**工序2组装**
```go
func build(in <-chan string) <-chan string {
   out := make(chan string)
   go func() {
      defer close(out)
      for c := range in {
         out <- "组装(" + c + ")"
      }
   }()
   return out
}
```
工序3打包
```go
func pack(in <-chan string) <-chan string {
   out := make(chan string)
   go func() {
      defer close(out)
      for c := range in {
         out <- "打包(" + c + ")"
      }
   }()
   return out
}
```

```go
func main() {

   coms := buy(10)    //采购10套配件
   phones := build(coms) //组装10部手机
   packs := pack(phones) //打包它们以便售卖

   //输出测试，看看效果
   for p := range packs {
      fmt.Println(p)
   }
}
```

从上述例子中，我们可以总结出一个流水线模式的构成：

流水线由一道道工序构成，每道工序通过 channel 把数据传递到下一个工序；

每道工序一般会对应一个函数，函数里有协程和 channel，协程一般用于处理数据并把它放入 channel 中，整个函数会返回这个 channel 以供下一道工序使用；

最终要有一个组织者（示例中的 main 函数）把这些工序串起来，这样就形成了一个完整的流水线，对于数据来说就是数据流。


### 扇出和扇入模式

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240528192711.png)



```go

//扇入函数（组件），把多个chanel中的数据发送到一个channel中
func merge(ins ...<-chan string) <-chan string {

    var wg sync.WaitGroup
    out := make(chan string)

    //把一个channel中的数据发送到out中
    p := func(in <-chan string) {
        defer wg.Done()
        for c := range in {
            out <- c
        }
    }

    wg.Add(len(ins))

    //扇入，需要启动多个goroutine用于处于多个channel中的数据
    for _, cs := range ins {
        go p(cs)
    }

    //等待所有输入的数据ins处理完，再关闭输出out
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}

func TestPippeline2(t *testing.T) {

    //1.配件 i
    coms := buy(100) //采购100套配件

    //2.组装
    //三班人同时组装100部手机
    phones1 := build(coms) 
    phones2 := build(coms)
    phones3 := build(coms)

    //3.汇聚三个channel成一个
    phones := merge(phones1, phones2, phones3)

    //4.打包
    packs := pack(phones) //打包它们以便售卖

    //输出测试，看看效果
    for p := range packs {
        fmt.Println(p)
    }
}
```


### Futures 模式


Futures 模式可以理解为未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取，如果子协程还没有返回结果，就一直等待。我用下面的代码进行演示：

```go
//洗菜

func washVegetables() <-chan string {
   vegetables := make(chan string)
   go func() {
      time.Sleep(5 * time.Second)
      vegetables <- "洗好的菜"
   }()
   return vegetables
}

//烧水

func boilWater() <-chan string {
   water := make(chan string)
   go func() {
      time.Sleep(5 * time.Second)
      water <- "烧开的水"
   }()
   return water
}
```

```go
func main() {
   vegetablesCh := washVegetables() //洗菜
   waterCh := boilWater()           //烧水
   fmt.Println("已经安排洗菜和烧水了，我先眯一会")
   time.Sleep(2 * time.Second)



   fmt.Println("要做火锅了，看看菜和水好了吗")
   vegetables := <-vegetablesCh
   water := <-waterCh
   fmt.Println("准备好了，可以做火锅了:",vegetables,water)
}
```



# go错误处理策略

go 语言中没有提供 try catch 的异常处理机制，而是和 c 语言一样，认为 **错误就是值** ，同时结合多返回值策略，避免了单返回值承载信息过多的情况

error接口

```go
//$GOROOT/src/builtin/builtin.go
type interface error {
    Error() string
}
```

## 构造错误值

**使用 `errors.New(string)`**
```go
err := errors.New("first error")
```

**使用 `fmt.Errorf(string)`**

```go
fmt.Errorf("wrap err:%d", 1)
fmt.Errorf("wrap err:%w", e1)
```

当我们使用 `%w`  时 `fmt.Errorf` 返回的错误类型为 `fmt.warpError`
```go
type warpError {
    msg string
    err Error
}

func (e *warpError) Error() string {
    return e.msg
}

func (e *warpError) Unwarp() Error {
    return e.err
}
```

`warpError` 类型的包装的错误，可以被**包装错误链**检查到

```go
e1 := errors.New("123")

e2 := fmt.Errorf("wrap err:%w", e1)

is := errors.Is(e2, e1) //e2 是否等于e1 或者 e2 包裹了 e1 返回 true
fmt.Print(is)
```



## 透明错误处理策略

```go
err := dosomething()
if err != nil{
    //不关心错误如何，执行简单的逻辑并返回错误
    ...
    return
}
```

这是最常见的错误处理策略

## 哨兵错误处理策略

我们可以判断 `Error()` 方法返回的错误字符串来进行处理，但是这种方式容易造成**隐式的耦合**，所以可以采用导出错误值的方式做出错误的分支处理

```go
// $GOROOT/src/bufio/bufio.go
var(
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    .
    .
    .
)

// 错误处理代码
data, err := b.Peek()

if err != nil {
    switch err
    case bufio.ErrInvalidUnreadByte:
        ....
        return 

    case ...:
        ....
        return 
    。
    。
    。
}
```
注意导出的错误一般以 `Errxxx` 方式命名



## 错误值类型检视策略

Go 提供了 `类型断言机制(type assertion)` 或 `类型选择机制(type switch)`


类型断言
```go
// 比较指针
val ,ok := err.(* xxxErr)
// 比较值
val ,ok := err.(xxxErr)
```

类型选择机制
```go
type MyError struct {
    msg string
}

func (e MyError) Error() string {
    return e.msg
}

func TestTypeSwitch(t *testing.T) {
    var err error
    err = MyError{msg: "13"}

    switch err.(type) {
    case MyError:
        println("MyError")
        break
    }
}
```

一般自定义导出的错误以 XxxxError 的形式命名

使用 `error.As` 方法检视错误
```go

func TestErrorAs(t *testing.T) {
    //对 err 进行包装
    err := &MyError{msg: "13"}
    err1 := fmt.Errorf("wrap err1: %w", err)
    err2 := fmt.Errorf("wrap err2: %w", err1)

    //声明一个 指针
    var e *MyError

    // 如果err2 的类型属于 e 的错误链上，则为 e 赋值，并返回 true
    if errors.As(err2, &e) {
        println("MyError is on the chain of err2")
        println(e == err)
    }
    println(e == nil)
}
```

## 减少重复出现的 if err != nil

1. 设计一个处理错误的函数，在将接收的错误在函数中处理

    原函数
    ```go
    func parse(r io.Reader) (*Point, error) {

        var p Point

        if err := binary.Read(r, binary.BigEndian, &p.Longitude); err != nil {
            return nil, err
        }
        if err := binary.Read(r, binary.BigEndian, &p.Latitude); err != nil {
            return nil, err
        }
        if err := binary.Read(r, binary.BigEndian, &p.Distance); err != nil {
            return nil, err
        }
        if err := binary.Read(r, binary.BigEndian, &p.ElevationGain); err != nil {
            return nil, err
        }
        if err := binary.Read(r, binary.BigEndian, &p.ElevationLoss); err != nil {
            return nil, err
        }
    }
    ```
    修改后
    ```go
    func parse(r io.Reader) (*Point, error) {
        var p Point
        var err error
        //设计一个处理错误的函数
        read := func(data interface{}) {
            if err != nil {
                return
            }
            err = binary.Read(r, binary.BigEndian, data)
        }

        read(&p.Longitude)  //调用处理错误的函数
        read(&p.Latitude)
        read(&p.Distance)
        read(&p.ElevationGain)
        read(&p.ElevationLoss)

        if err != nil {     //最后处理错误
            return &p, err
        }
        return &p, nil
    }
    ```
1. 内置 error ，将 err 放在返回值中，对返回值统一判断即可
    ```go
    scanner := bufio.NewScanner(input)

    for scanner.Scan() {
        token := scanner.Text()
        // process token
    }

    if err := scanner.Err(); err != nil {
        // process the error
    }
    ```


上面这几种方式都只适用于统一的处理方式，对于多种类型的错误，还是需要进行 if 判断

1. 使用 defer + recover  进行错误处理，但是需要注意的是这种方式，性能非常差大约较正常代码下降 90%
    ```go
    func check(err error) {
        if err != nil
            panic(err)
    }

    func main(){
        //.... 
        defer func(){
            //使用 recover 捕获异常
            if e:= recover(); e != nil {
                // 异常处理代码 。。。。。
            }
        }

        //处理函数
        err := handler()
        check(err)
    }
    ```

# Go Socket

## 网络 I/O 模型

### 阻塞 I/O 模型

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406051035653.png)

1. 用户空间应用线程，向操作系统内核，发起IO请求（操作系统提供的IO调用）
2. 内核尝试IO操作，等待数据就绪后，复制到用户空间，最后系统调用从用户空间返回，注意在内核操作时，用户线程处于阻塞状态
3. 用户处理用户空间的数据

在此种模式中，一个线程只能处理一个网络连接的数据，如果没有数据将被阻塞


### 非阻塞 I/O 模型

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406051045368.png)

与阻塞IO不同的时，在用户发起系统调用后，失败会立即返回错误值，随后用户可通过轮询获状态，当存在数据时，短暂阻塞用户线程后返回。

### I/O 多路复用模型
I/O 多路复用模型是建立在操作系统提供的 select 、poll 、 epoll 等多路复用函数上的。

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406051103237.png)


阻塞模型一个线程只能处理一个 socket ，而在 I/O 多路复用模型中，一个线程可以处理多个 socket 。并且 I/O 多路复用模型 由内核实现了 可读可写事件的通知，避免了非阻塞模型中轮询带来的资源浪费。


### 异步 I/O 模型



![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406051121316.png)

1. 用户线程发起异步调用后，内核将启动等待数据的操作后立即返回
2. 内核会主动生成信号，以驱动用户线程在异步I/O调用时，注册的信号处理函数，或者主动执行用户线程注册的回调函数，让用户线程完成对数据的操作。

相较于其他模型，异步IO模型 ,在各个平台上的支持程度不同。且使用起来较为复杂，在内存管理、信号处理、回调函数等逻辑设计上会给开发人员带来心智负担。

### GO 中的模型

Go 语言的设计者认为 **IO多路复用这种通过回调割裂控制流的模型**依旧复杂，且有悖于一般顺序的程序逻辑，所以他们将 复杂性隐藏在了 go 运行时当中。 在 GO 开发中只需要使用 **阻塞I/O** 模型即可完成 Socket 操作。

典型的GO服务端程序

```go
func handleConn(c net.Conn) {
    for {
        //从连接上读取数据
        //从连接上写入数据
    }
}

func TestServer(t *testing.T) {

    l, err := net.Listen("tcp", ":8888")

    if err != nil {
        println("监听异常", err)
        return
    }

    for {
        c, err := l.Accept()
        if err != nil {
            println("accept error", err)	
        }
        go handleConn(c)
    }
}
```
该程序与阻塞IO模型一致
1. 监听端口
2. 建立连接
3. 创建 线程/协程 处理收发数据


在 Go 的用户层，看起来是使用了 阻塞IO模型 ， 但是实际上使用 go 的运行时中的 **netpoller(网络轮训器)** 模拟出来的。而 netpoller 则使用了 **IO多路复用机制**

```go
// $GOROOT/src/net/socket_cloexec。ho
func sysSocket(family, sotype, proto int) (int, error) {

    .....
    if err = syscall.SetNonblock(s, true); err != nil {
        poll.CloseFunc(s)
        return -1, os.NewSyscallError("setnonblock", err)
    }
    return s, nil
}
```
在运行时拦截了针对底层 socket 的系统调用返回的错误码，并通过 netpoller 和 goroutin 调度让 goroutine 阻塞在用户所看到的的 socket 描述符上。

## gotcp 示例


服务器客户端示例
```go
package go_demo

import (
    "bufio"
    "net"
    "strconv"
    "testing"
    "time"
)

func handleConn(c net.Conn) {
    println("收到连接：", c.RemoteAddr().Network())
    for {
        //从连接上读取数据

        reader := bufio.NewReader(c)

        readString, err := reader.ReadString('\n')
        if err != nil {
            println("接收异常：", err)
            return
        }
        println(readString)

        //从连接上写入数据
        bytes := []byte(readString)
        c.Write(bytes)

    }
}

func TestServer(t *testing.T) {

    l, err := net.Listen("tcp", ":10003")

    if err != nil {
        println("监听异常", err)
        return
    }

    for {
        c, err := l.Accept()
        if err != nil {
            println("accept error", err)
        }
        go handleConn(c)
    }
}

func TestClient(t *testing.T) {
    dial, err := net.Dial("tcp", "127.0.0.1:10003")
    if err != nil {
        println("连接错误：", err)
        return
    }
    go func() {
        for i := 0; i < 10; i++ {
            str := "msg: " + strconv.Itoa(i) + "\n"
            bytes := []byte(str)
            dial.Write(bytes)
            time.Sleep(5)
        }
    }()
    for {
        reader := bufio.NewReader(dial)

        readString, err := reader.ReadString('\n')
        if err != nil {
            println("接收异常：", err)
            return
        }
        println(readString)
        println("client receive msg:", readString)

    }
}
```

我们可以使用 bufio包 来帮助我们实现一些操作，例如断包、粘包等问题



# net/http - todo

# time包

## 获取当前时间
```go
now := time.Now()  
fmt.Println(now)
```
输出
```
2024-06-05 16:03:00.5203983 +0800 CST m=+0.006861001
```

## 解析时间字符串

```go
// 使用 Go 的时间布局常量来解析时间字符串  
// 2006-01-02 15:04:05 MST  
t, err := time.Parse("2006-01-02 15:04:05", "2023-09-17 10:30:00")  
if err != nil {  
    fmt.Println("Error parsing time:", err)  
    return  
}  
fmt.Println(t)  
```
## 格式化时间
```go
package main  
  
import (  
    "fmt"  
    "time"  
)  
  
func main() {  
    now := time.Now()  
    fmt.Println(now.Format("2006-01-02 15:04:05"))  
}
```

## 时间计算
```go
package main  
  
import (  
    "fmt"  
    "time"  
)  
  
func main() {  
    now := time.Now()  
    // 加一天  
    oneDayLater := now.AddDate(0, 0, 1)  
    fmt.Println(oneDayLater)  
  
    // 减一小时  
    oneHourAgo := now.Add(-1 * time.Hour)  
    fmt.Println(oneHourAgo)  
}
```
## 时间比较
```go
package main  
  
import (  
    "fmt"  
    "time"  
)  
  
func main() {  
    now := time.Now()  
    then := now.Add(-1 * time.Hour)  
  
    if now.After(then) {  
        fmt.Println("Now is after then")  
    }  
  
    if now.Before(then) {  
        fmt.Println("Now is before then") // 这行不会被执行  
    }  
  
    if now.Equal(then) {  
        fmt.Println("Now is equal to then") // 这行也不会被执行  
    }  
}
```
## 定时器
```go
package main  
  
import (  
    "fmt"  
    "time"  
)  
  
func main() {  
    timer := time.NewTimer(2 * time.Second) // 创建一个定时器，2秒后触发  
  
    <-timer.C // 从通道接收值，等待定时器触发  
    fmt.Println("Timer fired!")  
}
```
# 对系统信号的处理
系统信号(signal) 是一种软件中断，它提供了一种异步的事件处理机制，用于操作系统内核或其他应用程序，通知某一进程发生了某种事件。


我们可以使用 kill -l 命令查看当前系统对信号的支持情况


## 软件对系统信号的处理方式

1. 执行系统默认动作

    对于中断触发的 SIGINT 信号，系统的默认动作是终止该进程

1. 忽略信号
   
2. 捕捉信号，并执行自定义操作
   
## Go 运行时对信号的处理情况


![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406051704007.png)

1. 同步信号
   
   同步信号是指那些由程序执行错误引发的信号，包括 **SIGBUS(总线错误/硬件异常)** 、 **SIGFPE(算术异常)** 、**SIGSEGV(段错误/无效引用)** . 一旦应用进程中的Go运行时，收到这三个信号中的一个，意味着可能出现了严重的bug，无法继续执行，这时一般会抛出一个运行时的 panic ，如果用户层面没有专门的 panic 恢复代码，那么Go程序将会异常退出。






2. 异步信号

    同步信号之外的都划归为异步信号。异步信号不是由程序执行错误引起的，而是由其他进程，或操作系统发出的。异步信号默认处理行为因信号而异。

    **SIGHUP 、 SIGINT 、 SIGTERM** 这三个信号将直接导致程序退出。

    **SIGQUIT 、SIGILL 、 SIGTRAP 、 SIGABRT 、 SIGSTKFLT 、 SIGEMT 、 SIGSYS** 在导致程序退出的同时，会将栈状态打印出来

    SIGPROF 信号 则是被 GO 运行时 实现运行时 CPU 性能剖析指标采集。 

    对于用户层通过 Notify 函数捕获的信号 ，Go 运行时则通过 channel 将信号发送给信号



## 使用系统信号实现程序的优雅退出

```go
func Test18(t *testing.T) {
    // 创建一个新的通道来接收信号通知
    sigChan := make(chan os.Signal, 1)

    // 通知 sigChan 接收特定的信号
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    // 模拟一个长时间运行的任务
    go func() {
        for {
            fmt.Println("Running...")
            time.Sleep(1 * time.Second)
        }
    }()

    // 阻塞等待信号
    sig := <-sigChan
    fmt.Printf("Received signal: %s, exiting...\n", sig)

    // 清理工作（如果有的话）...

    // 退出程序
    os.Exit(0)
}
```
# reflect包

Go 在标准库中提供的 reflect 包 让Go程序具备运行时的反射能力。

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202406061725440.png)

**反射世界的入口**

对象经由接口( `interface{}` ),进入反射世界，并获得对应的反射对象 `reflect.Type` 或者 `reflect.Value`

**反射世界的出口**

反射对象(`reflect.Value`) 通过转换为一个接口 `interface{}` 类型变量的形式，走出反射世界


**修改反射对象的前提：reflect.Value 必须是可设置的**

## 进入反射世界


`reflect.TypeOf` 和 `reflect.VauleOf` 方法能够将类型和值转变为 `reflect.Type` 和 `reflect.Vaue` 类型，在 `go` 语言中，所有的反射操作都是通过这两个类型实现的。


- `reflect.Type`  包含了被反射实例的所有类型信息。
- `reflect.Value` 包含了被反射实例的所有值信息。
  
### reflect.Type

reflect.Type 接口在 Go 语言的 reflect 包中定义了许多方法，用于在运行时查询和操作类型的元数据。以下是 reflect.Type 接口中定义的一些主要方法：


- **Name() string**
    返回类型的名称。对于预定义类型和未命名类型（如基本类型），返回空字符串。


- **PkgPath() string**
    返回类型所在包的导入路径。对于预定义的类型和内置类型，返回空字符串。

- **String() string**
    返回类型的字符串表示，通常是该类型在 Go 语言中的语法表示。

- **Kind() reflect.Kind**
    返回类型的基本种类（如 reflect.Int、reflect.Slice、reflect.Struct 等）。

- **Implements(u reflect.Type) bool**
    判断该类型是否实现了接口 u。

-  **ConvertibleTo(t reflect.Type) bool**
    判断该类型是否可以转换为类型 t。

- AssignableTo(t reflect.Type) bool
    判断该类型是否可赋值给类型 t（例如，如果类型 t 是接口类型，且当前类型是 t 的实现）。

- Comparable() bool
    判断该类型的值是否可以进行比较（如 int、string、数组等，但切片、映射和函数类型则不可比较）。

- Method(int) reflect.Method
    根据索引返回类型的方法（如果类型是一个接口类型或包含至少一个方法的类型）。

- NumMethod() int
    返回类型的方法数（如果类型是一个接口类型或包含至少一个方法的类型）。

- **MethodByName(string) (reflect.Method, bool)**
    根据方法名返回类型的方法，并返回一个布尔值表示是否找到该方法。

- **Field(int) reflect.StructField**
    根据索引返回类型的字段（如果类型是一个结构体类型）。

- **NumField() int**
    返回类型的字段数（如果类型是一个结构体类型）。

- FieldByName(string) (reflect.StructField, bool)
    根据字段名返回类型的字段，并返回一个布尔值表示是否找到该字段。

- FieldByIndex(index []int) reflect.StructField
    根据字段的索引序列返回嵌套结构体中的字段（如果类型是一个结构体类型）。
    
- FieldByNameFunc(match func(string, reflect.StructField) bool) (reflect.StructField, bool)
    使用匹配函数遍历字段，返回第一个匹配的字段（如果类型是一个结构体类型）。

- **Elem() reflect.Type**
    如果类型是指针、切片、通道、映射或函数类型，返回它指向的元素类型；否则返回自己。

- Key() reflect.Type
    如果类型是映射类型，返回键的类型；否则 panic。


- Len() int
    如果类型是数组、切片或通道类型，返回其长度；否则 panic。

- NumIn() int
    如果类型是函数类型，返回其输入参数的个数；否则 panic。

- In(i int) reflect.Type
    如果类型是函数类型，返回其第 i 个输入参数的类型；否则 panic。

- NumOut() int
    如果类型是函数类型，返回其输出参数的个数；否则 panic。

- Out(i int) reflect.Type
    如果类型是函数类型，返回其第 i 个输出参数的类型；否则 panic。

- Bits() int
    如果类型是整数类型或浮点数类型，返回其大小（以字节为单位）；否则 panic。
    
- Align() int
    返回类型在内存中的对齐要求（以字节为单位）。
  
- Size() uintptr
    返回类型在内存中的大小（以字节为单位）。

- Offset() uintptr
    如果类型是结构体类型的字段，返回其在结构体中的字节偏移量；否则 panic。

- IsVariadic() bool
    如果类型是函数类型且最后一个输入参数是变长参数列表，则返回 true。

**请注意，对于某些方法（如 NumIn、In、NumOut、Out 等），如果类型不是函数类型，调用它们将会导致 panic。因此，在调用这些方法之前，通常应该使用 Kind() 方法来**

### reflect.Value


reflect.Value 是 Go 语言 reflect 包中另一个重要的类型，它代表了一个 Go 值的反射表示。与 reflect.Type 类似，reflect.Value 提供了许多方法来检查和操作这个值。以下是一些 reflect.Value 接口中的主要方法：

- Type() reflect.Type
    返回该值所表示的类型。

- Kind() reflect.Kind
    返回该值所表示的基本种类。

- Interface() (i interface{})
    将 reflect.Value 转换回 interface{} 类型。如果 reflect.Value 无法转换为 interface{}（例如，它是无法取地址的值），则会 panic。

- InterfaceData() [2]uintptr
    返回两个 uintptr，它们一起表示 interface{} 的内部表示。第一个 uintptr 是实际数据的指针，第二个 uintptr 是类型信息的指针（即 reflect.rtype 的地址）。此方法通常不直接使用，除非你对 Go 的内部实现有深入了解。

- Elem() reflect.Value
    如果该值是指针、切片、映射、通道或函数，并且这些类型的值是非空的，则返回它指向的元素的值。否则，返回零值 reflect.Value。

- Field(i int) reflect.Value
    如果该值是一个结构体，则返回其第 i 个字段的值。对于其他类型，该方法会 panic。
- FieldByName(name string) (reflect.Value, bool)
    如果该值是一个结构体，则通过字段名查找并返回该字段的值，以及一个表示是否找到该字段的布尔值。对于其他类型，第一个返回值将是零值 reflect.Value。

- FieldByIndex(index []int) reflect.Value
    如果该值是一个结构体，并且 index 表示一个有效的字段索引序列（可能包括嵌套结构体），则返回相应的字段的值。对于其他类型或无效的索引，该方法会 panic。
- MapIndex(key reflect.Value) reflect.Value
    如果该值是一个映射，并且 key 是可比较的，则返回映射中与 key 关联的值。否则，返回零值 reflect.Value。

- MapKeys() []reflect.Value
    如果该值是一个映射，则返回映射中所有键的切片。对于其他类型，该方法会 panic。

- NumField() int
    如果该值是一个结构体，则返回结构体的字段数。对于其他类型，该方法会 panic。

- NumMethod() int
    如果该值是一个具有方法的方法接收器，则返回其方法数。对于其他类型，返回 0。

- Method(i int) reflect.Value
    如果该值是一个具有方法的方法接收器，则返回其第 i 个方法。对于其他类型或无效的索引，该方法会 panic。

- MethodByName(name string) (reflect.Value, bool)
    如果该值是一个具有方法的方法接收器，则通过方法名查找并返回该方法，以及一个表示是否找到该方法的布尔值。对于其他类型，第一个返回值将是零值 reflect.Value。

- Call(in []reflect.Value) []reflect.Value
    如果该值是一个函数值，则使用提供的输入参数调用该函数，并返回其输出值。对于其他类型，该方法会 panic。

- CallSlice(in []reflect.Value) []reflect.Value
    类似于 Call，但在调用函数之前将输入参数切片复制到新的切片中。这允许在调用期间修改输入参数切片，而不会影响原始的 in 切片。

- Select(sel []reflect.SelectCase) (int, reflect.Value, bool)
    执行一个 select 操作，类似于 select 语句在 Go 语言中的用法。它等待一个或多个通道操作完成，并返回选定的 case 的索引、接收到的值（如果有）以及一个表示操作是否完成的布尔值。

- Send(value reflect.Value) bool
    如果该值是一个通道，则尝试向该通道发送 value。如果发送成功，则返回 true；如果通道已关闭，则返回 false。对于其他类型，该方法会 panic。

- Recv() (reflect.Value, bool)
    如果该值是一个通道，则尝试从该通道接收一个值。返回接收到的值和一个布尔值，表示是否成功从通道接收到值（如果通道已关闭





### 对原生类型的检视

```go
//布尔型:
var b = true
val := reflect.ValueOf(b)
typ := reflect.TypeOf(b)
fmt.Println(typ.Name(), val.Bool()) //bool true

//整型
var i = 23
val = reflect.ValueOf(i)
typ = reflect.TypeOf(i)
fmt.Println(typ.Name(), val.Int()) //int 23

//浮点型
var f = 3.14
val = reflect.ValueOf(f)
typ = reflect.TypeOf(f)
fmt.Println(typ.Name(), val.Float()) //float 3.14

//字符串
var s = "hello"
val = reflect.ValueOf(s)
typ = reflect.TypeOf(s)
fmt.Println(typ.Name(), val.String()) //string hello

//函数<一等公民>
var fn = func(a,b int) int {
    return a+b
}
val = reflect.ValueOf(fn)
typ = reflect.TypeOf(fn)
fmt.Println(typ.Kind(), typ.String()) //func func(int, int) int
```

`reflect.Value` 对于原生的基本类型可以使用 `Bool()` 、`Int()` 、`String()` 来获取值.如原始值与获取值类型不同，则会收到 `panic` ,例如：

```go
var i = 23
val = reflect.ValueOf(i)
typ = reflect.TypeOf(i)
fmt.Println(typ.Name(), val.Bool()) //int 23
```

原始值为 `int` ，获取 `Bool` 出现 `panic`

```bash
panic: reflect: call of reflect.Value.Bool on int Value [recovered]
    panic: reflect: call of reflect.Value.Bool on int Value
```

### 对原生复杂类型和自定义类型的检视


```go
//切片
var s1 = []int{1, 2, 3}
val := reflect.ValueOf(s1)
typ := reflect.TypeOf(s1)
val.Index(0).SetInt(12)                                         //设置下标0 位置的元素为 12
fmt.Printf("[%d,%d]\n", val.Index(0).Int(), val.Index(1).Int()) //[12,2]
fmt.Println(typ.Kind(), typ.String())                           //slice []int

//数组
var arr = [3]int{1, 2, 3}
val = reflect.ValueOf(arr)
typ = reflect.TypeOf(arr)
//val.Index(0).SetInt(12) //由于数组存储在栈上，所以不同通过反射进行修改
//	panic: reflect: reflect.Value.SetInt using unaddressable value [recovered]
//	panic: reflect: reflect.Value.SetInt using unaddressable value
fmt.Printf("[%d,%d]\n", val.Index(0).Int(), val.Index(1).Int()) //[12,2]
fmt.Println(typ.Kind(), typ.String())                           //slice [3]int

//map
var m = map[string]int{
    "tony": 1,
    "jim":  1,
    "john": 1,
}
val = reflect.ValueOf(m)
typ = reflect.TypeOf(m)
iter := val.MapRange()
fmt.Print("{")
for iter.Next() {
    k := iter.Key()
    v := iter.Value()
    fmt.Printf("%s:%d,", k.String(), v.Int()) //{tony:1,jim:1,john:1,}
}
fmt.Println("}")
fmt.Println(typ.Kind(), typ.String()) //map map[string]int
type Person struct {
    Name string
    Age  int
}

//结构体
var p = Person{"tony", 13}
val = reflect.ValueOf(p)
typ = reflect.TypeOf(p)
fmt.Printf("{%s,%d}\n", val.Field(0).String(), val.Field(1).Int())                      //{tony,13}
fmt.Printf("{%s,%d}\n", val.FieldByName("Name").String(), val.FieldByName("Age").Int()) //{tony,13}
fmt.Println(typ.Kind(), typ.String())                                                   //struct go_demo.Person

//channel
ch := make(chan int, 1)
val = reflect.ValueOf(ch)
typ = reflect.TypeOf(ch)
ch <- 17
v, ok := val.TryRecv()
if ok {
    fmt.Println(v.Int())
}
fmt.Println(typ.Kind(), typ.String()) //chan chan int

//自定义类型
type myInt int
var mi myInt = 18
val = reflect.ValueOf(mi)
typ = reflect.TypeOf(mi)

fmt.Println(typ.Kind(), typ.String(), typ.String(), val.Int()) //int go_demo.myInt go_demo.myInt 18

// 函数
add := func(i int, j int) int {
    return i + j
}

f := reflect.ValueOf(add)
vals := []reflect.Value{reflect.ValueOf(5), reflect.ValueOf(6)}
ret := f.Call(vals)
fmt.Println(ret[0].Int()) //11

//方法
p2 := Person2{"张三", 18}
f2 := reflect.ValueOf(p2)
vals2 := []reflect.Value{reflect.ValueOf(1), reflect.ValueOf(2)}
mm := f2.MethodByName("Add2")
ret = mm.Call(vals2)
fmt.Println(ret[0].Int()) //3

type Person2 struct {
    Name string
    age  int
}

func (p Person2) Add2(i int, j int) int {
    return i + j
}
```






### 类型断言

- 你可以使用 `Type.ConvertibleTo()` 方法来检查一个类型是否可以转换为另一个类型。

- 使用 `Value.Convert()` 方法可以将一个反射值转换为另一个类型。


- 使用 `Value.Interface()` 方法可以将反射值转换回其原始的 `Go` 值接口（`interface{}`）。

## 反射世界的出口

`reflect.Value.Interface()` 是对 `reflect.ValueOf()` 的逆过程，通过该方法可以将 `reflect.Value` 对象恢复为一个 `interface{}` 的变量。这个变量与原变量是两个不同的变量，只是值相同，如果原变量为指针变量，那么对这个变量的修改会影响原变量


## 那些是可设置值的

```go
func Test23(t *testing.T) {

    //值类型: 不可设置、不可寻址
    var n = 17
    fmt.Println("int:")
    val := reflect.ValueOf(n)
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())
    // false false true

    //指针类型：可设置、可寻址
    fmt.Println("\n*int:")
    val = reflect.ValueOf(&n)
    // false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())
    // true true true
    val = reflect.ValueOf(&n).Elem() // 获取指针所指向的底层值
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    //slice：通过 Index 方法得到的元素，可以设置和寻址
    fmt.Println("\nslice:")
    var s1 = []int{5, 6, 7}
    val = reflect.ValueOf(s1)
    // false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    // val.Len() // 获取  slice 的长度
    val = val.Index(0) // 可设置 、可寻址
    //true true true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    //数组：通过 Index 方法得到的元素，不可以设置和寻址
    fmt.Println("\narray:")
    var arr = [3]int{5, 6, 7}
    val = reflect.ValueOf(arr)
    // false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    val = val.Index(0) // 不可设置 、不可寻址
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    //数组指针：通过 Index 方法得到的元素，可以设置和寻址
    fmt.Println("\n*array:")
    var pArr = &[3]int{5, 6, 7}
    val = reflect.ValueOf(pArr)
    // false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    val = val.Elem()
    val = val.Index(0) // 可设置 、可寻址
    //true true true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    //结构体: 导出字段    - 不可设置、不可寻址
    //       非导出字段  - 不可设置、不可寻址、不可恢复
    fmt.Println("\nstruct:")
    p := Person{"tony", 33}
    val = reflect.ValueOf(p)
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    nameField := val.Field(0)
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", nameField.CanSet(), nameField.CanAddr(), nameField.CanInterface())

    ageField := val.Field(1)
    //false false false
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", ageField.CanSet(), ageField.CanAddr(), ageField.CanInterface())

    //结构体指针: 导出字段    - 可设置 、可寻址
    //          非导出字段  - 不可设置、可寻址、不可恢复
    fmt.Println("\n *struct:")
    pointer := &Person{"tony", 33}
    val = reflect.ValueOf(pointer)
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())
    val = val.Elem()
    nameField = val.Field(0)
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", nameField.CanSet(), nameField.CanAddr(), nameField.CanInterface())

    ageField = val.Field(1)
    //false false false
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", ageField.CanSet(), ageField.CanAddr(), ageField.CanInterface())

    //万能接口
    fmt.Println("\n interface:")
    var i interface{} = &Person{"tony", 33}
    val = reflect.ValueOf(i)
    //false false true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    val = val.Elem()
    //true true true
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", nameField.CanSet(), nameField.CanAddr(), nameField.CanInterface())

    //map
    fmt.Println("\n map:")
    var m = map[string]int{
        "t": 23,
        "j": 24,
    }
    val = reflect.ValueOf(m)
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())

    val.SetMapIndex(reflect.ValueOf("t"), reflect.ValueOf(11))
    fmt.Printf("Settable = %v, CanAddr = %v, CanInterface = %v\n", val.CanSet(), val.CanAddr(), val.CanInterface())
    fmt.Println(m)

}
```



# unsafe


## 类型安全

**类型安全是指一块内存数据，一旦被特定的类型所解释（该内存数据与类型变量建立联系，也就是变量定义）它就不能再解释为其他类型，不能在与其他类型变量建立联系。**

## Go语法对类型安全的支持


Go 的类型安全是建立在Go编译器的静态检查及Go运行时利用类型信息进行的运行时检查之上的。在语法层面，为了实现常规下的类型安全，Go对语法做了诸多限制


1. 不支持隐式类型转换，所有类型转换必须显式进行
   ```go
   
    var i int = 17
    var j = i					//错误：int类型不能赋值给uint64类型
    var j2 uint64 = uint64(i)	//没问题
   ```

1. 只有底层类型相同的两个类型的指针之间才能进行类型转换

    ```go
    var i int = 17
	var p *uint64 = (*uint64)(&i) //错误：*int类型不能转换为*uint64类型
	fmt.Println(p)
	type Myint int
	var p2 *Myint = (*Myint)(&i) //正确的：Myint 的 底层类型 为 int
	fmt.Println(p2)
    ```

1. 不支持指针运算
    ```go
    var a [100]int
	var p *int = &a[0]
	*(p + 1) = 10	//错误 *int 类型 无法与 int 类型相加，即不能跨过数组的边界
    ```



## unsafe包方法使用

unsafe 包全部内容如下：
```go
package unsafe


type ArbitraryType int
type IntegerType int
type Pointer *ArbitraryType

func Sizeof(x ArbitraryType) uintptr
func Offsetof(x ArbitraryType) uintptr
func Alignof(x ArbitraryType) uintptr
func Add(ptr Pointer, len IntegerType) Pointer
func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType
```

ArbitraryType 不属于 unsafe包，在Go代码中并不使用 ArbitraryType 来定义变量，他表示一个任意表达式的类型，仅用于文档目的，Go编译器会对其做特殊处理。


### SizeOf方法
SizeOf 用于获取一个表达式值的大小
```go
func Test31(t *testing.T) {
	type Foo struct {
		a int      // 8
		b string   // 16
		c [10]byte // 10
		d float64  // 8
		//以上和为 42 字节，但是 go 会对齐到48的长度
	}

	var i int = 5
	var a = [100]int{}
	var s1 = a[:]
	var f Foo

	fmt.Println(unsafe.Sizeof(i))           // 8 	int类型大小为8
	fmt.Println(unsafe.Sizeof(a))           // 800 	数组长度 + 类型长度 = 100 * int长度8
	fmt.Println(unsafe.Sizeof(s1))          // 24	返回的是切片描述符的大小
	fmt.Println(unsafe.Sizeof(f))           // 48	返回的是结构体字段的大小的综合，包括内存对齐的长度
	fmt.Println(unsafe.Sizeof(f.a))         // 8	int类型大小为8
	fmt.Println(unsafe.Sizeof(f.b))         // 16	string类型大小为16（同结构体）
	fmt.Println(unsafe.Sizeof(f.c))         // 10	数组大小
	fmt.Println(unsafe.Sizeof(f.d))         // 8	float64 大小
	fmt.Println(unsafe.Sizeof((*int)(nil))) // 8	被解释为 int类型的 nil 值的大小
}
```

注意 SizeOf 函数不支持，直接传入 nil 
### Alignof

Alignof 用于获取一个表达式的内存地址的对齐参数。

对齐系数：处理器对变量地址都有对齐要求，**即变量的地址，必须可以被该变量的对齐系数整除。**

示例：
```go
var x int = 10
a := unsafe.Alignof(x)
addr := uintptr(unsafe.Pointer(&x))
b := addr%a
fmt.Println("x的地址:",addr)
fmt.Println("x的对其系数:",a)
fmt.Println("x地址对x对齐系数的取余:",b)
```


所有类型对齐系数获取

```go
func Test33(t *testing.T) {
	type Foo struct {
		a int      // 8 	长度
		b string   // 16	长度
		c [10]byte // 10	长度
		d float64  // 8		长度
		//以上和为 42 字节长度，但是 go 会对齐到48的长度
	}

	var i int = 5
	var a = [100]int{}
	var s1 = a[:]
	var f Foo
	fmt.Println(unsafe.Alignof(i))				// 8
	fmt.Println(unsafe.Alignof(f.a))			// 8
	fmt.Println(unsafe.Alignof(a))				// 8
	fmt.Println(unsafe.Alignof(s1))				// 8
	fmt.Println(unsafe.Alignof(f))				// 8
	fmt.Println(unsafe.Alignof(f.c))			// 1 数组的对齐长度与
	fmt.Println(unsafe.Alignof(struct {}{}))	// 1 空结构体的对齐系数为1
	fmt.Println(unsafe.Alignof([0]int{}))		// 8 长度为0的数组，对齐系数与元素类型相同
}
```
### Offsetof

Offsetof 用于获取某字段的地址偏移量（相对于结构体变量的地址）。Offset函数应用面较窄，仅用于求结构体中某字段的偏移值。

```go
func Test34(t *testing.T) {
	type Foo struct {
		a int      // 8 	长度
		b string   // 16	长度
		c [10]byte // 10	长度
		d float64  // 8		长度
		//以上和为 42 字节长度，但是 go 会对齐到48的长度
	}
	var f Foo
	fmt.Println(unsafe.Offsetof(f.b))	// 8
	fmt.Println(unsafe.Offsetof(f.d))	// 40
}
```

### Add

`unsafe.Add` 用于在一个指针的基础上增加一个偏移量，得到一个新的指针。这个方法从 `Go 1.17` 开始引入，目的是让指针运算更加安全和高效。
```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	arr := []int{1, 2, 3, 4, 5}
	ptr := unsafe.Pointer(&arr[0])
	// 增加一个偏移量，以字节为单位，这里每个int占4个字节（假设系统为32位）
	ptr = unsafe.Add(ptr, 4)
	fmt.Println(*(*int)(ptr)) // 输出: 2
}
```

###  Slice
`unsafe.Slice` 用于基于指针和长度创建一个切片。这个方法从 `Go 1.17` 开始引入。
```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var arr [5]int
	for i := 0; i < 5; i++ {
		arr[i] = i + 1
	}

	// 创建一个长度为 3 的切片，指向 arr 的前 3 个元素
	slice := unsafe.Slice(&arr[0], 3)
	fmt.Println(slice) // 输出: [1 2 3]
}
```

场景
1. 与 C 语言交互
   
    当你与 C 语言库进行交互时，通常需要从 C 语言传递的指针和长度创建 Go 切片。这种情况下，unsafe.Slice 非常有用。例如：

    ```go
    package main

    /*
    #include <stdlib.h>
    */
    import "C"
    import (
        "unsafe"
    )

    func main() {
        // 从 C 语言分配内存
        cArray := C.malloc(C.size_t(10 * C.sizeof_int))
        defer C.free(cArray)

        // 使用 unsafe.Slice 将 C 数组转换为 Go 切片
        slice := unsafe.Slice((*int)(cArray), 10)
        for i := range slice {
            slice[i] = i
        }
        fmt.Println(slice)
    }
    ```


2. 性能优化
    在某些性能关键的代码中，使用 unsafe.Slice 可以避免一些不必要的内存分配和拷贝操作，从而提升性能。例如，从现有的内存区域（如一个大数组的一部分）创建一个切片而不进行额外的内存分配。

3. 与低级数据结构交互
    有时你可能需要从一个低级数据结构（例如自定义的内存分配器或共享内存区域）创建切片。unsafe.Slice 可以让你直接操作这些数据，而不需要额外的封装。

4. 更灵活的指针操作
    在一些高级应用中，如操作系统开发、嵌入式编程或者一些需要直接操作硬件的场景，直接通过指针进行操作是非常常见的。unsafe.Slice 可以让你在这种情况下更灵活地处理数据。

    示例：从大数组的一部分创建切片
    ```go
    package main

    import (
        "fmt"
        "unsafe"
    )

    func main() {
        var arr [100]int
        for i := 0; i < 100; i++ {
            arr[i] = i + 1
        }

        // 从 arr 的第10个元素开始创建一个长度为10的切片
        slice := unsafe.Slice(&arr[10], 10)
        fmt.Println(slice) // 输出: [11 12 13 14 15 16 17 18 19 20]
    }
    ```
    注意这样创建的切片，同样会共享底层数组


## unsafe.Pointer

`unsafe` 包中定义了 `unsafe.Pointer` 类型， 它可以表示任意类型的指针。它的应用如下

1. 任意类型的指针都可以被转换为 `unsafe.Pointer`
   
   ```go
   	type Foo struct {
		a int      // 8 	长度
		b string   // 16	长度
		c [10]byte // 10	长度
		d float64  // 8		长度
		//以上和为 42 字节长度，但是 go 会对齐到48的长度
	}

	var a int = 5
	var b  float64 = 5.99
	var arr [10]string
	var f Foo
	
	p1 :=(unsafe.Pointer)(&a)
	p2 :=(unsafe.Pointer)(&b)
	p3 :=(unsafe.Pointer)(&arr)
	p4 :=(unsafe.Pointer)(&f)
   ```
1. unsafe.Pointer 也可以转换为任意类型的指针

    ```go
    var pa = (*int)(p1) 	// unsafe.Pointer -> *int 	
	var pb = (*int)(p2)		// unsafe.Pointer -> *float 
	var parr = (*int)(p3)	// unsafe.Pointer -> *[10]string 
	var pf = (*int)(p4)		// unsafe.Pointer -> *Foo 
    ```
1. uintptr 类型可以被转换为一个 unsafe.Pointer
   
    ```go
    var i uintptr = 0x80010203
    p:= unsafe.Pointer(i)
    ```


2. unsafe.Pointer 类型可以被转换为一个 uintptr

    ```go
    p:=unsafe.Pointer(&a)
    var j = uintptr(p)
    ```


## 性质总结
通过 unsafe.Pointer 可以很容易的穿透 Go 的类型安全保护。

## unsafe包的典型应用

### reflect包中使用unsafe包的典型应用

`ValueOf` 和 `TypeOf` 函数，会将任意类型转换为 `interface{}` 类型变量，再利用 `unsafe.Pointer` 将这个变量绑定的内存去重新解释为 `reflect.emptyinterface` 类型，以获得传入变量的类型和信息。

注意：`reflect.emptyinterface` 的结构 同 空接口`interface{}` 是一样的。

```go
// emptyInterface 用于表示一个 interface{} 类型的值的头部
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}
```
`reflect.ValueOf`
```go
func ValueOf(i any) Value {
    ...
	return unpackEface(i)
}

func unpackEface(i any) Value {
    //通过 指针 和 unsafe.Pointer 将内存解释为 emptyInterface 类型
	e := (*emptyInterface)(unsafe.Pointer(&i))
    ...
	return Value{t, e.word, f}
}
```

`reflect.TypeOf`
```go
func TypeOf(i any) Type {
    //通过 指针 和 unsafe.Pointer 将内存解释为 emptyInterface 类型
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}
```

### sync包中unsafe包的典型应用

`sync.Pool` 是一个并发安全的高性能临时对象缓存池。 `sync.Pool` 为每个 `P` 分配了一个本地缓冲池，并通过下面函数实现快速定位 `P` 的本地缓冲池：

```go
func indexLocal(l unsafe.Pointer, i int) *poolLocal {
    //通过指针计算方式获取目标对象
	lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{}))
	return (*poolLocal)(lp)
}
```
### syscall包


Syscall 系列函数接受的参数都是 uintptr 。

## unsafe包应用方向

1. 与操作系统及非Go编写代码的通信，如CGo
   
2. 高效类型转换，如 string 和 []byte 的转换:

1. 高性能序列化函数、原子操作、内存操作(指针运算)
   

## unsafe.Pointer 与 uintptr

Go语言的内存管理是基于垃圾回收的，垃圾回收会定期执行，如果一块内存没有被任何对象引用，它就会被垃圾器回收，而对象引用是通过指针实现的。

`unsafe.Pointer` 和其他常规类型指针一样，可以作为对象引用。如果一个对象被 `unsafe.Pointer` 引用着，那么该对象是不会被垃圾回收的。但是 uinptr 并不是指针，它仅仅是一个整型值，即使它存储着某个对象的内存地址，它也不会被算作对该对象的引用。

## unsafe.Pointer的安全使用模式


### 模式一(*T1 -> unsafe.Pointer -> *T2)

通过 `unsafe.Pointer` 将 `T1` 转变为 `T2` 类型


```go
//$GOROOT/src/math/unsafe.go
func Float64bits(f float64) uint64 { 
    return *(*uint64)(unsafe.Pointer(&f))
}
```
这种利用内存块重新解释实现的类型转换，不等价于 Go 语法层面的显式类型转换

显式转换
```go
var f float = 3.1415
var d1 = uint64(f) // d1 = 3
```

显式类型转换是语义层面的转换，float64 转为 uint64 实质上是取浮点数的整数部分，而用于 unsafe.Pointer 使用模式1 实现的转换，则只是机械的将这块内存视为 uint64 类型，它并不在乎原先存储的是什么数据。


在使用模式1 的时候也不能忽视内存对齐的问题。

```go
var a4 int32 = 10
var a8 int64 = 20

fmt.Println("int64的对齐系数：",unsafe.Alignof(a8))     // 8
fmt.Println("int32的对齐系数：",unsafe.Alignof(a4))     // 4

// int64 -> int32
a24 :=*(*int32)(unsafe.Pointer(&a8))                    
fmt.Println(a24)                                        // 20

// int32 -> int64 - 因为 int64 的 对齐系数 大于 int32，所以该方式不应使用
a28 :=*(*int64)(unsafe.Pointer(&a4))                
fmt.Println(a28)                                        // 85899345930
```

1. 如果 T1 的对齐系数小于 T2 ， 转换后，T2 则会占用额外的内存空间，导致结果出现错误。
2. 如果 T1 的对齐系数小于 T2 ， 并且 T2 的地址，不能整除 T2 的对齐系数，如果在 x86 平台(复杂指令集) 上，不会造成严重后果（可能会对性能产生少许影响），但是在一些对内存地址严格的平台，如 SPARC、ARM 上，对未对齐内存的地址进行指针解引用可能会出现 `总线错误` 等无法恢复的异常情况导致程序崩溃。



### 模式二(unsafe.Pointer -> uintptr)


模式2 比较简单就是将 unsafe.Pointer 转为 uintptr ，然后 uintptr 只用于打印输出，不参与其他操作

```go
var x int = 10
var p = uintptr(unsafe.Pointer(&x))
```

### 模式三模拟指针运算

在 C 语言中，指针和不定长的数组，在元素类型下是可以等价使用的。例如： 数组指针，就可以通过加减运算 ，来访问数组。但是这也容易造成内存访问越界的问题。


Go 语言中数组必须指定长度，且为值类型，指针运算也不在支持，这都是处于安全考虑。


在C语言中,指针运算如下

```c
++p
```

在go语言中，指针运算可以
```go
p := [5]int{1, 2, 3, 4, 5}

p2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Sizeof(p[0]) *2))

fmt.Println(*p2)
```

输出
```
3
```

**注意事项**
1. 不要越界
   
2. unsafe.Pointer -> uintptr -> unsafe.Pointer 的转换要在一个表达式中

    ```go
    func Test03(t *testing.T) {
        a := uintptr(unsafe.Pointer(NewArray()))
        //存在风险，这个时间空隙 ，GC 随时有可能回收掉 NewArray() 返回的数组实例
        p := unsafe.Pointer(a + unsafe.Sizeof(int(0)))
        fmt.Printf("%d\n", *(*int)(p))		//可能会抛出异常/panic 之类的
    }
    ```
    正确做法
    ```go
     p := unsafe.Pointer(uintptr(unsafe.Pointer(NewArray())) + unsafe.Sizeof(int(0)))
    ```


### 模式四(调用syscall.Syscall系列函数时指针类型到uintptr的转换)

错误做法
```go
var p *T
...
a := uintptr(unsafe.Pointer(p))
syscall.Syscall(SYS_READ, uintptr(fd), a, uinptr(n))
```
这个做法同模式三一样， a 所指向的值，可能会被GC 回收掉



正确做法
```go
syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uinptr(n))
```

### 模式五(将reflect.Value.Pointer或reflect.Value.UnsafeAddr转换为指针)

```go
//$GOROOT/src/reflect/value.go
func (v Value) Pointer() uintptr        // 用于获取反射值的底层指针
func (v Value) UnsafeAddr() uintptr     // 返回反射值的内存地址
```


示例1
```go
func Test03(t *testing.T) {
	a :=3
	i := *(*int)(unsafe.Pointer(reflect.ValueOf(&a).Pointer()))
	fmt.Println(i)
}
```
示例2
```go
func Test04(t *testing.T) {
	var x int = 42
	v := reflect.ValueOf(&x).Elem()
	ptr := (*int)(unsafe.Pointer(v.UnsafeAddr()))
	fmt.Printf("Value: %d\n", *ptr)
	fmt.Printf("Value: %d\n", ptr)
	fmt.Printf("Value: %d\n", &x)
}
```
### 模式六(reflect.SliceHeader和reflect.StringHeader必须通过模式1构建)


```go
func Test05(t *testing.T) {
	bh := (*reflect.SliceHeader)(unsafe.Pointer(newSlice())) //模式1 *T1 -> *T2
	var p = (*[]byte)(unsafe.Pointer(bh))
	fmt.Printf("%q\n", *p)

	var a = [...]byte{'I','o'}
	bh.Data = uintptr(unsafe.Pointer(&a))
	bh.Len = len(a)
	bh.Cap = len(a)
	
	fmt.Printf("%q\n", *p)
}
```


# 标准库读写模型


![](https://raw.githubusercontent.com/shisan1379/img/main/img/202407011004682.png)


io.Write 与 io.Reader 接口支持以下操作

1. 支持将 `[]byte` 类型的字节序列，写入/读取存储或传输数据的实体抽象
2. 可以在实体抽象的基础上实现(通过包裹函数)，缓冲读写、数据变换等特性
3. 抽象数据类型支持通过标准库所提供的各种编码方案（JSON、XML）转换，(encode/decode) 为 `[]byte` 类型承载的字节序列

## 直接读写字节序列
```go
// 写入文件
func directWriteByteSliceToFile(path string, data []byte) (int, error) {

	//* 使用 `os.OpenFile` 函数尝试打开文件。
	//* 如果文件不存在，由于使用了 `os.O_CREATE` 标志，它将创建一个新文件。
	//* `os.O_RDWR` 标志允许文件以读写模式打开。
	//* `os.O_APPEND` 标志确保数据被追加到文件的末尾，而不是覆盖文件的内容。
	//* `0666` 是文件的权限设置，代表文件所有者、组和其他用户都有读写权限（但在某些系统上，由于 umask 的影响，实际权限可能会有所不同）。

	f, err := os.OpenFile(path,
		os.O_RDWR|os.O_CREATE|os.O_APPEND,
		0666,
	)

	if err != nil {
		fmt.Println("open file error:", err)
		return 0, err
	}

	defer func() {
		f.Sync()
		f.Close()
	}()

	return f.Write(data)
}

//读取文件
func directReadByteSliceFormFile(path string, data []byte) (int, error) {
	f, err := os.Open(path)
	if err != nil {
		fmt.Println("open file error:", err)
		return 0, err
	}
	defer f.Close()
	return f.Read(data)
}
//写入后读取 但是 []byte 结尾会填充 0x0 
func Test06(t *testing.T) {

	file := "D:\\foo.txt"
	text := "hello, gopher"
	buf := make([]byte, 20)

	n, err := directWriteByteSliceToFile(file, []byte(text))
	if err != nil {
		fmt.Println("write file error:", err)
		return
	}
	fmt.Printf("write %d bytes to file,\n", n)

	n, err = directReadByteSliceFormFile(file, buf)
	if err != nil {
		fmt.Println("read file error:", err)
		return
	}
	fmt.Printf("read %d bytes to file: %q\n", n, buf)

}

//使用 eof 判断停止
func Test07(t *testing.T) {

	file := "D:\\foo.txt"
	text := "hello, gopher"
	buf := make([]byte, 13)
	n, err := directWriteByteSliceToFile(file, []byte(text))

	if err != nil {
		fmt.Println("写入失败")
		return
	}

	fmt.Printf("写 %d 字节 到文件 \n",n)

	f, err := os.Open(file)
	if err != nil {
		fmt.Println("打开文件失败", err)
		return
	}
	defer f.Close()

	for  {
		n, err := f.Read(buf)
		if err != nil {

		if err == io.EOF {
			fmt.Println("eof")
			return
		}
		fmt.Println("读取错误",err)
		}
		fmt.Printf("读 %d 字节 从 文件：%q\n",n,buf)
	}
}
```


## 直接读写抽象数据类型实例

直接读写抽象数据类型实例

![直接读写抽象数据类型实例](https://raw.githubusercontent.com/shisan1379/img/main/img/202407011031870.png)

### 利用fmt.Fscan和fmt.Fprint系列函数进行读写





定义一个结构体，并按照自定义格式写入文件：
```go
type Player struct {
	name string
	age int
	gender string
}

func (receiver Player) String() string {
	return fmt.Sprintf("%s %d %s",receiver.name,receiver.age,receiver.gender)
}
func directWriteADTToFile(path string ,players []Player)error  {
	f, err := os.Create(path)
	if err != nil {
		fmt.Println("创建文件失败",err)
		return err
	}
	defer func() {
		f.Sync()
		f.Close()
	}()
	for _, player := range players {
		_, err := fmt.Fprintf(f, "%s %d %s\n", player.name, player.age, player.gender)
		if err != nil {
			return err
		}
	}

	return nil
}
func Test08(t *testing.T) {

	players := []Player{
		{"tom", 18, "man"},
		{"lucy", 11, "women"},
		{"jerry", 10, "man"},
	}
	err := directWriteADTToFile("d:/players.dat", players)
	if err != nil {
		fmt.Println("写入失败",err)
	}
}
```
将文件内容还原到结构体中
```go

func Test09(t *testing.T) {
	f, err := os.Open("d:/players.dat")
	if err != nil {
		fmt.Println("打开失败", err)
		return
	}
	var player Player

	for {
        //Fscanf 方法只支持原生类型
		_, err := fmt.Fscanf(f, "%s %d %s", &player.name, &player.age, &player.gender)
		if err == io.EOF {
			fmt.Println("eof")
			return
		}
		if err != nil {
			fmt.Println("读取失败", err)
			return
		}
		fmt.Printf("%s %d %s\n", player.name, player.age, player.gender)
	}
}
```

缺点：本质是扫描和解析出的字符串，只能逐个字段进行填充


### 利用binary.Read和binary.Write函数进行读写

```go
type Player2 struct {
	Name   [20]byte
	Age    int16
	Gender [6]byte
}

func directWriteFileUseBinary(path string, players []Player2) error {
	f, err := os.Create(path)
	if err != nil {
		fmt.Println("创建文件失败", err)
		return err
	}
	defer func() {
		f.Sync()
		f.Close()
	}()
	for _, player := range players {
		err := binary.Write(f, binary.BigEndian, &player)
		if err != nil {
			return err
		}
	}

	return nil
}

func Test10(t *testing.T) {
	players := [3]Player2{}

	copy(players[0].Name[:], []byte("tommy"))
	players[0].Age = 18
	copy(players[0].Gender[:],[]byte("man"))


	path := "d:/players2.dat"
	err := directWriteFileUseBinary(path, players[:])
	if err != nil {
		fmt.Println("写入失败", err)
		return
	}

	f, err := os.Open(path)

	if err != nil {
		fmt.Println("打开文件失败", err)
		return
	}

	var player Player2

	for {
		err := binary.Read(f, binary.BigEndian, &player)
		if err == io.EOF {
			fmt.Println("eof")
			return
		}
		if err != nil {
			fmt.Println("读取失败", err)
			return
		}
		fmt.Printf("%s %d %s\n", player.Name, player.Age, player.Gender)

	}

}
```
1. 需要导出结构体字段（字段首字母大写）
2. 只支持了定长类型

### 使用gob包的Decode和Encode方法进行读写

```go
func Test12(t *testing.T) {
	path := "d:/player3"
	players := []Player{
		{"tom", 18, "man"},
		{"lucy", 11, "women"},
		{"jerry", 10, "man"},
	}

	f, err := os.Create(path)

	if err != nil {
		fmt.Println("创建文件失败", err)
		return
	}
	enc := gob.NewEncoder(f)

	for _,p := range players {

		err := enc.Encode(p)
		if err != nil {
			fmt.Println("写入错误",err)
			return
		}
	}
	f, err = os.Open(path)
	if err != nil {
		fmt.Println("打开文件失败", err)
		return
	}
	dec := gob.NewDecoder(f)
	var player Player
	for  {
		err := dec.Decode(&player)

		if err == io.EOF {
			fmt.Println("eof")
			return
		}
		if err != nil {
			fmt.Println("读取失败", err)
			return
		}
		fmt.Printf("%v\n", player)
	}
}
```
`gob` 包是 `Go 标准库` 提供的一个 序列化/反序列化 方案，和JSON、XML 等序列化/反序列化方案不同，它的 API 直接支持读写，实现了 io.Reader 和 io.Write 接口




## 通过包裹类型读写数据

包裹函数：接受接口类型参数，并返回与其参数类型相同的返回值
```go
func 你的包装方法(param 你的接口类型) 你的接口类型
```


### 通过包裹函数实现带缓冲I/O
```go
// 写
func TestBufioWrite(t *testing.T) {
	file := "d:/bufio.txt"
	f, err := os.OpenFile(file, os.O_RDWR| os.O_CREATE| os.O_APPEND, 0666)
	if err != nil {
		fmt.Println("创建文件失败", err)
		return
	}

	defer func() {
		f.Sync()
		f.Close()
	}()

	data :=[]byte("123456789")

	//设置缓冲区大小
	bio := bufio.NewWriterSize(f, 32)

	//写入缓冲区，如果缓冲区满的话则写入txt
	bio.Write(data)
	bio.Write(data)
	bio.Write(data)

	//将所有缓冲区缓存写入 txt
	bio.Flush()
}

// 读
func TestBufioRead(t *testing.T) {

	file := "d:/bufio.txt"
	f, err := os.Open(file)
	if err != nil {
		fmt.Println("读取文件失败", err)
		return
	}

	defer func() {
		f.Sync()
		f.Close()
	}()


	//设置缓冲区大小
	bio := bufio.NewReaderSize(f, 64)

	var i int = 1
	for  {
		data := make([]byte,15)
		n, err := bio.Read(data)

		if err == io.EOF {
			fmt.Println("eof")
			return
		}
		if err != nil {
			fmt.Println("读取失败", err)
			return
		}

		fmt.Printf("第 %d 次读出数据:%q,长度=%d\n",i,data,n)
		fmt.Printf("当前缓冲区缓存数据量%d字节\n\n",bio.Buffered())
		i++
	}
}
```

### 通过包裹类型实现数据压缩/解压缩


```go
func Test13(t *testing.T) {
	file := "d:/higo.gz"
	f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)

	defer f.Close()

	zw := gzip.NewWriter(f)
	defer zw.Close()
	_, err = zw.Write([]byte("12345678912345679"))
	if err != nil {
		fmt.Println("写入失败")
	}
}

func Test14(t *testing.T) {
	file := "d:/higo.gz"
	f, _ := os.Open(file)

	defer f.Close()

	zw, _ := gzip.NewReader(f)
	defer zw.Close()
	i := 1
	for {
		buf := make([]byte, 2)
		_, err := zw.Read(buf)
		if err != nil {
			if err == io.EOF {
				fmt.Printf("第 %d 次读出数据:%q\n", i, buf)
				fmt.Println("eof")
				return
			}
		}
		fmt.Printf("第 %d 次读出数据:%q\n", i, buf)
		i++
	}
}
```





# cgo-todo


# 测试

1. 测试用例文件必须以 `_test.go` 结尾
2. 测试用例方法必须以 `Test` 开头
3. 模糊测试用例以 `Fuzz` 开头
4.  Error 会使得测试失败，Fatal 会终止测试
   ```go
    t.Errorf("%v",structS)
    t.Fatalf("%s","12")
   ```
   
## 包内测试和包外测试

**包内测试**
将测试代码放在与被测包同名中的测试方法，称之为包内测试。

包内测试的缺点
1. 测试代码需要经常维护
2. 包循环引用，这是Go不允许的

**包外测试**
测试代码所在包与被测代码所在包不同，称之为包外测试

包外测试的缺点
1. 只能测试导出的方法/API,导致覆盖不足，使用 `export_text` 方式导出未测试的代码
   ```go
   //m02 属于包内函数，通过赋值方式导出
   var M02 = m02
    func TestM02(t *testing.T) {
        s := M02()
        fmt.Println(s)
    }
   ```


总结：有限使用包外测试
1. 有限保证导出的API的正确性
2. 从用户角度保证导出的API的有效性
3. 保持测试代码的健壮性，尽可能降低对测试代码维护的投入
4. 不失灵活，可以通过 `export_text.go` 导出
   

## 有层次的组织测试代码


### 平铺


![](https://raw.githubusercontent.com/shisan1379/img/main/img/202407030947880.png)

使用 `-v` 对被测测试用例进行平铺展示

```bash
go test -v
```
结果
```bash
=== RUN   TestM01
--- PASS: TestM01 (0.00s)
```


### subtest

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202407030950164.png)

对于所有测试用例是都平铺在顶层，这代表了，并没有对其进行组织，与此相对应的是 `xUnit` 组织形式，以树形结构组织测试用例，即 `测试工程 -> 测试套件 -> 测试用例`。

在 Go1.7 以后，加入了 `subtest` 模式

```go
package m

import "testing"

func TM01(t *testing.T)   {
	M01()
}
func TM02(t *testing.T)   {
	M01()
}

func TestBuilder(t *testing.T)  {
	t.Run("TM01",TM01)
	t.Run("TM02",TM02)
}
```

执行 `go test -v .` 
```bash
=== RUN   TestBuilder
=== RUN   TestBuilder/TM01
=== RUN   TestBuilder/TM02
--- PASS: TestBuilder (0.00s)
    --- PASS: TestBuilder/TM01 (0.00s)
    --- PASS: TestBuilder/TM02 (0.00s)
PASS
ok      _/E_/GIT/go_test/src/m  1.565s
```

### 测试固件

测试固件是指，一个人造的、确定性的环境，即软件逻辑运行之前所需的基础。

测试固件常见的场景
1. 将一组特定的数据加载到数据库中，测试后清除
   
2. 复制一组特定的已知文件，测试结束后清除这些文件
   
3. 创建一些对象或模拟对象，并未这些对象设置所需的特定数据和期望结果
   

**go1.14版本增加了 `testing.Cleanup` 方法，为测试固件提供了包级的支持**

```go
package m

import (
	"fmt"
	"testing"
)

func TM01(t *testing.T)   {
	M01()
}
func TM02(t *testing.T)   {
	M01()
}

func setUp(testName string) func() {
	fmt.Println("测试名称:",testName)
	return func() {
		fmt.Println("结束测试")
	}
}

func TestFunc2(t *testing.T) {
    //使用 Cleanup 方法销毁测试固件
	t.Cleanup(setUp(t.Name()))
	t.Run("TM01",TM01)
	t.Run("TM02",TM02)
}
```
`go test -v .`输出
```bash
=== RUN   TestFunc2
测试名称: TestFunc2
=== RUN   TestFunc2/TM01
=== RUN   TestFunc2/TM02
结束测试
--- PASS: TestFunc2 (0.00s)
    --- PASS: TestFunc2/TM01 (0.00s)
    --- PASS: TestFunc2/TM02 (0.00s)
PASS
ok      _/E_/GIT/go_test/src/m  1.610s
```

**go1.14版本增加了 `TestMain`，为`包级别`测试固件提供了创建和**
```go
func TestTM01(t *testing.T) {
	t.Cleanup(setUp(t.Name()))
	M01()
}
func TestTM02(t *testing.T) {
	t.Cleanup(setUp(t.Name()))
	M01()
}

func pkgSetUp(testName string) func() {
	fmt.Println("测试名称pkg:", testName)
	return func() {
		fmt.Println("结束测试pkg")
	}
}
func setUp(testName string) func() {
	fmt.Println("测试名称:", testName)
	return func() {
		fmt.Println("结束测试:", testName)
	}
}

func TestMain(m2 *testing.M) {
	defer pkgSetUp("package m2_test")()
	m2.Run()
}
```
输出
```bash
测试名称pkg: package m2_test
=== RUN   TestTM01
测试名称: TestTM01
结束测试: TestTM01
--- PASS: TestTM01 (0.00s)
=== RUN   TestTM02
测试名称: TestTM02
结束测试: TestTM02
--- PASS: TestTM02 (0.00s)
PASS
结束测试pkg
ok      _/E_/GIT/go_test/src/m  1.866s
```

有时一些测试函数所需的测试固件是相同的我们可以把 `测试套件` 和 `TestMain` 结合使用，来减少 `测试固件` 的重复创建。这也是 `xUnit` 的组织模式
```go
func TM01(t *testing.T) {
	M01()
}
func TM02(t *testing.T) {
	M01()
}

func pkgSetUp(testName string) func() {
	fmt.Println("测试名称pkg:", testName)
	return func() {
		fmt.Println("结束测试pkg")
	}
}
func setUp(testName string) func() {
	fmt.Println("测试名称:", testName)
	return func() {
		fmt.Println("结束测试:", testName)
	}
}

func TestFun1(t *testing.T) {
	t.Cleanup(setUp(t.Name()))
	t.Run("TM01",TM01)
	t.Run("TM02",TM02)
}

func TestFun2(t *testing.T) {
	t.Cleanup(setUp(t.Name()))
	t.Run("TM01-2",TM01)
	t.Run("TM02-2",TM02)
}

func TestMain(m2 *testing.M) {
	defer pkgSetUp("package m2_test")()
	m2.Run()
}
```
输出
```bash
测试名称pkg: package m2_test
=== RUN   TestFun1
测试名称: TestFun1
=== RUN   TestFun1/TM01
=== RUN   TestFun1/TM02
结束测试: TestFun1
--- PASS: TestFun1 (0.00s)
    --- PASS: TestFun1/TM01 (0.00s)
    --- PASS: TestFun1/TM02 (0.00s)
=== RUN   TestFun2
测试名称: TestFun2
=== RUN   TestFun2/TM01-2
=== RUN   TestFun2/TM02-2
结束测试: TestFun2
--- PASS: TestFun2 (0.00s)
    --- PASS: TestFun2/TM01-2 (0.00s)
    --- PASS: TestFun2/TM02-2 (0.00s)
PASS
结束测试pkg
ok      _/E_/GIT/go_test/src/m  1.831s
```

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202407031032841.png)

## testdata目录
Go 语言规定：Go工具链将忽略名为 testdata 的目录。 `go test` 命令,在执行时会将程序包源码所在目录设置为工作目录，如果要使用 `testdata` 文件夹下某个文件，就无须处理各种路径问题

```go
file, err := os.OpenFile("testdata/xxx.txt")
```

# 

# 性能剖析





# go工具链



