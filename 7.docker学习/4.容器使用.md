

# 容器是什么

容器是基于镜像创建的可执行实例，并且单独存在。一个镜像可以创建出多个容器。运行容器化环境是，实际上是在容器内部创建该文件的读写副本。这将添加一个容器层，该层允许修改镜像的整个副本
![alt text](image-9.png)

# 容器的生命周期

容器的生命周期是容器可能处于的状态，容器的生命周期分为 5 种。

1. `created` : 创建状态
2. `running` : 运行状态
3. `stopped` : 停止状态
4. `paused`  : 暂停状态
5. `deleted` : 删除状态
   
![alt text](image-10.png)


1. 通过 `docker create` 命令创建容器为 `created` 状态
2. 通过 `docker start`  命令可以转化为 `running` 状态
3. 通过 `docker stop`   命令可以转发为 `stopped` 状态
4. 通过 `docker pause`  命令可以转化为 `paused`  状态
5. 处于以上四种状态的容器都可以直接删除

# 容器的操作

## 创建并启动容器

**第一种方式**
1. 使用 docker create 创建容器，使用 docker start 启动容器
```bash
docker create -it --name=busybox busybox
07d155aba3b8fbbdb80d6a41de6b4e84496b5f80b7aab5ac25f3e7d05fada10a
```
查看容器状态
```bash
docker ps -a
# 如果容器较多可以加入筛选 docker ps -a| grep busybox
CONTAINER ID   IMAGE     COMMAND   CREATED              STATUS    PORTS     NAMES
07d155aba3b8   busybox   "sh"      About a minute ago   Created             busybox
```
容器此时为 `Created` 状态，使用 `docker start` 启动容器

```bash
docker start  07d155aba3b8
07d155aba3b8
```
继续查看状态
```bash
docker ps 
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS          PORTS     NAMES
07d155aba3b8   busybox   "sh"      5 minutes ago   Up 11 seconds             busybox
```



**第二种方式** 使用 docker run 创建并启动容器

```bash
$ docker run -it --name=busybox2 busybox
```
当使用 docker run 创建并启动容器时，会执行以下流程

1. docker 会检查本地是否存在镜像，如果不存在则从 Docker Hub 拉取
2. 使用镜像创建并启动一个容器
3. 分配文件系统，并在在镜像只读层外创建一个读写层
4. 从 Docker IP 池分配一个 IP 给容器
5. 执行用户的启动命令，运行程序

上述命令中， -t 参数的作用是分配一个伪终端，-i 参数则可以终端的 STDIN 打开，同时使用 -it 参数可以让我们进入交互模式。 在交互模式下，用户可以通过所创建的终端来输入命令，例如：
```bash
$ ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 sh
    6 root      0:00 ps aux
```

我们可以看到容器的 1 号进程为 sh 命令，在容器内部并不能看到主机上的进程信息，因为容器内部和主机是完全隔离的。同时由于 sh 是 1 号进程，意味着如果通过 `exit PID` 退出 sh，那么容器也会退出。所以对于容器来说，**杀死容器中的主进程，则容器也会被杀死**。


### docker create

基本语法
```bash
docker create [OPTIONS] IMAGE [COMMAND] [ARG...]
```

- IMAGE: 要基于哪个镜像创建容器，比如 ubuntu:latest。
- COMMAND: 可选项，指定容器启动时执行的命令。
- OPTIONS: 包括容器的配置选项。
- 
**常见的选项和参数**
1. `--name`: 指定容器的名称。
   ```bash
   docker create --name my_container ubuntu
   ```
1. `-v`: 挂载卷，将主机的目录挂载到容器中。
    ```bash
   docker create -v /host/path:/container/path ubuntu
   ```
1. `-e`: 设置环境变量。
   ```bash
   docker create -e MY_ENV_VAR=value ubuntu
   ```
1. `--network`: 指定容器要连接的 Docker 网络。
   ```bash
   docker create --network my_network ubuntu
   ```
1. `-p`: 暴露端口，将主机的端口映射到容器的端口
   ```bash
   # docker create -p <主机端口>:<容器端口> IMAGE
   docker create -p 8080:80 nginx
   ```
1. `--restart`: 设置容器的重启策略（如 no, on-failure, always）
   ```bash
   docker create --restart always nginx
   ```
### docker run

基本语法
```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
大部分参数同 `docker create` 相同，少数不同如下：

1. -d: 后台运行容器（分离模式）。
   ```bash
   docker run -d nginx
   ```
   会让容器在后台运行，且不会锁定终端。
1. -it: 交互模式（-i 保持标准输入打开，-t 分配伪终端）。
   ```bash
   docker run -it ubuntu bash
   ```
   进入交互模式并运行 bash，你可以通过终端与容器进行交互。
1. --rm: 容器停止后自动删除
   ```bash
   docker run --rm ubuntu
   ```
   这会在容器退出时自动删除它，适用于一次性任务。

1. --cpus 和 --memory: 限制容器的 CPU 和内存使用。
   ```bash
   docker run --cpus="2.0" --memory="512m" ubuntu
   ```
   限制容器最多使用 2 个 CPU 和 512 MB 内存。

1. 运行带命令的容器
   ```bash
   docker run ubuntu echo "Hello Docker"
   ```

## 停止容器

容器启动后，如果我们想停止运行中的容器，
1. docker stop
2. docker kill


### docker stop

`docker stop` 会首先发送一个 SIGTERM 信号给容器中的主进程，给它时间来完成清理工作。默认情况下，Docker 会等待 10 秒，如果容器在这段时间内没有停止，Docker 将发送 `SIGKILL` 信号，强制终止容器。

命令格式：
```bash
docker stop [OPTIONS] CONTAINER [CONTAINER...]
```
常用选项： 
1. -t 或 --time: 设置等待容器停止的超时时间（秒）。

    - 默认等待时间是 10 秒。如果你希望容器有更多时间来优雅地停止，你可以通过 -t 参数进行调整。
  
    ```bash
    docker stop -t 20 my_container
    ```
### docker kill

docker kill 默认会发送 SIGKILL 信号给容器，这个信号会立即终止容器的进程，不允许它进行任何清理工作。因此，这种方式用于紧急停止或不需要优雅关闭的情况。

基本语法
```bash
docker kill [OPTIONS] CONTAINER [CONTAINER...]
```
常见选项
- -s 或 --signal: 发送指定的信号，而不是默认的 SIGKILL。

    你可以发送其他信号，如 SIGTERM、SIGINT 等。
    ```bash
    docker kill -s SIGTERM my_container
    ```

常见信号
![alt text](image-11.png)

## 进入容器

处于运行状态的容器可以通过docker attach、docker exec、nsenter等多种方式进入容器。


### docker attach

docker attach 命令连接到容器的主进程，适用于需要直接控制容器主进程的情况。

注意：当我们同时使用docker attach命令同时在多个终端运行时，所有的终端窗口将同步显示相同内容，当某个命令行窗口的命令阻塞时，其他命令行窗口同样也无法操作。

```bash
docker attach [OPTIONS] CONTAINER
```
- CONTAINER: 容器的名称或 ID。

注意
- docker attach 会附加到容器的主进程。如果你停止了主进程，容器会随之停止。
  
- 不同于 docker exec，docker attach 是直接控制容器的主要流程，适用于需要实时监控输出的场景，但在与多个终端操作时，它的灵活性不如 docker exec。

### docker exec

docker exec 命令可以在已经运行的容器内启动一个新的进程。它是最常用的进入容器的方法，特别适合在容器内启动新的终端或运行其他命令。
```bash
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```
- -it: 交互式终端，-i 保持输入流打开，-t 分配一个伪终端。
- CONTAINER: 容器的名称或 ID。
- COMMAND: 要在容器中运行的命令，通常使用 bash 或 sh 来打开 Shell。
  
**示例：**
1. 进入容器的 Bash Shell
   ```bash
   docker exec -it my_container bash
   ```
   这会启动 bash Shell，进入容器 my_container。

1. 如果容器没有 Bash，可以尝试用 sh
   ```bash
   docker exec -it my_container sh
   ```
1. 在容器内运行特定命令
   ```bash
   docker exec -it my_container ls /var/log
   ```
   这会列出容器内 /var/log 目录的内容，而不进入 Shell。

### nsenter (进阶方法)

nsenter 命令可以直接访问容器的命名空间，这是一种更底层的方式，但需要你的系统上安装了 nsenter 工具。它并不是 Docker 的内置命令。

```bash
nsenter --target PID --mount --uts --ipc --net --pid
```
PID: 容器中某个进程的 ID，可以通过 docker inspect 获取容器的主进程 ID。

1. 获取容器ID
    ```bash
    docker inspect --format "{{.State.Pid}}" my_container
    ```
1. 使用 `nsenter` 进入容器
   ```bash
   nsenter --target 12345 --mount --uts --ipc --net --pid
   ```
1. 尝试 sh Shell
   如果容器中没有 bash，你可以尝试使用 sh，它是许多轻量级 Linux 系统的默认 shell。
   ```bash
   sudo nsenter --target 4192 --mount --uts --ipc --net --pid -- /bin/sh
   ```