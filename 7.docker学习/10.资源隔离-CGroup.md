
# cgroups

cgroups（全称：control groups）是 Linux 内核的一个功能，它可以实现限制进程或者进程组的资源（如 CPU、内存、磁盘 IO 等）。

> 在 2006 年，Google 的工程师（ Rohit Seth 和 Paul Menage 为主要发起人） 发起了这个项目，起初项目名称并不是cgroups，而被称为进程容器（process containers）。在 2007 年cgroups代码计划合入Linux 内核，但是当时在 Linux 内核中，容器（container）这个词被广泛使用，并且拥有不同的含义。为了避免命名混乱和歧义，进程容器被重名为cgroups，并在 2008 年成功合入 Linux 2.6.24 版本中。cgroups目前已经成为 systemd、Docker、Linux Containers（LXC） 等技术的基础。


# cgroups 功能及核心概念



cgroups 主要提供了如下功能。

- 资源限制： 限制资源的使用量，例如我们可以通过限制某个业务的内存上限，从而保护主机其他业务的安全运行。

- 优先级控制：不同的组可以有不同的资源（ CPU 、磁盘 IO 等）使用优先级。

- 审计：计算控制组的资源使用情况。

- 控制：控制进程的挂起或恢复。


cgroups功能的实现依赖于三个核心概念：子系统、控制组、层级树。

- **子系统（subsystem）**：是一个内核的组件，一个子系统代表一类**资源调度控制器**。例如内存子系统可以限制内存的使用量，CPU 子系统可以限制 CPU 的使用时间。
  
  可以使用 `lssubsys -a` 查看内核支持的 subsystem
    ```bash
    what@what-virtual-machine:~$ lssubsys -a
    cpuset
    cpu
    cpuacct
    blkio
    memory
    devices
    freezer
    net_cls
    perf_event
    net_prio
    hugetlb
    pids
    rdma
    misc
    ```


- **控制组（cgroup）**：cgroups 是 control groups 的缩写。
  
  表示一组进程和一组带有参数的子系统的关联关系。例如，一个进程使用了 CPU 子系统来限制 CPU 的使用时间，则这个进程和 CPU 子系统的关联关系称为控制组。
  
  一个进程可以加入某个 cgroup，也可以从某个 cgroup 迁移到另外一个 cgroup

- **层级树（hierarchy）**：是由一系列的控制组按照树状结构排列组成的。这种排列方式可以使得控制组拥有父子关系，子控制组默认拥有父控制组的属性，也就是子控制组会继承于父控制组。
  比如，系统中定义了一个控制组 c1，限制了 CPU 可以使用 1 核，然后另外一个控制组 c2 想实现既限制 CPU 使用 1 核，同时限制内存使用 2G，那么 c2 就可以直接继承 c1，无须重复定义 CPU 限制。
  
  可以使用 `mount | grep cgroup` 命令查看


cgroups 的三个核心概念中，子系统是最核心的概念，因为子系统是真正实现某类资源的限制的基础。



# CPU 子系统

1. 首先创建一个文件夹 ， 把它当做 cgroup 的挂载点
   ```bash
   mkdir cgroup-test
   ```
2. 挂载一个 hierarchy 到文件夹
   ```bash
   mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test
   ```
   查看 cgroup-test 文件夹
   ```bash
    what@what-virtual-machine:~$ cd cgroup-test/
    what@what-virtual-machine:~/cgroup-test$ ll
    总计 4
    dr-xr-xr-x  2 root root    0  9月 23 16:52 ./
    drwxr-x--- 18 what what 4096  9月 23 16:50 ../
    -rw-r--r--  1 root root    0  9月 23 16:52 cgroup.clone_children
    -rw-r--r--  1 root root    0  9月 23 16:52 cgroup.procs
    -r--r--r--  1 root root    0  9月 23 16:52 cgroup.sane_behavior
    -rw-r--r--  1 root root    0  9月 23 16:52 notify_on_release
    -rw-r--r--  1 root root    0  9月 23 16:52 release_agent
    -rw-r--r--  1 root root    0  9月 23 16:52 tasks
   ```
   - `cgroup.clone_children` : 是否将新创建的子进程自动加入到它们的父进程所在的 cgroup 中。如果该文件包含 1（或 0），则表示启用（或禁用）这个行为。通常，这个设置是 1，意味着子进程会继承父进程的 cgroup 成员身份。
  
   - `cgroup.procs` : 这个文件列出了当前属于该 cgroup 的所有进程的 PID（进程ID）。你可以通过向这个文件写入 PID 来将进程添加到 cgroup，或者通过从文件中删除 PID 来将进程从 cgroup 中移除。
  
   - `cgroup.sane_behavior` : 这个文件用于控制 cgroup 在处理某些异常情况时的行为。如果该文件包含 1，则表示启用更安全的默认行为，这有助于防止某些潜在的安全问题或意外的资源隔离问题。具体行为可能依赖于你使用的 Linux 发行版和内核版本。
   
   - `notify_on_release` : 当 cgroup 中的最后一个进程终止或被移除，且该 cgroup 随后被销毁时，此设置可以触发一个通知。如果该文件包含 1，则当 cgroup 被销毁时会尝试执行 release_agent 指定的脚本或程序。
  
   - `release_agent` : 这个文件应包含一个指向脚本或程序的路径，该脚本或程序在 cgroup 被销毁时将被执行（前提是 notify_on_release 被设置为 1）。这通常用于执行清理任务，如释放资源或记录日志。
  
  <!-- 有问题 -->
   - `tasks` : 类似于 cgroup.procs，但 tasks 文件通常用于与较旧版本的 cgroup 接口兼容。它也包含了属于该 cgroup 的进程的 PID 列表，但不应直接修改这个文件来添加或删除进程；相反，应该使用 cgroup.procs。
3. 
