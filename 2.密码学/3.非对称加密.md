
# 介绍

非对称加密也叫共要密码：使用公钥加密，私钥解密


![](http://qiniu.liulei.life/202208061152326.png)

在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。用于解密的密钥必须被配送给接收者，这一问题称为密钥配送问题。如果使用非对称加密也可以称为公钥密码，则无需向接收者配送用于解密的密钥，这样就解决了密钥配送问题。可以说非对称加密是密码学历史上最伟大的发明

仔细思考一下加密密钥和解密密钥的区别，我们可以发现：
- 发送者只需要加密密钥
- 接收者只需要解密密钥
- 解密密钥不可以被窃听者获取
- 加密密钥被窃听者获取也没问题




# 非对称加密通信流程 

下面我们来看一看使用公钥密码的通信流程。和以前一样、我们还是假设Alice要给Bob发送一条消息，Alice是发送者，Bob是接收者，而这一次窃听者Eve依然能够窃所到他们之间的通信内容。

在公非对称加密通信中，通信过程是由接收者Bob来启动的。

1. Bob生成一个包含公钥和私钥的密钥对。
    > 私钥由Bob自行妥善保管。

1. Bob将自己的公钥发送给Alicea
    > Bob的公钥被窃听者Eve截获也没关系。
    将公钥发送给Alice，表示Bob请Alice用这个公钥对消息进行加密并发送给他。

1. Alice用Bob的公钥对消息进行加密。
    > 加密后的消息只有用Bob的私钥才能够解密。
    虽然Alice拥有Bob的公钥，但用Bob的公钥是无法对密文进行解密的。

1. Alice将密文发送给Bobo
    > 密文被窃听者Eve截获也没关系。Eve可能拥有Bob的公钥，但是用Bob的公钥是无法进行解密的。

1. Bob用自己的私钥对密文进行解密。

![](http://qiniu.liulei.life/202208061603117.png)

窃听者Eve可能拥有Bob的公钥，但是Bob的公钥只是加密密钥，而不是解密密钥，因此窃听者Eve就无法完成解密操作。

# RSA

RSA是第一个比较完善的公开密钥算法，它既能用于加密，也能用于数字签名。RSA以它的三个发明者Ron Rivest, Adi Shamir, Leonard Adleman的名字首字母命名，这个算法经受住了多年深入的密码分析，虽然密码分析者既不能证明也不能否定RSA的安全性，但这恰恰说明该算法有一定的可信性，目前它已经成为最流行的公开密钥算法。

RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。 

RSA的公钥、私钥的组成，以及加密、解密的公式可见于下表：


![](http://qiniu.liulei.life/202208081048619.png)

下面是对RSA找那个数学概念的解释


## RSA中的数学概念

- 最大公约数
- 素数/质数
- 互质

### 最大公约数

公约数，也被称为“公因数”。它是一个能被若干个整数同时均整除的整数。如果一个整数同时是几个整数的约数，称这个整数为它们的“公约数”；

> 例如：30和40，它们的公约数有1，2，5，10，最大公约数是10。

### 素数

素数是这样的整数，它除了**能表示为它自己和1的乘积以外，不能表示为任何其它两个整数的乘积**。

> 例如，15＝3＊5，所以15不是素数；又如，12＝6＊2＝4＊3，所以12也不是素数。另一方面，13除了等于13＊1以外，不能表示为其它任何两个整数的乘积，所以13是一个素数。素数也称为“质数”。

### 什么是“互质数”（或“互素数”）？

小学数学教材对互质数是这样定义的：“公约数只有1的两个数，叫做互质数。”这里所说的“两个数”是指自然数。

判别方法主要有以下几种（不限于此）：

1. 两个质数一定是互质数。例如，2与7、13与19。
1. 一个质数如果不能整除另一个合数，这两个数为互质数。例如，3与10、5与 26。
1. 1不是质数也不是合数，它和任何一个自然数在一起都是互质数。如1和9908。
1. 相邻的两个自然数是互质数。如 15与 16。
1. 相邻的两个奇数是互质数。如 49与 51。
1. 大数是质数的两个数是互质数。如97与88。
1. 小数是质数，大数不是小数的倍数的两个数是互质数。如 7和 16。
1. 两个数都是合数（二数差又较大），小数所有的质因数，都不是大数的约数，这两个

数是互质数。如357与715，357=3×7×17，而3、7和17都不是715的约数，这两个数为互质数。等等。

### 指数运算

指数是幂运算aⁿ (a≠0)中的一个参数，a为底数，n为指数，指数位于底数的右上角，幂运算表示指数个底数相乘。. 当n是一个正整数，a ⁿ 表示n个a连乘。.

### 什么是模指数运算？


模指数运算就是先做指数运算，取其结果再做模运算。
如
> 5^3 mod 7 = 125 mod 7 = 6

## RSA算法

1. 选择一对不同的素数，`p, q`

1. 计算 `n = p * q`

1. 计算 `f(n) = (p - 1) * (q - 1)` 同时对p、q保密，不让任何人知道
    1. 采用欧拉ϕ函数， `ϕ(n) = ϕ(pq) = ϕ(p) * ϕ(q) = (p - 1) * (q -1)`

1. 计算一个与 `f(n)` 互质的 `e` ，并且 `1 < e < f(n)`
    
    1. 选择一个整数 e 与 ϕ(n) 互质，并且 e 小于 ϕ(n)

1. 计算 `de ≡ 1 mod f(n) `

    **注意**：≡ 是数论中 同余的符号。公式中，≡ 符号的左边必须和符号右边同余，也就是两边模运算结果相同。显而易见，不管f(n)取什么值，符号右边1 mod f(n)的结果都等于1；符号的左边d与e的乘积做模运算后的结果也必须等于1。这就需要计算出d的值，让这个同余等式能够成立。

    计算d公式 
    > `e * d = 1(mod(ϕ(n)))`
    d 就是 e 的 `mod(ϕ(n)) `逆元，应用扩展欧几里得算法
    

1. 公钥 `KU = (e, n)`，私钥 `KR = (d, n)`

1. 加密：先将明文变成 0 至 n-1 的一个整数 M ，如果明文较长可先分割为适当的组，然后进行加密。设密文为 C，过程为
    > C ≡ M^e (mod n)

1. 解密: 
    > M ≡ C^d (mod n)

### 示例

1. 计算公钥(e,n)和私钥(d,n)
    
    令 p = 3、q = 11

    f(n) = (p-1) * (q-1) = 2 * 10 = 20

    取e = 3 ，3 与 20 互质

    通过公式 `d ≡ e - 1 mod f(n)` 得出  `3 × d ≡ 1 mod 20`d怎样取值呢？可以用试算的办法来寻找。试算结果见下表：

    ![](http://qiniu.liulei.life/202208081438761.png)

    通过试算我们找到，当d=7时，`e×d≡1 mod f(n)` 同余等式成立。因此，可令d=7。从而我们可以设计出一对公私密钥，加密密钥（公钥）为：KU =(e,n)=(3,33)，解密密钥（私钥）为：KR =(d,n)=(7,33)。

1. 英文数字化

    将明文信息数字化，并将每块两个数字分组。假定明文英文字母编码表为按字母顺序排列数值，即：

    ![](http://qiniu.liulei.life/202208081439887.png)

    则得到分组后的key的明文信息为：11，05，25。

1. 明文加密

    用户加密密钥(3,33) 将数字化明文分组信息加密成密文。由 `C ≡ M^e (mod n)` 得：11、31、16

1. 密文解密

    密文通过  `M ≡ C^d (mod n)` 得出：11、05、25

    根据上面的编码表将其转换为英文，我们又得到了恢复后的原文“key”。

实际运用要比这复杂得多，由于RSA算法的公钥私钥的长度（模长度）要到1024位甚至2048位才能保证安全，因此，p、q、e的选取、公钥私钥的生成，加密解密模指数运算都有一定的计算程序，需要仰仗计算机高速完成。


## 为什么RSA密码难破解

在RSA密码应用中，公钥KU是被公开的，即e和n的数值可以被第三方窃听者得到。

破解RSA密码的问题就是从已知的e和n的数值（n等于pq），想法求出d的数值，这样就可以得到私钥来破解密文。

从上文中的公式：`d ≡ e-1 (mod((p-1)(q-1)))` 或 `de ≡ 1 (mod((p-1)(q-1)))` 我们可以看出。密码破解的实质问题是：从pq的数值，去求出(p-1)和(q-1)。换句话说，只要求出p和q的值，我们就能求出d的值而得到私钥。

当p和q是一个大素数的时候，从它们的积pq去分解因子p和q，这是一个公认的数学难题。比如当pq大到1024位时，迄今为止还没有人能够利用任何计算工具去完成分解因子的任务。因此，RSA从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。

然而，虽然RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性能如何。

此外，RSA的缺点还有：A)产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。B)分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。因此，使用RSA只能加密少量数据，大量的数据加密还要靠对称密码算法。

# ECC椭圆曲线加密

椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。

ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。

椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的

困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。

ECC 164位的密钥产生的一个安全级相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国 居民二代身份证 正在使用 256 位的椭圆曲线密码，虚拟货币 比特币 也选择ECC作为加密算法。


##  数学原理



不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。

椭圆曲线依赖的数学难题如下:

1. 选定特定的一条椭圆曲线 Eq(a,b)

1. 通过随机源得到一个正整数 k       - 私钥 private key

1. 在椭圆曲线上选择一个点 p(x, y)   - 基点 base point

1. 通过kp(x ,y) 得到一个点 q(x, y)  - 公钥 public key





在这个过程中，通过给定的 k 和 p ，根据 '加法法则' ，计算q很容易。

但是给定 q 和 p 但给定p 和 q 求k 非常困难。（在实际应用中，质数 p 取的非常大，使得穷举出 k 非常困难），下面会给出图解

注意：这里的加法运算，是椭圆曲线定义的加法运算


### 椭圆曲线的加法运算


首先先画出椭圆曲线

y^2 = x^3 + ax + b 其中 a、b为实数，且不等于 4a^3 + 27b^2 ≠ 0 (为了保证曲线不包含奇点)

![](http://qiniu.liulei.life/202208091624771.png)

基于该曲线，有以下两种情况

### 第一种情况A+B

![](http://qiniu.liulei.life/202208091626075.png)

假设有A、B两点，这两点构成一条直线，与曲线相交于第三点，第三点相对于x轴做对称点，即为 A+B = C点

### 第二种情况A+A

![](http://qiniu.liulei.life/202208091628741.png)

当给定的两个点都为点A时，我们基于A点做一条与椭圆相切的直线，该直线，与曲线相交于第二点，该点相对于x轴做对称点，即为 2A

那么如何计算3A呢？

由2A与A连线与曲线交点的对称点即为3A


### 第三种情况kA
在实际过程中我们计算公钥的时候可能重复k次。会非常消耗计算机资源，所以这里我们可以使用乘法交换律，来得到kA。

假设K = 8 ，首先计算2A，随后 (2A)4 = 8A，当然这里的乘法指的是椭圆曲线上的乘法，具体实现如下：

1. 首先计算2A 
1. 做2A与椭圆的切线，与曲线的焦点的对称点，即为4A
1. 如此循环下去，即可得到想要的点 8A




## 椭圆曲线为什么难以破解



![](http://qiniu.liulei.life/202208111004340.png)

如图所示A点经过三次运算，得到E。

![](http://qiniu.liulei.life/202208111005097.png)

起点为A终点为E，A经过多少次运算才能得到E，这里的多少次运算就是私钥。

这就很符合我们的想法，**加密简单，解密困难**

这种类型的函数叫做 `Trapdoor function` 活板门函数 - 单向函数。

在实际应用中，如果选择一个很简单的点，与私钥相乘，得到的公钥就会相对容易破解。所以对选择的点提出一些要求。这个要求就是把这条椭圆曲线定义在某个质数阶的有限域上。但是计算规则相同。
图示如下

![](http://qiniu.liulei.life/202208111516891.png)


在比特币中使用的是`secp256k1标准`。规定了使用椭圆曲线 系数，a,b 的具体值，以及阶数P的值，以及满足这些要求的基准点G的坐标。
在这个标准中规定`a = 0，b = 7`，方程及为 `y^2 = x^3 + 7`

**以下为数学概念解释：**

**域**
> 域是一个可以在其上进行加法、减法、乘法、除法运算，而结果不会超出域的集合。
如有理数集合、实数集合、负数集合都是域，但整数集合不是（使用除法得到的分数或者小数会超出整数集合）

**有限域**

1.  F域中包含有限个数元素，称之为`有限域`
1. 有限域中元素的个数称之为有限域的阶。
1. 每个有限域的阶，必维素数的幂，技有限域的阶可以表示为 p^n（p是素数，n是正整数）
1. 该有限域称为Galois 域(Galois Fields)，记为GF(p^n)


**有限域上的椭圆曲线**

1. 定义模p加法和模p乘法（加或者乘超过p时，模p取余数，p为素数）

1. 集合内的元素经过加法和乘法的计算，结果仍然在集合内

1. 计算符合交换律、结合律、分配率

1. 加法和乘法有单位元素（所有的集合内的值都有对应的负数，所有集合内非零值都有倒数）

## ECDHE 秘钥交换算法

![](http://qiniu.liulei.life/202209182155807.png)

1. Aclic拥有一对公私钥：Ka Pa

    Bob拥有一对对公私钥：Kb Pb

1. Alic可以将 Ka * Pb，而 Pb = Kb * G

    Bob可以将  Kb * Pa，而 Pa = Ka * G

1. 所以Alice 的式子可以写为 Ka * (Kb * G) 

    Bob 的式子可以写为       Kb * (Ka * G)

1. 通过乘法交换律我们可以判断这两个式子相等，即创造了一个只有 Alice 和 Bob 知道的密钥。




## ECDSA 椭圆曲线数字签名算法



