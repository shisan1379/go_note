
# 散列函数的设计

把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。

散列值一般用来查找记录，在记录的存储位置和它的关键码之间建立一个确定的对应关系H，使得每个关键码key和唯一的存储位置H(key)相对应。

存储记录时，根据这个对应关系找到关键码的映射地址，并按此地址存储该记录；查找记录时，根据这个对应关系找到待查找关键码的映射地址，并按此地址访问该记录。

采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表(hash table)，将关键码映射为散列表中适当存储位置的函数称为散列函数(hash function)，所得到的存储位置成为散列地址(hash address)。


## 设计原则

1. **计算简单**：散列函数不应该有很大的计算量，否则会降低查找效率

1. **函数值(散列地址)分布均匀**：希望散列函数能够把数据以相同的概率散列到所有的地址空间中，这样才能保证存储空间的有效利用，并减少冲突


## 三种常见的散列函数

1. 直接定址法

直接定址法就是关键码的线性代数：
```
H(key) = a * key + b (a、b为常数)
```

**例如：** 关键码集合为{10，30，50，70，80，90}，选取H(key) = key/10。则散列表如下图所示。

![](http://qiniu.liulei.life/202209261614130.png)


1. 除留余数法

除留余数法的基本思想是：选择某个适当的正整数P，以关键码除以 `p` 的余数作为散列地址，即： `H(key) = key mod p`

这个方法在于选择合适的 p，否则容易产生相同的地址。

例如：若 p 还有质因子， p = m * n，则所有含有 m或者 n 的关键码的散列地址，均为m 或 n 的倍数。显然这增加了冲突的机会，一般情况下，若散列表表长为m，通常 p 小于或者等于表长，最好接近 m 的最小素数或者不包含20质因子的合数。

3. 平方取中法

平方取中法地对关键码平方后，按照散列表大小，取中间若干位作为散列地址。其原理是一个数平方后，中间的几位分布较为均匀，从而发生的概率较小

例如：关键码 1234 ，假设散列地址是两位，由于 1234 * 1234 = 1522756，选取中间两位作为散列地址，22或27.

平方取中法通常用在事先不知道关键码的分区且关键码的位数不是很大的情况下。

## 处理碰撞的方法

两个不同的关键码产生同一个散列值的情况称之为 碰撞（collision），放发生碰撞时我们一般用以下方法解决


1. 开放定址法

**如果关键码得到的散列地址产生了碰撞，根据 (H(key) + d) % m 寻找下一个散列地址**


例：设关键码集合{47，7，29，11，16，92，22，8，3}，散列表表长为11，散列函数为H(key) = key mod 11，用开放定址法处理碰撞，得到的散列表如图所示，具体过程如下：

1. H(47)=3，H(7)=7，没有碰撞，直接存入；
1. H(29)=7，发生碰撞，(H(29)+1)%11=8，散列地址8为空，将29存入；
1. H(11)=0，H(16)=5，H(92)=4，没有碰撞，直接存入；
1. H(22)=0，发生碰撞，(H(22)+1)%11=1，散列地址1为空，将22存入；
1. H(8)=8，发生碰撞，(H(8)+1)%11=9，散列地址9为空，将8存入；
1. H(3)=3，发生碰撞，(H(3)+1)%11=4，仍然碰撞，(H(3)+2)%11=5，仍然碰撞， (H(3)+3)%11=6，散列地址6为空，将3存入


![](http://qiniu.liulei.life/202209261652906.png)

1. 拉链法

将所有散列地址相同的记录，存储在一个链表中，称之为同义词子表(synonym table) ，将散列表中存储的事所有同义词字表的头指针


# 散列函数的应用

1. 防止篡改

    > 很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。

1. 消息认证：

    > 消息认证码是将“发送者和接收者之间的**共享密钥**”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。

1. 数字签名：

    > 数字签名是现实社会中的签名(sign)和盖章这样的行为，在数字世界中的实现。数字签名一般非常耗时，所以一般不会对消息内容直接施加签名，而是对消息的散列值施加签名

1. 伪随机数生成器

    > 密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。

1. 一次性口令

    > 一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取口令，也无法使用。


# 常用的单向散列函

## MD4、MD5

> MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。

> MD5是由Rwest于1991年设计的单项散列函数，能够产生128比特的散列值（RFC1321）。<br>
MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已
经不安全了。


> MD4和MD5中的MD是消息摘要（Message Digest）的缩写。


## go使用MD5

### 第一种方式

```go
func getMD5(str []byte) string {
	//1. 计算数据的MD5
	result := md5.Sum(str)

	fmt.Println(result)
	//以16进制打印
	fmt.Printf("%x\n", result)

	//2. 将数据格式化为16进制字符串
	res := hex.EncodeToString(result[:])

	fmt.Println("res: ", res)

	return res

}

func main() {

	getMD5([]byte("123"))

}
```
输出
```
[32 44 185 98 172 89 7 91 150 75 7 21 45 35 75 112]
202cb962ac59075b964b07152d234b70
res:  202cb962ac59075b964b07152d234b70
```

### 第二种方式

```go
func getMD5_2(str []byte) string  {
	//1. 创建一个使用MD5校验的hash对象
	myHash := md5.New()

	//2. 通过IO操作将数据写入hash对象中
	io.WriteString(myHash,"hello")
	//io.WriteString(myHash, ", world") == myHash.Write([]byte(", world"))
	myHash.Write([]byte(", world"))

	//3. 计算结果
	result :=myHash.Sum(nil)

	fmt.Println(result)

	//以16进制打印
	fmt.Printf("%x\n", result)

	//2. 将数据格式化为16进制字符串
	res := hex.EncodeToString(result[:])

	fmt.Println("res: ", res)

	return res
}
func main() {

	getMD5_2([]byte("123"))

}
```

输出
```
[228 215 241 180 237 46 66 209 88 152 244 178 123 1 157 164]
e4d7f1b4ed2e42d15898f4b27b019da4
res:  e4d7f1b4ed2e42d15898f4b27b019da4
```

函数说明

Hash是一个被所有hash函数实现的公共接口。
```go
type Hash interface {

    // 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误
    io.Writer

    // 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态
    Sum(b []byte) []byte

    // 重设hash为无数据输入的状态
    Reset()

    // 返回Sum会返回的切片的长度
    Size() int

    // 返回hash底层的块大小；Write方法可以接受任何大小的数据，
    // 但提供的数据是块大小的倍数时效率更高
    BlockSize() int
}
```


## SHA-1、SHA-224、SHA-256、SHA-384、SHA-512

> SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。<br>
SHA-1的消息长度存在上限，但这个值接近于2^64比特，是个非常巨大的数值，因此在实际应用中没有问题。<br>
SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64 比特，SHA-384 和 SHA-512的上限接近于 2^128 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。


|         | 比特数 | 字节数 |
| ------- | :----: | :----: |
| MD4     | 128bit | 16byte |
| MD5     | 128bit | 16byte |
| SHA-1   | 160bit | 20byte |
| SHA-224 | 224bit | 28byte |
| SHA-256 | 256bit | 32byte |
| SHA-384 | 384bit | 48byte |
| SHA-512 | 512bit | 64byte |


## go使用sha256

```go
func getSha256(str []byte) string {

	myHash := sha256.New()
	myHash.Write(str)
	result := myHash.Sum(nil)

	fmt.Printf("      %x\n", result)

	return hex.EncodeToString(result[:])
}

func main() {
	s := getSha256([]byte("123"))
	fmt.Println("res: ",s)
}
```
输出
```
      a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3
res:  a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3
```