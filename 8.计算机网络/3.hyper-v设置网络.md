

# 要求

1. 能够访问外网
2. 宿主机开启VPN时能够影响到，虚拟机
3. 虚拟机能够固定IP



# 实现


1. `虚拟交换机` 设置如下

    ![alt text](image-152.png)

    1. 首选有一个默认的 `Default Switch`
    2. 然后创建一个内部虚拟机 `net`
    
2. 设置虚拟机的网络适配器

   ![alt text](image-154.png)

   按照顺序设置/添加网络适配器， 
   1. `Default Switch`  
   2. `net`


2. 在主机端设置虚拟网卡 `net` 的IP地址
    `192.168.4.1`
    ![alt text](image-153.png)
3. 在主机端设置 nat
 
    
    ```bash
    New-NetNat -Name HyperVNat -InternalIPInterfaceAddressPrefix 192.168.4.0/24
    ```
    获取当前机器 NAT
    ```bash
    GET-NETNAT
    ```

4. 虚拟机端设置 `静态IP`
    因为我们是按照上面的顺序设置的网络适配器，所以 eth1 对应的是 `net` 适配器
   ![alt text](image-155.png)

   上面的 nat 的网络号为 `192.168.4.0/24` 所以ip按照其进行分配，网关因为上面的虚拟网卡设置的为 `192.168.4.1`，所以网关也设置为 `192.168.4.1`
    ![alt text](image-156.png)
6. 验证-宿主机不使用VPN
   ![alt text](image-157.png)
7. 验证-宿主机使用VPN
   ![alt text](image-158.png)
8. 宿主机连接虚拟机ssh
   ![alt text](image-159.png)





# hyper-v linux 扩展硬盘

1. 在 hyper-v 扩展硬盘
2. 登录vm-linux
   ```bash
   sudo parted /dev/sda
   ```
   输入 print  命令获取当前硬盘信息

   输入 `resizepart 1` 调整分区大小，随后按照提示输入

   最后 输入`quit` 退出

3. ext4 文件系统：使用 resize2fs 命令，使得分区生效
   ```bash
   sudo resize2fs /dev/sda1
   ```
4. XFS 文件系统：使用 xfs_growfs 命令，例如：
   ```bash
   sudo xfs_growfs /dev/sda1
   ```
5. 使用 df -h 或 lsblk 命令查看分区大小是否已成功调整：
   ```bash
    df -h /dev/sda1
    lsblk /dev/sda
   ```

# 设置k8s 中的pod 通过 nat访问网络


## 第一步：设置宿主机

```bash
# 填入从虚拟机查询到的NAT网关IP（例如192.168.4.1）
$NatGatewayIp = "192.168.4.1"  
$PodCidr = "10.244.0.0/16"  # 你的Pod网段（已确认）
$NatInterfaceName = "vEthernet (NAT)"  # 宿主机NAT网卡名称

# 1. 启用宿主机IP转发
#    启用指定网络接口的IP转发功能。这相当于将宿主机变成一个路由器，使其能够将从一个网络接口收到的数据包转发到另一个接口
Set-NetIPInterface -InterfaceAlias $NatInterfaceName -Forwarding Enabled

# 2. 添加Pod网段静态路由（永久生效） - 
#    告诉宿主机：所有要发送到 10.244.0.0/16这个Pod网段的数据包，都先发给网关 。-p参数确保此路由规则在系统重启后依然有效（永久路由）
route add 10.244.0.0 mask 255.255.0.0 $NatGatewayIp -p

# 3. 配置防火墙允许Pod网段流量
#    创建两条新的Windows防火墙规则，允许入站和出站方向的所有协议数据包与Pod网段（10.244.0.0/16）自由通信，确保网络流量不会被防火墙阻断
New-NetFirewallRule -DisplayName "Allow K8s Pod NAT" -Direction Inbound -Protocol Any -RemoteAddress 10.244.0.0/16 -Action Allow
New-NetFirewallRule -DisplayName "Allow K8s Pod NAT" -Direction Outbound -Protocol Any -RemoteAddress 10.244.0.0/16 -Action Allow
```






## 查看 pod 网段方式
查看Calico的IP池（IPPool）配置：Calico通过IPPool资源来定义Pod可用的IP地址范围。使用以下命令查看现有IP池：
```bash
root@master:/home/what01# kubectl get ippool -o yaml
apiVersion: v1
items:
- apiVersion: crd.projectcalico.org/v1
  kind: IPPool
  metadata:
    annotations:
      projectcalico.org/metadata: '{"uid":"9f7d89aa-21a2-42f4-8d9d-740e9c8097e1","creationTimestamp":"2025-07-25T08:12:15Z"}'
    creationTimestamp: "2025-07-25T08:12:15Z"
    generation: 1
    name: default-ipv4-ippool
    resourceVersion: "2602"
    uid: 79b01286-41c6-417f-8e0f-7eb1e26b7fdb
  spec:
    allowedUses:
    - Workload
    - Tunnel
    blockSize: 26
    cidr: 10.244.0.0/16
    ipipMode: Always
    natOutgoing: true
    nodeSelector: all()
    vxlanMode: Never
kind: List
metadata:
  resourceVersion: ""

```


## 第二步：验证宿主机设置是否正确


检查路由是否存在（应显示 10.244.0.0 指向你的网关）
```bash
route print | findstr "10.244"
   10.244.0.0      255.255.0.0      192.168.4.1       1
```

若之前配置过错误的路由，在 PowerShell 中删除：
```bash
route delete 10.244.0.0
```
手动重建路由（同上）
```bash
# 确保网关 IP 是你的虚拟机 NAT 网关（192.168.4.1）
route add 10.244.0.0 mask 255.255.0.0 192.168.4.1 -p
```


```bash
# 检查 IP 转发是否开启（应显示 "Enabled"）
Get-NetIPInterface -InterfaceAlias "vEthernet (NAT)" | Select-Object InterfaceAlias, Forwarding
```




补充检查：确保路由关联到正确网卡
1. 在 PowerShell 中查看宿主机网卡列表，找到 NAT 网卡的索引（Interface Index）：
   ```bash
   Get-NetAdapter | Where-Object { $_.Name -like "vEthernet (NAT)" } | Select-Object Name, InterfaceIndex
   ```
   假设输出 InterfaceIndex: 3（示例）。

2. 若路由未关联到 NAT 网卡，可指定网卡索引重建路由：
   ```bash
   # 替换 3 为你的 NAT 网卡 InterfaceIndex
   route add 10.244.0.0 mask 255.255.0.0 192.168.4.1 if 3 -p
   ```


## 第三步：修正 conredns 设置

查看dns设置
```bash
kubectl get configmap coredns -n kube-system -o yaml

apiVersion: v1
data:
  Corefile: |
    .:53 {
        errors
        health {
           lameduck 5s
        }
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
           ttl 30
        }
        prometheus :9153
        forward . 8.8.8.8 114.114.114.114 223.5.5.5  {
           max_concurrent 1000
        }
        cache 30
        loop
        reload
        loadbalance
    }
kind: ConfigMap
metadata:
  creationTimestamp: "2025-07-25T07:49:20Z"
  name: coredns
  namespace: kube-system
  resourceVersion: "4511645"
  uid: df6e0c55-0883-4608-91e2-3314a4ff9d4e
```

在 forward 字段部分设置外部 dns 
```bash
# 编辑配置（按i修改，Esc+:wq保存）
kubectl edit configmap coredns -n kube-system
# 重启coredns使配置生效
kubectl rollout restart deployment coredns -n kube-system
```



## 第四步：设置calico

```bash
# 1. 确认 Calico 节点 Pod 正常运行
kubectl get pods -n kube-system | grep calico-node

# 2. 查看 Calico 的 NAT 规则是否生效（在节点上执行）
sudo iptables -t nat -L POSTROUTING | grep 10.244
# 正常应显示类似规则（将 Pod 网段 10.244.0.0/16 转换为节点 IP）：
# MASQUERADE  all  --  10.244.0.0/16      0.0.0.0/0
# 或者不进行过滤
sudo iptables -t nat -L POSTROUTING
# 正常应该显示,
# 第一行：明确该规则由 Kubernetes 的网络组件（kube-proxy）自动生成，用于处理 K8s 集群的 POSTROUTING 层面网络规则，例如 Service 的 SNAT、Pod 访问外部网络的地址转换等。
# 第二行：Calico 通过该子链实现 Pod 间通信的地址转换、跨节点 Pod 通信的 SNAT/DNAT、网络策略的地址转换规则等。
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
KUBE-POSTROUTING  all  --  anywhere             anywhere             /* kubernetes postrouting rules */
cali-POSTROUTING  all  --  anywhere             anywhere             /* cali:0i8pjzKKPyA34aQD */





# 3. 若缺少 NAT 规则，重启 Calico 节点
kubectl rollout restart daemonset calico-node -n kube-system
```


如果还没有规则则查看日志
```bash
# 替换 <calico-pod-name> 为实际的 calico-node Pod 名称
kubectl logs -n kube-system <calico-pod-name> -c calico-node | grep -i "nat"
```

## 第五步：如果继续没有规则则临时添加NAT规则

若上述步骤仍无法生成规则，可手动添加 iptables 规则验证（重启节点后失效，但能快速确认问题）：
```bash
# 在所有 K8s 节点执行（替换 192.168.4.101 为节点自身 IP）
sudo iptables -t nat -A POSTROUTING -s 10.244.0.0/16 ! -d 10.244.0.0/16 -j MASQUERADE --to-source 192.168.4.101

# 验证规则是否添加成功
sudo iptables -t nat -L POSTROUTING | grep "10.244.0.0/16"
# 应显示类似：MASQUERADE  all  --  10.244.0.0/16    !10.244.0.0/16    ...
```


## 第六步：如果第五步成功，那么则检查日志有可能 ipset/ipadm 等工具与内核不兼容

```bash
# 检查 nat相关日志
kubectl logs -n kube-system coredns-5f9d769dd7-9xvfg -f | grep nat
# 或者检查 错误日志
kubectl logs -n kube-system coredns-5f9d769dd7-9xvfg -f | grep Error
```


之后进一步分析



## 最后验证访问

```bash
kubectl run test-net --image=busybox:1.35 --rm -it -- sh
/ # ping 8.8.8.8 -c 4
```