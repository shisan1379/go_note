

# 非编码类规范

## 开源规范

首先要说明的是，只有开源项目才会用到开源协议，如果你的项目不准备开源，就用不到
开源协议。但先了解一下总是没错的，以后总能用得上。
业界有上百种开源协议，每种开源协议的要求不一样，有的协议对使用条件要求比较苛
刻，有的则相对比较宽松。我们没必要全都记住，只需要知道经常使用的 6 种开源协议，
也就是 GPL、MPL、LGPL、Apache、BSD 和 MIT 就可以了。


那具体如何选择适合自己的开源协议呢？你可以参考乌克兰程序员 Paul Bagwell 画的这张图：
![alt text](image.png)


1. 第一，开源项目，应该有一个高的单元覆盖率。这样，一方面可以确保第三方开发者在开发完代码之后，能够很方便地对整个项目做详细的单元测试，另一方面也能保证提交代码的质量。
   
1. 第二，要确保整个代码库和提交记录中，不能出现内部 IP、内部域名、密码、密钥这类信息。否则，就会造成敏感信息外漏，可能会对我们的内部业务造成安全隐患。

1. 第三，当我们的开源项目被别的开发者提交 pull request、issue、评论时，要及时处理，一方面可以确保项目不断被更新，另一方面也可以激发其他开发者贡献代码的积极性。
   
2. 第四，好的开源项目，应该能够持续地更新功能，修复 Bug。对于一些已经结项、不维护的开源项目，需要及时地对项目进行归档，并在项目描述中加以说明。

## 文档规范

### README 规范
README 文档是项目的门面，它是开发者学习项目时第一个阅读的文档，会放在项目的根
目录下。因为它主要是用来介绍项目的功能、安装、部署和使用的，所以它是可以规范化
的。
下面，我们直接通过一个 README 模板，来看一下 README 规范中的内容：
```html
# 项目名称
<!-- 写一段简短的话描述项目 -->

## 功能特性
<!-- 描述该项目的核心功能点 -->

## 软件架构(可选)
<!-- 可以描述下项目的架构 -->


## 快速开始

### 依赖检查
<!-- 描述该项目的依赖，比如依赖的包、工具或者其他任何依赖项 -->

### 构建
<!-- 描述如何构建该项目 -->

### 运行
<!-- 描述如何运行该项目 -->

## 使用指南
<!-- 描述如何使用该项目 -->

## 如何贡献
<!-- 告诉其他开发者如果给该项目贡献源码 -->

## 社区(可选)
<!-- 如果有需要可以介绍一些社区相关的内容 -->

## 关于作者
<!-- 这里写上项目作者 -->

## 谁在用(可选)
<!-- 可以列出使用本项目的其他有影响力的项目，算是给项目打个广告吧 -->

## 许可证
<!-- 这里链接上该项目的开源许可证 -->
```
### 项目文档规范

项目文档包括一切需要文档化的内容，它们通常集中放在 /docs 目录下。当我们在创建团队的项目文档时，通常会预先规划并创建好一些目录，用来存放不同的文档。因此，在开始 Go 项目开发之前，我们也要制定一个软件文档规范。好的文档规范有 2 个优点：易读和可以快速定位文档。

不同项目有不同的文档需求，在制定文档规范时，你可以考虑包含两类文档。为了方便全球开发者和用户使用，开发文档和用户文档，可以预先规划好英文和中文 2 个版本。为了加深你的理解，这里我们来看下实战项目的文档目录结构：


- 开发文档：用来说明该项目的开发流程，比如如何搭建开发环境、构建二进制文件、测试、部署等。

- 用户文档：软件的使用文档，对象一般是软件的使用者，内容可根据需要添加。比如，可以包括 API 文档、SDK 文档、安装文档、功能介绍文档、最佳实践、操作指南、常见问题等。

```
docs
│── devel
│ ├── en-US/                # 英文版文档，可以根据需要组织文件结构
│ └── zh-CN                 # 中文版文档，可以根据需要组织文件结构
│ └── development.md        # 开发手册，可以说明如何编译、构建、运行项目
├── guide                   # 用户文档
│ ├── en-US/                # 英文版文档，可以根据需要组织文件结构
│ └── zh-CN                 # 中文版文档，可以根据需要组织文件结构
│ ├── api/                  # API文档
│ ├── best-practice         # 最佳实践，存放一些比较重要的实践文章
│ │ └── authorization.md
│ ├── faq                   # 常见问题
│ │ ├── iam-apiserver
│ │ └── installation
│ ├── installation          # 安装文档
│ │ └── installation.md
│ ├── introduction/         # 产品介绍文档
│ ├── operation-guide       # 操作指南，里面可以根据RESTful资源再划分为更细的
│ │ ├── policy.md
│ │ ├── secret.md
│ │ └── user.md
│ ├── quickstart            # 快速入门
│ │ └── quickstart.md
│ ├── README.md             # 用户文档入口文件
│ └── sdk                   # SDK文档
│ └── golang.md
└── images                  # 图片存放目录
└── 部署架构v1.png
```

### API 接口文档规范
![alt text](image-1.png)

一个规范的 API 接口文档，通常需要包含:
1. 一个完整的 API 接口介绍文档 - API 接口使用文档中需要包含接口描述、请求方法、请求参数、输出参数和请求示例。
2. API 接口变更历史文档
3. 通用说明
4. 数据结构说明
5. 错误码描述和 API 接口使用文档。




以Markdown 为例接口文档拆分为以下几个 Markdown 文件，并存放在目录 docs/guide/zh-CN/api中：


- `README.md` ：API 接口介绍文档，会分类介绍 IAM 支持的 API 接口，并会存放相关 API 接口文档的链接，方便开发者查看。

- `CHANGELOG.md` ：API 接口文档变更历史，方便进行历史回溯，也可以使调用者决定是否进行功能更新和版本更新。

- `generic.md` ：用来说明通用的请求参数、返回参数、认证方法和请求方法等。
  
- `struct.md` ：用来列出接口文档中使用的数据结构。这些数据结构可能被多个 API 接口使用，会在 `user.md`、`secret.md`、`policy.md` 文件中被引用。

- `user.md` 、 `secret.md` 、 `policy.md` ：API 接口文档，相同 REST 资源的接口会存放在一个文件中，以 REST 资源名命名文档名。

- `error_code.md` ：错误码描述，通过程序自动生成。

这里我拿 user.md 接口文档为例，和你解释下接口文档是如何写的。user.md 文件记录
了用户相关的接口，每个接口按顺序排列，包含如下 5 部分。

- **接口描述**：描述接口实现了什么功能。
- **请求方法**：接口的请求方法，格式为 HTTP 方法 请求路径，例如 POST /v1/users。在 通用说明中的请求方法部分，会说明接口的请求协议和请求地址。
  
- **输入参数**：接口的输入字段，它又分为 Header 参数、Query 参数、Body 参数、Path参数。每个字段通过：`参数名称`、`必选`、`类型` 和 `描述` 4 个属性来描述。如果参数有限制或者默认值，可以在描述部分注明。
  
- **输出参数**：接口的返回字段，每个字段通过 `参数名称`、`类型` 和 `描述` 3 个属性来描述。
  
- **请求示例**：一个真实的 API 接口请求和返回示例




## 版本规范

在做 Go 项目开发时，我建议你把所有组件都加入版本机制。原因主要有两个：
- 一是通过版本号，我们可以很明确地知道组件是哪个版本，从而定位到该组件的功能和代码，方便我们定位问题。
- 二是发布组件时携带版本号，可以让使用者知道目前的项目进度，以及使用版本和上一个版本的功能差别等。


目前业界主流的版本规范是语义化版本规范，也是 IAM 系统采用的版本规范。

### 那什么是语义化版本规范呢？


语义化版本规范（SemVer，Semantic Versioning）是 GitHub 起草的一个具有指导意义的、统一的版本号表示规范。它规定了版本号的表示、增加和比较方式，以及不同版本号代表的含义。

在这套规范下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。语义化版本格式为：*主版本号.次版本号.修订号（X.Y.Z）*，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。

版本号可按以下规则递增：

- 主版本号（MAJOR）：当做了不兼容的 API 修改。
  
- 次版本号（MINOR）：当做了向下兼容的功能性新增及修改。这里有个不成文的约定需要你注意，偶数为稳定版本，奇数为开发版本。
  
- 修订号（PATCH）：当做了向下兼容的问题修正。

例如，v1.2.3 是一个语义化版本号，版本号中每个数字的具体含义见下图：
![alt text](image-2.png)


你可能还看过这么一种版本号：*v1.2.3-alpha*。这其实是把先行版本号（Pre-release）和版本编译元数据，作为延伸加到了主版本号.次版本号.修订号的后面，格式为 X.Y.Z[-先行版本号][+版本编译元数据]，如下图所示：


![alt text](image-3.png)


先行版本号意味着，该版本不稳定，可能存在兼容性问题，格式为：X.Y.Z-[一连串以句点分隔的标识符] ，比如下面这几个例子：
```
1.0.0-alpha
1.0.0-alpha.1
1.0.0-0.3.7
1.0.0-x.7.z.92
```
编译版本号，一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制。下面是一些编译版本号的示例：
```
1.0.0-alpha+001
1.0.0+20130313144700
1.0.0-beta+exp.sha.5114f85
```

### 如何确定版本号？
- 第一，在实际开发的时候，我建议你使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号。
  
- 第二，当我们的版本是一个稳定的版本，并且第一次对外发布时，版本号可以定为 1.0.0。
- 
- 第三，当我们严格按照 Angular commit message 规范提交代码时，版本号可以这么来确定：
    - fix 类型的 commit 可以将修订号 +1。
    - feat 类型的 commit 可以将次版本号 +1。
    - 带有 BREAKING CHANGE 的 commit 可以将主版本号 +1。



## Commit规范


使用git查找日志:
基于这些 Commit Message 进行过滤查找，比如只查找某个版本新增的功能：
```bash
git log --oneline --grep "^feat|^fix|^perf"。
```


```

<type>([optional scope]): <description>
// 空行
[optional body]
// 空行
[optional footer(s)]
```
示例

![alt text](image-4.png)


Header 部分只有一行，包括三个字段：type（必选）、scope（可选）和 subject（必选）。


**type**

![alt text](image-5.png)
有这么多 type，我们该如何确定一个 commit 所属的 type 呢？这里我们可以通过下面这张图来确定

![alt text](image-6.png)

**scope**

scope 是用来说明 commit 的影响范围的，它必须是名词。显然，不同项目会有不同的scope。在项目初期，我们可以设置一些粒度比较大的 scope，比如可以按组件名或者功能来设置 scope；后续，如果项目有变动或者有新功能，我们可以再用追加的方式添加新的 scope。

**subject**


subject 是 commit 的简短描述，必须以动词开头、使用现在时。比如，我们可以用change，却不能用 changed 或 changes，而且这个动词的第一个字母必须是小写。通过这个动词，我们可以明确地知道 commit 所执行的操作。此外我们还要注意，subject 的结尾不能加英文句号。

**Body**

Body 部分可以分成多行，而且格式也比较自由。不过，和 Header 里的一样，它也要以动词开头，使用现在时。此外，它还必须要包括修改的动机，以及和跟上一版本相比的改动点。

**Footer**



### 提交频率

一种情况是，只要我对项目进行了修改，一通过测试就立即 commit。比如修复完一个 bug、开发完一个小功能，或者开发完一个完整的功能，测试通过后就提交。

另一种情况是，我们规定一个时间，定期提交。这里我建议代码下班前固定提交一次，并且要确保本地未提交的代码，延期不超过 1 天。这样，如果本地代码丢失，可以尽可能减少丢失的代码量。


按照上面 2 种方式提交代码，你可能会觉得代码 commit 比较多，看起来比较随意。或者说，我们想等开发完一个完整的功能之后，放在一个 commit 中一起提交。这时候，我们可以在最后合并代码或者提交 Pull Request 前，执行 git rebase -i 合并之前的所有commit。


那么如何合并 commit 呢？接下来，我来详细说说。


### 合并提交

合并提交，就是将多个 commit 合并为一个 commit 提交。这里，我建议你把新的commit 合并到主干时，只保留 2~3 个 commit 记录。那具体怎么做呢？


在 Git 中，我们主要使用 git rebase 命令来合并。git rebase 也是我们日后开发需要经常使用的一个命令，所以我们一定要掌握好它的使用方法

**git rebase 命令介绍**


> git rebase 的最大作用是它可以重写历史。

我们通常会通过 git rebase -i <commit ID>使用 git rebase 命令，-i 参数表示交互（interactive），该命令会进入到一个交互界面中，其实就是 Vim 编辑器。在该界面中，我们可以对里面的 commit 做一些操作，交互界面如图所示：

![alt text](image-7.png)
```bash
```





## 发布规范



# 编码类规范


## 目录规范

## 代码规范

## 接口规范

## 日志规范
## 错误码规范