# 32位与64位

32位与64位都包含，软件、操作系统、CPU



# 图灵机的构造

图灵机在计算机科学方面有两个巨大的贡献：

- 第一，它清楚地定义了**计算机能力的边界，也就是可计算理论**；

- 第二，它定义了**计算机由哪些部分组成，程序又是如何执行的**。

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410103905.png)


1. 图灵机拥有一条无限长的纸带，纸带上是一个个格子，格子中可以写字符，可以把纸带看作是内存，这些字符就是内存中的数据或者程序

1. 图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符

1. 读写头上的盒子是一些精密零件，包括，图灵机的存储、控制单元和运算单元


# 图灵机如何执行程序

下面我们来举一个例子，让大家弄清楚图灵机是如何工作的，比如我们要计算 11 + 15 的值，具体的运算步骤如下：

- 首先，我们将“11、15、+” 分别写入纸带上的 3 个格子（现在纸带上的字符串是11、15、 +)，然后将读写头先停在 11 对应的格子上。

    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121226.png)

- 接下来，图灵机通过读写头读入 11 到它的存储设备中（这个存储设备也叫作图灵机的状态）。图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点。


    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121251.png)

- 然后读写头向右移动一个格，用同样的方法将 15 读入图灵机的状态中。现在图灵机的状态中有两个连续的数字，11 和 15。
    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121316.png)

- 接下来重复上面的过程，会读到一个+号。下面我详细说一下这个运算流程：

    - 读写头读到一个 + 号 ；

    - 然后将 + 号传输给控制单元 ；

    - 控制单元发现是一个 + 号，所以没有存入状态中。因为 + 号是一个我们预设的控制符（指令），它的作用是加和目前状态。因此，控制单元识别出是控制符，并通知运算单元工作；

    - 运算单元从状态中读入 11、15 并进行计算，将结果 26 存储到状态；

    - 运算单元将结果回传给控制单元；

    - 控制单元将结果传输给读写头。

    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121356.png)

    - 读写头向右移动，将结果 26 写入纸带。

    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121416.png)

这样，我们就通过图灵机计算出了 11+15 的值。不知道你有没有发现，图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计和我们今天的计算机是一样的。

图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。

# 冯诺依曼模型


![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410121513.png)


具体的实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出的。报告遵循了图灵机的设计，并提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：

- 输入设备
- 输出设备
- 内存
- 中央处理器
- 总线


## 内存

在冯诺依曼模型中，程序和数据被存储在一个被称作内存的**线性排列存储区域**中。

存储数据单位是二进制位：bit，最小的存储单位是字节，8位。内存地址从0开始编号，依次自增排列。

内存都是随机存取器，也就是读取任何一个地址数据的速度都是一样的，写入任何一个地址的速度也是一样的。


## CPU
CPU 和内存以及其他设备之间，也需要通信，这种设备叫做总线。总线分为三种：

- **地址总线**：专门指定 CPU 要操作的内存地址
- **数据总线**：用来读写内存中的数据
当CPU 需要读写内存时，首先通过地址总线指定内存地址，再通过数据总线来传输数据

- **控制总线**：用来收发关键信号，例如： 中断信号 、 设备复位 、 就绪信号等


## 输入、输出设备

输入设备向计算机输入数据，经过计算机计算，将结果通过输出设备传达给外界。


# 线路位宽问题

数据如何通过线路传递。其实是通过电压操作，低电压是 `0` 、高电压是 `1`。

如果只有一条线路，每次只能传递一个信号 `0` 或者 `1` 。

一个 bit 一个 bit 的发送的方式，叫做串行。 如果需要每次多传送一些数据，就需要增加线路，也就是并行。

一条地址总线，就只能表示 0 或 1，只能操作两个内存地址， 如果有 10 条 那就能表示 2^10 个地址。通常在32位计算机上，使用了 32条，地址总线 ，也就能操作 2^32 个地址 ， 也就是 4G 内存。


# 64位和32位的计算


32位宽的 CPU 最多能操作 **32位宽的地址总线和数据总线**。

如果32位的CPU，要计算 64 位 的数字, 必须将64位数，拆分为两个32位数进行计算。而64位的CPU一次可以读入 64位数，同时 CPU 内部的逻辑运算单元也支持64位计算。但这并不代表 64位CPU 就比32位的CPU 性能高出很多。


# 程序的执行过程

1. 首先，CPU 读取 PC 指针指向的指令，将它导入指令寄存器

    1. CPU 读取 PC 指针指向的指令，将它导入指令寄存器，也就是把PC 指针的值拷贝到地址总线中
    1. CPU 通知内存设备准备数据（如果内存设备准备好了，就通过数据总线传送给CPU）
    1. CPU 收到内存传来的数据后，将这个数据存入指令寄存器

1. CPU 分析指令寄存器中的指令，确定指令的类型和参数
1. 如果是计算指令，那么就交给，逻辑运算单元计算，如果是存储类型的指令，就由控制单元执行

1. PC 指针自增，并准备获取下一条指令

    > 如果在32位机器上，指令是 4字节 ,那么 PC 指针就会自增 4 

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410210541.png)



PC 也是一个寄存器，64位CPU 会提供64位的寄存器.

> 64位的CPU 一般配套工作的地址总线只有40条，那么可寻址的范围就只有 1T ，也就是 2 的 40 次方

> 从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作CPU 的 **指令周期** 

## 详解 a = 11 + 15 的过程

程序员写的程序a=11+15是字符串，CPU 不能执行字符串，只能执行指令。所以这里需要用到一种特殊的程序——编译器。编译器的核心能力是翻译，它把一种程序翻译成另一种程序语言。

这里，我们需要编译器将程序员写的程序翻译成 CPU 认识的指令（指令我们认为是一种低级语言，我们平时书写的是高级语言）。

1. 编译器通过分析，发现 11 和 15 是数据，因此编译好的程序启动时，会在内存中开辟出一个专门的区域存这样的常数，这个专门用来存储常数的区域，就是数据段，如下图所示：

    - 11 被存储到了地址 0x100；
    - 15 被存储到了地址 0x104；

    ![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410211333.png)

2. 编译器将 `a=11+15` 转换成了 4 条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。如上图所示，这 4 条指令被存储到了 0x200-0x20c 的区域中：

    1. 0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；

    1. 0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；

    1. 0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；

    1. 0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。

3.具体执行的时候，PC 指针先指向 0x200 位置，然后依次执行这 4 条指令。

这里还有几个问题要说明一下：

1. 变量 a 实际上是内存中的一个地址，a 是给程序员的助记符。

1. 为什么 0x200 中代表加载数据到寄存器的指令是 0x8c000100。

在上面的例子中，我们每次操作 4 个地址，也就是 32 位，这是因为我们在用 32 位宽的 CPU 举例。在 32 位宽的 CPU 中，指令也是 32 位的。但是数据可以小于 32 位，比如可以加和两个 8 位的字节。


# 指令

上面的例子中：load 指令将内存中的数据导入寄存器，我们写成了16进制： 0x8c000100，拆分成二进制就是：

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410211958.png)

- 最左边的6位，叫做 **操作码** - opCode ， `100011` 代表 `load` 指令

- 中间的 4 位 0000 是寄存器的编号，这里代表寄存器 `R0`

- 后面的 22位 代表要读取的地址 0x100 

指令 = 操作码 + 寄存器编号 + 要操作的地址 

再来看求加法运算的 `add` 指令，16进制表示： 0x08048000

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410213032.png)

add指令(000010) + 寄存器R0(0000) + 寄存器R1(0001) + 寄存器R2(0010) + 14位未使用

该指令表示，将 R0 与 R1 的值相加 存储到 R2 


## 指令周期

构造指令的过程叫做**指令的编码**，通常由编译器完成，解析指令的过程叫做**指令的解码**，由 CPU 完成。由此可见 CPU 内部有一个循环

1. 首先CPU 通过 PC 指针，读取对应内存地址的指令，这个步骤叫做 `Fetch`  就是获取的意思
1. 其次 CPU 对指令解码 - Decode
1. 然后 CPU 执行指令 - Execution
1. 最后 CPU 将结果存回寄存器，或者将寄存器的值存入内存，这个步骤叫做 Store

![](https://raw.githubusercontent.com/shisan1379/img/main/img/20240410214430.png)

这四个步骤 叫做 **CPU 的指令周期**，CPU 的工作就是一个周期接着一个周期，周而复始

## 指令的类型

根据上面的例子，不同类型的 操作码，参数个数，每个参数的位宽都不一样，参数可以是下面这三种类型

- 寄存器
- 内存地址
- 数值(一般是整数或浮点数)

当然这三种类型都是数值


指令从功能角度划分大概有5类

1. **I/O指令**：比如处理内存间数据交换的 `store` / `load` 等，再比如将一个内存地址的数据转移到另一个内存地址的数据 `mov` 指令

1. **计算指令**： 最多只能处理两个寄存器，比如：加减乘除/位运算/比较大小等

1. **跳转指令**：用处就是修改 PC指针，比如编程中 条件判断 + 跳转的逻辑，`if else` / `switch` / `函数调用` 等

1. **信号指令**：例如终端指令 trap

1. **闲置指令**：nop ，一般 CPU 都有的指令，执行后 CPU 会空转一个周期


指令还可以根据寻址模式区分，比如同样是求和指令，可能会有两个版本
1. 将两个寄存器相加的 add 指令
1. 将一个寄存器和一个整数相加的 addi 指令

另外，同样是加载内存的数据到寄存器的 load 指令，也有不同的寻址模式：

1. 直接加载一个内存地址中的数据到寄存器 la ,叫做直接寻址

1. 将一个数值导入寄存器的指令 li ， 叫做寄存器寻址

1. 将一个寄存器中的数值作为地址，然后再去加载这个地址中的数据 的指令 lw ，叫做间接寻址


因此寻址模式是从指令如何获取数据的角度对指令的分类，目的是给编写指令的人更多选择。


1. 关于寻址模式和所有的指令，只要你不是嵌入式开发人员，就不需要记忆，理解即可。

1. 不同 CPU 的指令和寄存器名称都不一样，因此这些名称也不需要你记忆。

1. 有几个寄存器在所有 CPU 里名字都一样，比如 PC 指针、指令寄存器等。

## 指令的执行速度

CPU 是由石英晶体产生的脉冲转化为时钟信号驱动的，每一次始终信号高低电平的转换就是一个周期，我们称之为 **时钟周期** 。 CPU 的主频，说的就是时钟信号的频率。比如 1GHz 的CPU，说的是时钟信号的频率是 1G。

是不是每个时钟周期都可以执行一条指令？

多数指令都不能在一个时钟周期内完成，通常需要 2/4/6 个时钟周期




# 64位和32位相比有哪些优势

1. 64位CPU可以进行更大数字的运算，这个优势对于普通应用不明显但是对于数值计算较多的应用就非常明显

1. 64位CPU由更大的寻址空间


32位的指令可以在64位CPU机器上执行，但是64位CPU在32位机器上执行就很难了

