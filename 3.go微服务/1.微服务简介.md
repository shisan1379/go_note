
# 微服务演进


## 单体服务

浏览器 -> 服务器 -> 数据库

尽管是模块化逻辑，但最终还是打包并部署为单体应用，可靠性很低，敏捷开发和部署的思路无法完成。

## SOA-面向服务的架构模式


浏览器 -> 多个服务 -> 多个数据库

![](https://raw.githubusercontent.com/shisan1379/img/main/img/202407091022874.png)

- 单一职责： 一个服务只需要做好一件事
  
- 尽可能早地创建原型： 尽早提供API，建立服务契约，至于实现和完善可以慢慢做

- 可移植性比效率更重要： 服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性






## 微服务


**特点**

- 原子服务

- 独立进程

- 隔离部署

- 去中心化服务治理(两个服务之间直连，进行负载均衡)、(服务发现)


**缺点**

1. 基础设施的建设，管理的，复杂度高
2. 微服务是分布式系统，由此会带来固有的复杂性。开发者不得不使用 RPC 或者消息传递，来实现进程间通讯。此外还需要处理代码来解决消息传递中的速度过慢，或者不可用等问题
3. 分区的数据库架构，同时更新多个业务主体的事务很普遍。由于需要同时更新多个数据库，这对开发者提出了更高的要求（分布式事务）
4. 测试一个基于微服务架构的应用也是很复杂的任务
5. 模块间的依赖，应用的升级很可能波及多个服务模块的修改
6. 对运维基础设施的挑战比较大
   




## 实现思路


### 组件服务化

- kit：一个微服务的基础库(框架)
- service: 业务代码+kit 依赖 + 第三方依赖组成的业务微服务
- RPC + Message Queue : 轻量级通讯


### 按照业务组织服务



服务所提供的能力和业务功能相对应。



举例：

大前端(移动/web) -> 网关 -> 业务服务 -> 平台服务 -> 基础设施


开发团队对软件在生产环境的运行负全部责任。


### 基础设施自动化

自动化测试、自动化部署

- CICD: Gitlib 、Gitlib Hooks 、 Kubernetes
- Testing: 测试环境 、 单元测试 、API自动化测试
- 在线运行时： Kubernetes 、 以及一些列 Prometheus 、 ELK 、 Conrtol Panel
  
### 可用性&兼容性设计


1. 隔离
    定义：微服务中的隔离策略主要用于避免单个服务的故障或性能问题影响到整个系统。通过隔离，可以局部化问题，维护系统的稳定性和可靠性。

    常见策略：

    - 动静隔离：将系统的动态内容和静态内容分开处理。动态内容需要实时计算或检索，而静- 态内容（如图片、音视频、CSS、JS文件等）则可直接从文件系统中获取。
    - 读写隔离：将读操作和写操作分离到不同的服务或实例中处理，通常通过CQRS（命令查询- 职责分离）模式实现。
    - 核心隔离：按照服务的核心程度进行分级，优先保障核心业务的稳定运行。
    - 热点隔离：针对高频访问的数据进行隔离，减少对后端存储服务的访问压力。
    - 用户隔离：按照不同的分组形成不同的服务实例，确保某个服务实例的故障不会影响到全- 部用户。
    - 进程隔离：每个进程拥有独立的地址空间，提供操作系统级别的保护。
    - 线程隔离：将不同请求分类发送给不同的线程池，避免单个服务故障影响其他服务。
    - 集群隔离：将某些服务单独部署成集群，或进行分组集群管理。
    - 机房隔离：在不同机房或数据中心部署和运行服务，实现物理层面的隔离。
2. 超时控制
3. 
    定义：微服务中的超时控制用于处理请求响应时间过长的情况，避免用户等待过久或系统资源耗尽。

    实现方式：

    设定请求超时时间，如请求超时、连接超时、读超时、写超时等。
    当请求超过设定的超时时间时，快速返回错误响应，释放系统资源。
    传递超时时间给下游服务，确保整个请求链路的超时控制。
4. 负载保护
    定义：负载保护机制用于防止服务节点在高负载情况下过载甚至崩溃，确保系统的稳定性和可用性。

    常见机制：

    - 流控：设置节点的并发请求数，当达到阈值时拒绝新增请求。
    - 熔断：当服务节点发生异常时，立即断开节点的请求，避免请求继续发送到异常节点上。
    - 降级：在服务器压力剧增时，对一些服务和页面进行降级处理，释放资源以保证核心业务的正常运行。
  
5. 限流
    定义：通过对并发/请求进行限速来保护系统，防止系统过载。

    限流算法：

    - QPS限流：限制每秒的请求数。
    - 令牌桶算法：系统按恒定速率往桶里加入令牌，请求来临时需要拿走一个令牌，否则阻塞或拒绝服务。
    - 漏桶算法：请求以恒定速率进入漏桶，桶满时请求溢出被丢弃。
    实现方式：

    在服务端进行限流计算，防止系统过载。
    为不同的业务客户端提供不同的限流策略。
5. 降级
    定义：在服务器压力剧增时，对一些服务和页面进行策略性的不处理或用简单方式处理，以释放资源保证核心业务的正常运行。

    实现方式：

    对非核心接口和数据请求进行降级处理。
    返回一个友好的提示信息给客户端。
    降级为只读缓存、只更新缓存或打日志而不写数据库等。
6. 重试
    定义：在微服务请求失败时，根据一定的策略重新发起请求。

    实现方式：

    设定重试次数和重试间隔。
    对可重试的错误类型进行区分，避免不必要的重试。
    在重试过程中进行限流和熔断控制，防止系统过载。
7. 负载均衡
    定义：将请求均衡地分发到多个服务节点上，以达到均衡负载的目的。

    常见算法：

    轮询：将请求依次分发到不同的服务节点上。
    加权轮询：给不同的服务节点分配不同的权重，按比例分发请求。
    最少连接数：将请求发送到当前连接数最少的服务节点上。
    最短响应时间：将请求发送到响应时间最短的服务节点上。
    实现方式：

    通过服务网关实现请求的路由和负载均衡。
    选择合适的负载均衡算法进行服务节点的选择。


这些概念和机制共同构成了微服务架构中的高可用性和可靠性保障体系，确保了系统在面对各种挑战时能够稳定运行并快速响应。



# 微服务设计



## BFF层

 BFF层在软件开发中指的是Backend for Frontend（服务于前端的后端），它是一种架构模式，用于构建前端与后端之间的中间层。以下是BFF层在软件开发中的详细解释：

 - 轻量级交互：协议精简、聚合(避免前端为获得部分数据向多个服务请求)
 - 差异服务：针对终端定制API
 - 动态升级：原有系统兼容升级，更新服务而非协议
 - 沟通效率提升：协作模式演进为，移动业务 + 网关小组

BFF 可以认为是一种适配服务，将后端的微服务面向前端进行适配。这样只需要保证暴露统一的API即可

与BFF 相对应的概念是，面向资源，即针对某个数据表的接口。


**缺点**

- 单个模块，也会导致后续业务集成复杂度高
- 很多横跨切面的逻辑，比如安全认证、日志监控、限流熔断等，随着时间的推移代码会变得越来越复杂
- 严重的代码缺陷或流量洪峰可能导致集群宕机



**解决方式**

1. 按照业务场景，拆分多个 BFF、例如移动端、WEB端、管理端等
2. 将横跨切面的逻辑抽取，放置到 API Geteway 层


## APIGeteway

横跨切面的功能（路由、认证、限流、安全），将其全部放入 gateway 层与BFF层解耦。这样各线业务团队，可以独立开发和交付各自的微服务。

## 微服务划分



1. 按照业务职能划分
   由公司内部不同部门提供的职能：例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能

2. 按照DDD划分 - 解决问题
   限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案