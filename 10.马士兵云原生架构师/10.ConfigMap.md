
# 什么是ConfigMap


ConfigMap 是 Kubernetes 提供的一种API对象，用于将 **非机密** 的 **配置数据** 与 容器镜像进行分析，从而实现解耦。

它就是一个专门用来存放配置信息的 **键值对** 存储中心。 应用程序Pod 可以从这里读取 配置，而不需要硬编码在镜像中。


# 核心作用



- 解耦配置与镜像： 配置不嵌入镜像，同一镜像可通过不同的 ConfigMap 适配不同环境（开发、测试、生产）
- 动态更新配置： 部分场景下（如挂载为文件），修改 ConfigMap 后 Pod 内的配置文件会自动同步（需要满足特定条件），无需重启Pod
- 集中管理配置： 多个 Pod 可以共享同一个 ConfigMap 无需重复定义
- 安全隔离非敏感数据： 与敏感数据 Secret 区分（Secret 会对数据编码 / 加密，ConfigMap 明文存储），明确配置数据的敏感级别。



# ConfigMap的创建方式


ConfigMap 支持通过 yaml 和 命令行两种方式创建




## 通过 YAML 文件创建


### 存储键值对

适用于简单的环境变量配置，如：端口、地址等

```yaml
# configmap-demo.yaml
apiVersion: v1  # ConfigMap 属于 v1 版本核心资源
kind: ConfigMap
metadata:
  name: app-config  # ConfigMap 的名称（后续 Pod 需通过此名称引用）
  namespace: default  # 所属命名空间（默认 default，需与 Pod 一致）
data:  # 核心配置数据，键值对格式
  DB_HOST: "mysql-service"  # 键：DB_HOST，值：mysql-service（数据库服务名）
  DB_PORT: "3306"           # 键：DB_PORT，值：3306
  APP_ENV: "production"     # 键：APP_ENV，值：production（环境标识）
```

创建命令
```bash
kubectl apply -f configmap-demo.yaml
```


### 存储于文件内容
适用于配置文件，如 nginx.conf 、 app.properties ，将文件内容作为值，键作为文件名

```yaml
# configmap-file.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  # 键：nginx.conf（文件名），值：文件的完整内容
  nginx.conf: |
    server {
        listen 80;
        server_name localhost;

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }
  # 可同时存储多个文件
  index.html: |
    <h1>Hello from ConfigMap!</h1>
```

### 混合存储


支持在同一个 ConfigMap 中同时存储单个值和文件内容：
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mixed-config
data:
  # 单个值
  LOG_LEVEL: "info"
  # 文件内容
  app.conf: |
    timeout=30s
    max_connections=1000
```

## 通过 kubectl 命令行创建

无需编写 YAML 文件，直接通过 kubectl create configmap 命令快速创建，适合临时测试场景。


### 从键值对创建

```bash
# 格式：kubectl create configmap <名称> --from-literal=键1=值1 --from-literal=键2=值2
kubectl create configmap app-config --from-literal=DB_HOST=mysql-service --from-literal=DB_PORT=3306
```

### 从本地文件创建
将本地文件的内容直接导入 ConfigMap（键为文件名，值为文件内容）：
```bash
# 从单个文件创建：--from-file=<本地文件路径>
kubectl create configmap nginx-config --from-file=./nginx.conf

# 从多个文件创建：多个 --from-file 参数
kubectl create configmap app-config --from-file=./app.conf --from-file=./log.conf

# 自定义键名（不使用默认文件名）：--from-file=<自定义键名>=<本地文件路径>
kubectl create configmap app-config --from-file=my-app-conf=./app.conf
```



### 从 “本地目录” 创建

```bash
# 格式：kubectl create configmap <名称> --from-file=<本地目录路径>
kubectl create configmap app-config --from-file=./config-dir/
# 注：目录下的每个文件会成为 ConfigMap 的一个键，值为文件内容
```

# ConfigMap 的查看与修改


## 查看所有ConfigMap

```bash
root@master:/home/what01# kubectl get configmap
NAME               DATA   AGE
kube-root-ca.crt   1      81d
mixed-config       2      4m47s

root@master:/home/what01# kubectl get cm
NAME               DATA   AGE
kube-root-ca.crt   1      81d
mixed-config       2      6s
```

## 查看单个 ConfigMap 的详情

```bash
root@master:/home/what01# kubectl describe cm mixed-config
Name:         mixed-config
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
app.conf:
----
timeout=30s
max_connections=1000


LOG_LEVEL:
----
info


BinaryData
====

Events:  <none>
```

## 查看 ConfigMap 的 YAML 定义

```bash
root@master:/home/what01# kubectl get cm mixed-config  -o yaml
apiVersion: v1
data:
  LOG_LEVEL: err
  app.conf: |
    timeout=30s
    max_connections=1000
kind: ConfigMap
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"LOG_LEVEL":"err","app.conf":"timeout=30s\nmax_connections=1000\n"},"kind":"ConfigMap","metadata":{"annotations":{},"name":"mixed-config","namespace":"default"}}
  creationTimestamp: "2025-10-14T13:39:17Z"
  name: mixed-config
  namespace: default
  resourceVersion: "3855883"
  uid: c17f62d6-02eb-4201-b9c1-b13e78d481ed

```


## 修改 ConfigMap

ConfigMap 创建后支持修改，修改方式有两种

### 通过YAML文件修改(推荐)
1. 编辑原YAML文件
2. 执行 `kubectl apply -f xxx.yaml`

### 通过命令行编辑

直接在线编辑 ConfigMap 的 YAML 定义
```bash
kubectl edit cm mixed-config 
```


> 修改 ConfigMap 后 Pod 对配置的同步规则：
>
> - 若 ConfigMap 挂载为 **环境变量** ： Pod 不会自动同步修改，需重启 Pod 生效
> - 若 ConfigMap 挂载为 **文件** ： k8s会约在 10秒内同步文件内容，但需应用程序支持 "热加载配置"，如 nginx 需执行 nginx -s reload


# Pod引用 ConfigMap 的方式

Pod 可通过3种方式使用 ConfigMap 中的配置数据，分别适用于不同场景


## 方式1： 作为环境变量注入

将 ConfigMap 中的键值对直接作为 Pod 容器的环境变量，适用于简单的配置如端口、地址


**注入单个环境变量**
```yaml
# pod-env-single.yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: nginx:alpine
    env:
      # 引用 ConfigMap 中的单个键值对
      - name: DB_HOST  # 容器内的环境变量名
        valueFrom:
          configMapKeyRef:
            name: app-config  # 引用的 ConfigMap 名称
            key: DB_HOST      # 引用的 ConfigMap 中的键
      - name: DB_PORT
        valueFrom:
          configMapKeyRef:
            name: app-config
            key: DB_PORT
```
**注入全部键值对**
若需将 ConfigMap 的所有键值对作为环境变量注入，可使用 envFrom：
```yaml
# pod-env-all.yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: nginx:alpine
    envFrom:
      # 批量引用 ConfigMap 的所有键值对
      - configMapRef:
          name: app-config  # 引用的 ConfigMap 名称
```

**验证环境变量**
进入 Pod 容器，直接查看环境变量是否生效
```bash
# 进入容器
kubectl exec -it app-pod -- sh

# 查看环境变量（如 DB_HOST）
echo $DB_HOST  # 输出：mysql-service
```

## 方式2: 作为文件挂载(Volume挂载)


将 ConfigMap 中的键值对（或文件内容）挂载为 Pod 容器内的文件，适用于配置文件（如 nginx.conf、app.properties）。

### 挂载所有键值对为文件

每个键会成为一个文件，文件内容为对应的值，挂载到容器指定的目录

```yaml
# pod-volume-all.yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: nginx:alpine
    volumeMounts:
      # 容器内的挂载目录（需提前存在，或设置 subPath 避免覆盖目录原有内容）
      - name: config-volume  # 与下方 volumes.name 对应
        mountPath: /etc/config  # 容器内的目录，ConfigMap 会挂载到这里
  volumes:
    # 定义 Volume，类型为 configMap
    - name: config-volume
      configMap:
        name: app-config  # 引用的 ConfigMap 名称
```
验证挂载结果
进入容器，查看 /etc/config 目录下的文件：
```bash
kubectl exec -it app-pod -- sh
ls /etc/config  # 输出：DB_HOST  DB_PORT
cat /etc/config/DB_HOST  # 输出：mysql-service
```
### 挂载指定键为文件（自定义文件名）

若只需挂载 ConfigMap 中的部分键，或自定义文件名称，可通过 items 配置：
```bash
# pod-volume-specific.yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: nginx:alpine
    volumeMounts:
      - name: config-volume
        mountPath: /etc/config  # 挂载目录
  volumes:
    - name: config-volume
      configMap:
        name: app-config  # 引用的 ConfigMap 名称
        items:
          # 挂载指定键：DB_HOST，自定义文件名为 db-host.txt
          - key: DB_HOST
            path: db-host.txt  # 容器内的文件名
          # 挂载指定键：DB_PORT，自定义文件名为 db-port.txt
          - key: DB_PORT
            path: db-port.txt
```


### 挂载到已有目录（不覆盖原有文件）


若直接挂载到容器的已有目录（如 /etc/nginx），会覆盖目录下的所有原有文件。此时需通过 subPath 指定 “仅挂载单个文件到目标目录”，避免覆盖：


```yaml
# pod-volume-subpath.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:alpine
    volumeMounts:
      # 仅将 nginx-config 中的 nginx.conf 挂载到 /etc/nginx/nginx.conf
      - name: nginx-config-volume
        mountPath: /etc/nginx/nginx.conf  # 容器内的目标文件路径
        subPath: nginx.conf  # ConfigMap 中的键（对应文件名）
  volumes:
    - name: nginx-config-volume
      configMap:
        name: nginx-config  # 引用存储 nginx.conf 的 ConfigMap
```


### 在容器命令行中的引用
通过 $(ENV_NAME) 语法，在容器的 command 或 args 中直接引用 ConfigMap 注入的环境变量：


```yaml
# pod-cmd-ref.yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app-container
    image: busybox:1.35
    envFrom:
      - configMapRef:
          name: app-config  # 注入所有键值对为环境变量
    # 在命令中引用环境变量
    command: ["sh", "-c", "echo 'DB Host: $(DB_HOST), DB Port: $(DB_PORT)'"]
```


查看 Pod 日志，验证命令执行结果：
```bash
kubectl logs app-pod  # 输出：DB Host: mysql-service, DB Port: 3306
```

# ConfigMap的使用限制与注意事项


1. **敏感数据不适用** ： ConfigMap 中的数据以明文方式存在 etcd 中，且通过 kubectl describe 可以直接查看，禁止存储 密码、密钥 、token 等敏感数据
2. **依赖命名空间隔离**： ConfigMap 是命名空间级别的资源， Pod 只能引用 同一命名空间下的 ConfigMap。 跨命名空间需要通过 ServiceAccount 或第三方工具 如 Kustomize
3. **Pod 引用不存在 Config Map 会导致启动失败**
   - 若 Pod 通过 configMapKeyRef 引用 ConfigMap，且该 ConfigMap 不存在 Pod 会处于 pending 状态
4. **ConfigMap 不可挂载为内存文件系统(tmpfs)** : 默认挂载的文件在容器的可写层，若需要提高性能或避免持久化，可结合 emptDir(tmpfs类型) 使用，但需手动同步 ConfigMap 数据
5. **资源大小限制** ： ConfigMap 的总数据量建议不超过 1MB （etcd 对单个资源的大小限制，避免影响集群性能）







·
